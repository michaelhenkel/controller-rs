// Generated from definition net.juniper.ssd-git.contrail.cn2.contrail.pkg.apis.core.v4.SubnetSpec

/// SubnetSpec defines the desired state of a Subnet.
#[derive(Clone, Debug, Default, PartialEq)]
pub struct SubnetSpec {
    /// Primary IP address used for the BGP as a service session.
    pub bgpaas_primary_ip: Option<String>,

    /// Secondary IP address used for the BGP as a service session when the second control node is present.
    pub bgpaas_secondary_ip: Option<String>,

    /// Subnet range in CIDR notation.
    pub cidr: Option<String>,

    /// Default Gateway IP address in the subnet. If not provided, one is auto-generated by the system.
    pub default_gateway: Option<String>,

    /// Disables auto allocation of BGPaaSPrimaryIP and BGPaaSecondaryIP. False by default, automatic allocation is enabled. IPs are auto allocated when at least one BGPAsAService is configured under this subnet. If DisableBGPaaSIPAutoAllocation is set to true, BGPaaSPrimaryIP and BGPaaSSecondaryIP must be specified. Leave this flag false if the BGPAsAService feature is not required.
    pub disable_bg_paa_sip_auto_allocation: Option<bool>,

    /// List of DNS servers associated with the subnet.
    pub dns_nameservers: Option<Vec<String>>,

    /// Enables or disables vrouter DHCP
    pub enable_dhcp: Option<bool>,

    /// FqName is the list of resource names that fully qualify a Contrail resource.
    pub fq_name: Option<Vec<String>>,

    /// Ranges, when present, define the IP allocation ranges corresponding to a given key. If not provided, IP allocation is determined by the CIDR.
    pub ranges: Option<Vec<crate::ssd_git::contrail::cn2::contrail::pkg::apis::core::v4::Range>>,
}

impl k8s_openapi::DeepMerge for SubnetSpec {
    fn merge_from(&mut self, other: Self) {
        k8s_openapi::DeepMerge::merge_from(&mut self.bgpaas_primary_ip, other.bgpaas_primary_ip);
        k8s_openapi::DeepMerge::merge_from(&mut self.bgpaas_secondary_ip, other.bgpaas_secondary_ip);
        k8s_openapi::DeepMerge::merge_from(&mut self.cidr, other.cidr);
        k8s_openapi::DeepMerge::merge_from(&mut self.default_gateway, other.default_gateway);
        k8s_openapi::DeepMerge::merge_from(&mut self.disable_bg_paa_sip_auto_allocation, other.disable_bg_paa_sip_auto_allocation);
        k8s_openapi::merge_strategies::list::atomic(&mut self.dns_nameservers, other.dns_nameservers);
        k8s_openapi::DeepMerge::merge_from(&mut self.enable_dhcp, other.enable_dhcp);
        k8s_openapi::merge_strategies::list::atomic(&mut self.fq_name, other.fq_name);
        k8s_openapi::merge_strategies::list::atomic(&mut self.ranges, other.ranges);
    }
}

impl<'de> k8s_openapi::serde::Deserialize<'de> for SubnetSpec {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: k8s_openapi::serde::Deserializer<'de> {
        #[allow(non_camel_case_types)]
        enum Field {
            Key_bgpaas_primary_ip,
            Key_bgpaas_secondary_ip,
            Key_cidr,
            Key_default_gateway,
            Key_disable_bg_paa_sip_auto_allocation,
            Key_dns_nameservers,
            Key_enable_dhcp,
            Key_fq_name,
            Key_ranges,
            Other,
        }

        impl<'de> k8s_openapi::serde::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: k8s_openapi::serde::Deserializer<'de> {
                struct Visitor;

                impl<'de> k8s_openapi::serde::de::Visitor<'de> for Visitor {
                    type Value = Field;

                    fn expecting(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_str("field identifier")
                    }

                    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E> where E: k8s_openapi::serde::de::Error {
                        Ok(match v {
                            "bgpaasPrimaryIP" => Field::Key_bgpaas_primary_ip,
                            "bgpaasSecondaryIP" => Field::Key_bgpaas_secondary_ip,
                            "cidr" => Field::Key_cidr,
                            "defaultGateway" => Field::Key_default_gateway,
                            "disableBGPaaSIPAutoAllocation" => Field::Key_disable_bg_paa_sip_auto_allocation,
                            "dnsNameservers" => Field::Key_dns_nameservers,
                            "enableDhcp" => Field::Key_enable_dhcp,
                            "fqName" => Field::Key_fq_name,
                            "ranges" => Field::Key_ranges,
                            _ => Field::Other,
                        })
                    }
                }

                deserializer.deserialize_identifier(Visitor)
            }
        }

        struct Visitor;

        impl<'de> k8s_openapi::serde::de::Visitor<'de> for Visitor {
            type Value = SubnetSpec;

            fn expecting(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_str("SubnetSpec")
            }

            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error> where A: k8s_openapi::serde::de::MapAccess<'de> {
                let mut value_bgpaas_primary_ip: Option<String> = None;
                let mut value_bgpaas_secondary_ip: Option<String> = None;
                let mut value_cidr: Option<String> = None;
                let mut value_default_gateway: Option<String> = None;
                let mut value_disable_bg_paa_sip_auto_allocation: Option<bool> = None;
                let mut value_dns_nameservers: Option<Vec<String>> = None;
                let mut value_enable_dhcp: Option<bool> = None;
                let mut value_fq_name: Option<Vec<String>> = None;
                let mut value_ranges: Option<Vec<crate::ssd_git::contrail::cn2::contrail::pkg::apis::core::v4::Range>> = None;

                while let Some(key) = k8s_openapi::serde::de::MapAccess::next_key::<Field>(&mut map)? {
                    match key {
                        Field::Key_bgpaas_primary_ip => value_bgpaas_primary_ip = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_bgpaas_secondary_ip => value_bgpaas_secondary_ip = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_cidr => value_cidr = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_default_gateway => value_default_gateway = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_disable_bg_paa_sip_auto_allocation => value_disable_bg_paa_sip_auto_allocation = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_dns_nameservers => value_dns_nameservers = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_enable_dhcp => value_enable_dhcp = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_fq_name => value_fq_name = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Key_ranges => value_ranges = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?,
                        Field::Other => { let _: k8s_openapi::serde::de::IgnoredAny = k8s_openapi::serde::de::MapAccess::next_value(&mut map)?; },
                    }
                }

                Ok(SubnetSpec {
                    bgpaas_primary_ip: value_bgpaas_primary_ip,
                    bgpaas_secondary_ip: value_bgpaas_secondary_ip,
                    cidr: value_cidr,
                    default_gateway: value_default_gateway,
                    disable_bg_paa_sip_auto_allocation: value_disable_bg_paa_sip_auto_allocation,
                    dns_nameservers: value_dns_nameservers,
                    enable_dhcp: value_enable_dhcp,
                    fq_name: value_fq_name,
                    ranges: value_ranges,
                })
            }
        }

        deserializer.deserialize_struct(
            "SubnetSpec",
            &[
                "bgpaasPrimaryIP",
                "bgpaasSecondaryIP",
                "cidr",
                "defaultGateway",
                "disableBGPaaSIPAutoAllocation",
                "dnsNameservers",
                "enableDhcp",
                "fqName",
                "ranges",
            ],
            Visitor,
        )
    }
}

impl k8s_openapi::serde::Serialize for SubnetSpec {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: k8s_openapi::serde::Serializer {
        let mut state = serializer.serialize_struct(
            "SubnetSpec",
            self.bgpaas_primary_ip.as_ref().map_or(0, |_| 1) +
            self.bgpaas_secondary_ip.as_ref().map_or(0, |_| 1) +
            self.cidr.as_ref().map_or(0, |_| 1) +
            self.default_gateway.as_ref().map_or(0, |_| 1) +
            self.disable_bg_paa_sip_auto_allocation.as_ref().map_or(0, |_| 1) +
            self.dns_nameservers.as_ref().map_or(0, |_| 1) +
            self.enable_dhcp.as_ref().map_or(0, |_| 1) +
            self.fq_name.as_ref().map_or(0, |_| 1) +
            self.ranges.as_ref().map_or(0, |_| 1),
        )?;
        if let Some(value) = &self.bgpaas_primary_ip {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "bgpaasPrimaryIP", value)?;
        }
        if let Some(value) = &self.bgpaas_secondary_ip {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "bgpaasSecondaryIP", value)?;
        }
        if let Some(value) = &self.cidr {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "cidr", value)?;
        }
        if let Some(value) = &self.default_gateway {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "defaultGateway", value)?;
        }
        if let Some(value) = &self.disable_bg_paa_sip_auto_allocation {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "disableBGPaaSIPAutoAllocation", value)?;
        }
        if let Some(value) = &self.dns_nameservers {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "dnsNameservers", value)?;
        }
        if let Some(value) = &self.enable_dhcp {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "enableDhcp", value)?;
        }
        if let Some(value) = &self.fq_name {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "fqName", value)?;
        }
        if let Some(value) = &self.ranges {
            k8s_openapi::serde::ser::SerializeStruct::serialize_field(&mut state, "ranges", value)?;
        }
        k8s_openapi::serde::ser::SerializeStruct::end(state)
    }
}

#[cfg(feature = "schemars")]
impl crate::schemars::JsonSchema for SubnetSpec {
    fn schema_name() -> String {
        "net.juniper.ssd-git.contrail.cn2.contrail.pkg.apis.core.v4.SubnetSpec".to_owned()
    }

    fn json_schema(__gen: &mut crate::schemars::gen::SchemaGenerator) -> crate::schemars::schema::Schema {
        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                description: Some("SubnetSpec defines the desired state of a Subnet.".to_owned()),
                ..Default::default()
            })),
            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Object))),
            object: Some(Box::new(crate::schemars::schema::ObjectValidation {
                properties: [
                    (
                        "bgpaasPrimaryIP".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Primary IP address used for the BGP as a service session.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "bgpaasSecondaryIP".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Secondary IP address used for the BGP as a service session when the second control node is present.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "cidr".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Subnet range in CIDR notation.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "defaultGateway".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Default Gateway IP address in the subnet. If not provided, one is auto-generated by the system.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "disableBGPaaSIPAutoAllocation".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Disables auto allocation of BGPaaSPrimaryIP and BGPaaSecondaryIP. False by default, automatic allocation is enabled. IPs are auto allocated when at least one BGPAsAService is configured under this subnet. If DisableBGPaaSIPAutoAllocation is set to true, BGPaaSPrimaryIP and BGPaaSSecondaryIP must be specified. Leave this flag false if the BGPAsAService feature is not required.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Boolean))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "dnsNameservers".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("List of DNS servers associated with the subnet.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Array))),
                            array: Some(Box::new(crate::schemars::schema::ArrayValidation {
                                items: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(
                                    crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                                        instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                                        ..Default::default()
                                    })
                                ))),
                                ..Default::default()
                            })),
                            ..Default::default()
                        }),
                    ),
                    (
                        "enableDhcp".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Enables or disables vrouter DHCP".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Boolean))),
                            ..Default::default()
                        }),
                    ),
                    (
                        "fqName".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("FqName is the list of resource names that fully qualify a Contrail resource.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Array))),
                            array: Some(Box::new(crate::schemars::schema::ArrayValidation {
                                items: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(
                                    crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                                        instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::String))),
                                        ..Default::default()
                                    })
                                ))),
                                ..Default::default()
                            })),
                            ..Default::default()
                        }),
                    ),
                    (
                        "ranges".to_owned(),
                        crate::schemars::schema::Schema::Object(crate::schemars::schema::SchemaObject {
                            metadata: Some(Box::new(crate::schemars::schema::Metadata {
                                description: Some("Ranges, when present, define the IP allocation ranges corresponding to a given key. If not provided, IP allocation is determined by the CIDR.".to_owned()),
                                ..Default::default()
                            })),
                            instance_type: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(crate::schemars::schema::InstanceType::Array))),
                            array: Some(Box::new(crate::schemars::schema::ArrayValidation {
                                items: Some(crate::schemars::schema::SingleOrVec::Single(Box::new(__gen.subschema_for::<crate::ssd_git::contrail::cn2::contrail::pkg::apis::core::v4::Range>()))),
                                ..Default::default()
                            })),
                            ..Default::default()
                        }),
                    ),
                ].into(),
                ..Default::default()
            })),
            ..Default::default()
        })
    }
}
