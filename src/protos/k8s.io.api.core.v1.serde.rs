impl serde::Serialize for AwsElasticBlockStoreVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_id.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.partition.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource", len)?;
        if let Some(v) = self.volume_id.as_ref() {
            struct_ser.serialize_field("volumeID", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.partition.as_ref() {
            struct_ser.serialize_field("partition", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AwsElasticBlockStoreVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeID",
            "fsType",
            "partition",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeId,
            FsType,
            Partition,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeID" => Ok(GeneratedField::VolumeId),
                            "fsType" => Ok(GeneratedField::FsType),
                            "partition" => Ok(GeneratedField::Partition),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AwsElasticBlockStoreVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AwsElasticBlockStoreVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_id__ = None;
                let mut fs_type__ = None;
                let mut partition__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeId => {
                            if volume_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeID"));
                            }
                            volume_id__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::Partition => {
                            if partition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partition"));
                            }
                            partition__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AwsElasticBlockStoreVolumeSource {
                    volume_id: volume_id__,
                    fs_type: fs_type__,
                    partition: partition__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Affinity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.node_affinity.is_some() {
            len += 1;
        }
        if self.pod_affinity.is_some() {
            len += 1;
        }
        if self.pod_anti_affinity.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Affinity", len)?;
        if let Some(v) = self.node_affinity.as_ref() {
            struct_ser.serialize_field("nodeAffinity", v)?;
        }
        if let Some(v) = self.pod_affinity.as_ref() {
            struct_ser.serialize_field("podAffinity", v)?;
        }
        if let Some(v) = self.pod_anti_affinity.as_ref() {
            struct_ser.serialize_field("podAntiAffinity", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Affinity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "nodeAffinity",
            "podAffinity",
            "podAntiAffinity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NodeAffinity,
            PodAffinity,
            PodAntiAffinity,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nodeAffinity" => Ok(GeneratedField::NodeAffinity),
                            "podAffinity" => Ok(GeneratedField::PodAffinity),
                            "podAntiAffinity" => Ok(GeneratedField::PodAntiAffinity),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Affinity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Affinity")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Affinity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut node_affinity__ = None;
                let mut pod_affinity__ = None;
                let mut pod_anti_affinity__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::NodeAffinity => {
                            if node_affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeAffinity"));
                            }
                            node_affinity__ = map.next_value()?;
                        }
                        GeneratedField::PodAffinity => {
                            if pod_affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podAffinity"));
                            }
                            pod_affinity__ = map.next_value()?;
                        }
                        GeneratedField::PodAntiAffinity => {
                            if pod_anti_affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podAntiAffinity"));
                            }
                            pod_anti_affinity__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Affinity {
                    node_affinity: node_affinity__,
                    pod_affinity: pod_affinity__,
                    pod_anti_affinity: pod_anti_affinity__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Affinity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AttachedVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.device_path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AttachedVolume", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.device_path.as_ref() {
            struct_ser.serialize_field("devicePath", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AttachedVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "devicePath",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            DevicePath,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "devicePath" => Ok(GeneratedField::DevicePath),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AttachedVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AttachedVolume")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AttachedVolume, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut device_path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::DevicePath => {
                            if device_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("devicePath"));
                            }
                            device_path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AttachedVolume {
                    name: name__,
                    device_path: device_path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AttachedVolume", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AvoidPods {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.prefer_avoid_pods.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AvoidPods", len)?;
        if !self.prefer_avoid_pods.is_empty() {
            struct_ser.serialize_field("preferAvoidPods", &self.prefer_avoid_pods)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AvoidPods {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "preferAvoidPods",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PreferAvoidPods,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "preferAvoidPods" => Ok(GeneratedField::PreferAvoidPods),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AvoidPods;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AvoidPods")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AvoidPods, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prefer_avoid_pods__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PreferAvoidPods => {
                            if prefer_avoid_pods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preferAvoidPods"));
                            }
                            prefer_avoid_pods__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AvoidPods {
                    prefer_avoid_pods: prefer_avoid_pods__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AvoidPods", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AzureDiskVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.disk_name.is_some() {
            len += 1;
        }
        if self.disk_uri.is_some() {
            len += 1;
        }
        if self.caching_mode.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AzureDiskVolumeSource", len)?;
        if let Some(v) = self.disk_name.as_ref() {
            struct_ser.serialize_field("diskName", v)?;
        }
        if let Some(v) = self.disk_uri.as_ref() {
            struct_ser.serialize_field("diskURI", v)?;
        }
        if let Some(v) = self.caching_mode.as_ref() {
            struct_ser.serialize_field("cachingMode", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            struct_ser.serialize_field("kind", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AzureDiskVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "diskName",
            "diskURI",
            "cachingMode",
            "fsType",
            "readOnly",
            "kind",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DiskName,
            DiskUri,
            CachingMode,
            FsType,
            ReadOnly,
            Kind,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "diskName" => Ok(GeneratedField::DiskName),
                            "diskURI" => Ok(GeneratedField::DiskUri),
                            "cachingMode" => Ok(GeneratedField::CachingMode),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "kind" => Ok(GeneratedField::Kind),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AzureDiskVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AzureDiskVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AzureDiskVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut disk_name__ = None;
                let mut disk_uri__ = None;
                let mut caching_mode__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut kind__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::DiskName => {
                            if disk_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("diskName"));
                            }
                            disk_name__ = map.next_value()?;
                        }
                        GeneratedField::DiskUri => {
                            if disk_uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("diskURI"));
                            }
                            disk_uri__ = map.next_value()?;
                        }
                        GeneratedField::CachingMode => {
                            if caching_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cachingMode"));
                            }
                            caching_mode__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AzureDiskVolumeSource {
                    disk_name: disk_name__,
                    disk_uri: disk_uri__,
                    caching_mode: caching_mode__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AzureDiskVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AzureFilePersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.secret_name.is_some() {
            len += 1;
        }
        if self.share_name.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.secret_namespace.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AzureFilePersistentVolumeSource", len)?;
        if let Some(v) = self.secret_name.as_ref() {
            struct_ser.serialize_field("secretName", v)?;
        }
        if let Some(v) = self.share_name.as_ref() {
            struct_ser.serialize_field("shareName", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.secret_namespace.as_ref() {
            struct_ser.serialize_field("secretNamespace", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AzureFilePersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "secretName",
            "shareName",
            "readOnly",
            "secretNamespace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SecretName,
            ShareName,
            ReadOnly,
            SecretNamespace,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "secretName" => Ok(GeneratedField::SecretName),
                            "shareName" => Ok(GeneratedField::ShareName),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "secretNamespace" => Ok(GeneratedField::SecretNamespace),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AzureFilePersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AzureFilePersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AzureFilePersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut secret_name__ = None;
                let mut share_name__ = None;
                let mut read_only__ = None;
                let mut secret_namespace__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::SecretName => {
                            if secret_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretName"));
                            }
                            secret_name__ = map.next_value()?;
                        }
                        GeneratedField::ShareName => {
                            if share_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shareName"));
                            }
                            share_name__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::SecretNamespace => {
                            if secret_namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretNamespace"));
                            }
                            secret_namespace__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AzureFilePersistentVolumeSource {
                    secret_name: secret_name__,
                    share_name: share_name__,
                    read_only: read_only__,
                    secret_namespace: secret_namespace__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AzureFilePersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AzureFileVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.secret_name.is_some() {
            len += 1;
        }
        if self.share_name.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.AzureFileVolumeSource", len)?;
        if let Some(v) = self.secret_name.as_ref() {
            struct_ser.serialize_field("secretName", v)?;
        }
        if let Some(v) = self.share_name.as_ref() {
            struct_ser.serialize_field("shareName", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AzureFileVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "secretName",
            "shareName",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SecretName,
            ShareName,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "secretName" => Ok(GeneratedField::SecretName),
                            "shareName" => Ok(GeneratedField::ShareName),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AzureFileVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.AzureFileVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<AzureFileVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut secret_name__ = None;
                let mut share_name__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::SecretName => {
                            if secret_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretName"));
                            }
                            secret_name__ = map.next_value()?;
                        }
                        GeneratedField::ShareName => {
                            if share_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shareName"));
                            }
                            share_name__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AzureFileVolumeSource {
                    secret_name: secret_name__,
                    share_name: share_name__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.AzureFileVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Binding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.target.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Binding", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.target.as_ref() {
            struct_ser.serialize_field("target", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Binding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "target",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Target,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "target" => Ok(GeneratedField::Target),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Binding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Binding")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Binding, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut target__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Binding {
                    metadata: metadata__,
                    target: target__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Binding", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CsiPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.driver.is_some() {
            len += 1;
        }
        if self.volume_handle.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if !self.volume_attributes.is_empty() {
            len += 1;
        }
        if self.controller_publish_secret_ref.is_some() {
            len += 1;
        }
        if self.node_stage_secret_ref.is_some() {
            len += 1;
        }
        if self.node_publish_secret_ref.is_some() {
            len += 1;
        }
        if self.controller_expand_secret_ref.is_some() {
            len += 1;
        }
        if self.node_expand_secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CSIPersistentVolumeSource", len)?;
        if let Some(v) = self.driver.as_ref() {
            struct_ser.serialize_field("driver", v)?;
        }
        if let Some(v) = self.volume_handle.as_ref() {
            struct_ser.serialize_field("volumeHandle", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if !self.volume_attributes.is_empty() {
            struct_ser.serialize_field("volumeAttributes", &self.volume_attributes)?;
        }
        if let Some(v) = self.controller_publish_secret_ref.as_ref() {
            struct_ser.serialize_field("controllerPublishSecretRef", v)?;
        }
        if let Some(v) = self.node_stage_secret_ref.as_ref() {
            struct_ser.serialize_field("nodeStageSecretRef", v)?;
        }
        if let Some(v) = self.node_publish_secret_ref.as_ref() {
            struct_ser.serialize_field("nodePublishSecretRef", v)?;
        }
        if let Some(v) = self.controller_expand_secret_ref.as_ref() {
            struct_ser.serialize_field("controllerExpandSecretRef", v)?;
        }
        if let Some(v) = self.node_expand_secret_ref.as_ref() {
            struct_ser.serialize_field("nodeExpandSecretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CsiPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "driver",
            "volumeHandle",
            "readOnly",
            "fsType",
            "volumeAttributes",
            "controllerPublishSecretRef",
            "nodeStageSecretRef",
            "nodePublishSecretRef",
            "controllerExpandSecretRef",
            "nodeExpandSecretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Driver,
            VolumeHandle,
            ReadOnly,
            FsType,
            VolumeAttributes,
            ControllerPublishSecretRef,
            NodeStageSecretRef,
            NodePublishSecretRef,
            ControllerExpandSecretRef,
            NodeExpandSecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "driver" => Ok(GeneratedField::Driver),
                            "volumeHandle" => Ok(GeneratedField::VolumeHandle),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "fsType" => Ok(GeneratedField::FsType),
                            "volumeAttributes" => Ok(GeneratedField::VolumeAttributes),
                            "controllerPublishSecretRef" => Ok(GeneratedField::ControllerPublishSecretRef),
                            "nodeStageSecretRef" => Ok(GeneratedField::NodeStageSecretRef),
                            "nodePublishSecretRef" => Ok(GeneratedField::NodePublishSecretRef),
                            "controllerExpandSecretRef" => Ok(GeneratedField::ControllerExpandSecretRef),
                            "nodeExpandSecretRef" => Ok(GeneratedField::NodeExpandSecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CsiPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CSIPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CsiPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut driver__ = None;
                let mut volume_handle__ = None;
                let mut read_only__ = None;
                let mut fs_type__ = None;
                let mut volume_attributes__ = None;
                let mut controller_publish_secret_ref__ = None;
                let mut node_stage_secret_ref__ = None;
                let mut node_publish_secret_ref__ = None;
                let mut controller_expand_secret_ref__ = None;
                let mut node_expand_secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Driver => {
                            if driver__.is_some() {
                                return Err(serde::de::Error::duplicate_field("driver"));
                            }
                            driver__ = map.next_value()?;
                        }
                        GeneratedField::VolumeHandle => {
                            if volume_handle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeHandle"));
                            }
                            volume_handle__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::VolumeAttributes => {
                            if volume_attributes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeAttributes"));
                            }
                            volume_attributes__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::ControllerPublishSecretRef => {
                            if controller_publish_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("controllerPublishSecretRef"));
                            }
                            controller_publish_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::NodeStageSecretRef => {
                            if node_stage_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeStageSecretRef"));
                            }
                            node_stage_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::NodePublishSecretRef => {
                            if node_publish_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodePublishSecretRef"));
                            }
                            node_publish_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ControllerExpandSecretRef => {
                            if controller_expand_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("controllerExpandSecretRef"));
                            }
                            controller_expand_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::NodeExpandSecretRef => {
                            if node_expand_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeExpandSecretRef"));
                            }
                            node_expand_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CsiPersistentVolumeSource {
                    driver: driver__,
                    volume_handle: volume_handle__,
                    read_only: read_only__,
                    fs_type: fs_type__,
                    volume_attributes: volume_attributes__.unwrap_or_default(),
                    controller_publish_secret_ref: controller_publish_secret_ref__,
                    node_stage_secret_ref: node_stage_secret_ref__,
                    node_publish_secret_ref: node_publish_secret_ref__,
                    controller_expand_secret_ref: controller_expand_secret_ref__,
                    node_expand_secret_ref: node_expand_secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CSIPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CsiVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.driver.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if !self.volume_attributes.is_empty() {
            len += 1;
        }
        if self.node_publish_secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CSIVolumeSource", len)?;
        if let Some(v) = self.driver.as_ref() {
            struct_ser.serialize_field("driver", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if !self.volume_attributes.is_empty() {
            struct_ser.serialize_field("volumeAttributes", &self.volume_attributes)?;
        }
        if let Some(v) = self.node_publish_secret_ref.as_ref() {
            struct_ser.serialize_field("nodePublishSecretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CsiVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "driver",
            "readOnly",
            "fsType",
            "volumeAttributes",
            "nodePublishSecretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Driver,
            ReadOnly,
            FsType,
            VolumeAttributes,
            NodePublishSecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "driver" => Ok(GeneratedField::Driver),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "fsType" => Ok(GeneratedField::FsType),
                            "volumeAttributes" => Ok(GeneratedField::VolumeAttributes),
                            "nodePublishSecretRef" => Ok(GeneratedField::NodePublishSecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CsiVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CSIVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CsiVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut driver__ = None;
                let mut read_only__ = None;
                let mut fs_type__ = None;
                let mut volume_attributes__ = None;
                let mut node_publish_secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Driver => {
                            if driver__.is_some() {
                                return Err(serde::de::Error::duplicate_field("driver"));
                            }
                            driver__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::VolumeAttributes => {
                            if volume_attributes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeAttributes"));
                            }
                            volume_attributes__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::NodePublishSecretRef => {
                            if node_publish_secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodePublishSecretRef"));
                            }
                            node_publish_secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CsiVolumeSource {
                    driver: driver__,
                    read_only: read_only__,
                    fs_type: fs_type__,
                    volume_attributes: volume_attributes__.unwrap_or_default(),
                    node_publish_secret_ref: node_publish_secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CSIVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Capabilities {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.add.is_empty() {
            len += 1;
        }
        if !self.drop.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Capabilities", len)?;
        if !self.add.is_empty() {
            struct_ser.serialize_field("add", &self.add)?;
        }
        if !self.drop.is_empty() {
            struct_ser.serialize_field("drop", &self.drop)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Capabilities {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "add",
            "drop",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Add,
            Drop,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "add" => Ok(GeneratedField::Add),
                            "drop" => Ok(GeneratedField::Drop),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Capabilities;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Capabilities")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Capabilities, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut add__ = None;
                let mut drop__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Add => {
                            if add__.is_some() {
                                return Err(serde::de::Error::duplicate_field("add"));
                            }
                            add__ = Some(map.next_value()?);
                        }
                        GeneratedField::Drop => {
                            if drop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("drop"));
                            }
                            drop__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Capabilities {
                    add: add__.unwrap_or_default(),
                    drop: drop__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Capabilities", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CephFsPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monitors.is_empty() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.user.is_some() {
            len += 1;
        }
        if self.secret_file.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CephFSPersistentVolumeSource", len)?;
        if !self.monitors.is_empty() {
            struct_ser.serialize_field("monitors", &self.monitors)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.secret_file.as_ref() {
            struct_ser.serialize_field("secretFile", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CephFsPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "monitors",
            "path",
            "user",
            "secretFile",
            "secretRef",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Monitors,
            Path,
            User,
            SecretFile,
            SecretRef,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "monitors" => Ok(GeneratedField::Monitors),
                            "path" => Ok(GeneratedField::Path),
                            "user" => Ok(GeneratedField::User),
                            "secretFile" => Ok(GeneratedField::SecretFile),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CephFsPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CephFSPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CephFsPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monitors__ = None;
                let mut path__ = None;
                let mut user__ = None;
                let mut secret_file__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Monitors => {
                            if monitors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("monitors"));
                            }
                            monitors__ = Some(map.next_value()?);
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::SecretFile => {
                            if secret_file__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretFile"));
                            }
                            secret_file__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CephFsPersistentVolumeSource {
                    monitors: monitors__.unwrap_or_default(),
                    path: path__,
                    user: user__,
                    secret_file: secret_file__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CephFSPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CephFsVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monitors.is_empty() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.user.is_some() {
            len += 1;
        }
        if self.secret_file.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CephFSVolumeSource", len)?;
        if !self.monitors.is_empty() {
            struct_ser.serialize_field("monitors", &self.monitors)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.secret_file.as_ref() {
            struct_ser.serialize_field("secretFile", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CephFsVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "monitors",
            "path",
            "user",
            "secretFile",
            "secretRef",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Monitors,
            Path,
            User,
            SecretFile,
            SecretRef,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "monitors" => Ok(GeneratedField::Monitors),
                            "path" => Ok(GeneratedField::Path),
                            "user" => Ok(GeneratedField::User),
                            "secretFile" => Ok(GeneratedField::SecretFile),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CephFsVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CephFSVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CephFsVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monitors__ = None;
                let mut path__ = None;
                let mut user__ = None;
                let mut secret_file__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Monitors => {
                            if monitors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("monitors"));
                            }
                            monitors__ = Some(map.next_value()?);
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::SecretFile => {
                            if secret_file__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretFile"));
                            }
                            secret_file__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CephFsVolumeSource {
                    monitors: monitors__.unwrap_or_default(),
                    path: path__,
                    user: user__,
                    secret_file: secret_file__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CephFSVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CinderPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_id.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CinderPersistentVolumeSource", len)?;
        if let Some(v) = self.volume_id.as_ref() {
            struct_ser.serialize_field("volumeID", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CinderPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeID",
            "fsType",
            "readOnly",
            "secretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeId,
            FsType,
            ReadOnly,
            SecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeID" => Ok(GeneratedField::VolumeId),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CinderPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CinderPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CinderPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_id__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeId => {
                            if volume_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeID"));
                            }
                            volume_id__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CinderPersistentVolumeSource {
                    volume_id: volume_id__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    secret_ref: secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CinderPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CinderVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_id.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.CinderVolumeSource", len)?;
        if let Some(v) = self.volume_id.as_ref() {
            struct_ser.serialize_field("volumeID", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CinderVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeID",
            "fsType",
            "readOnly",
            "secretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeId,
            FsType,
            ReadOnly,
            SecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeID" => Ok(GeneratedField::VolumeId),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CinderVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.CinderVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<CinderVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_id__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeId => {
                            if volume_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeID"));
                            }
                            volume_id__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CinderVolumeSource {
                    volume_id: volume_id__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    secret_ref: secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.CinderVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClaimSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.resource_claim_name.is_some() {
            len += 1;
        }
        if self.resource_claim_template_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ClaimSource", len)?;
        if let Some(v) = self.resource_claim_name.as_ref() {
            struct_ser.serialize_field("resourceClaimName", v)?;
        }
        if let Some(v) = self.resource_claim_template_name.as_ref() {
            struct_ser.serialize_field("resourceClaimTemplateName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClaimSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "resourceClaimName",
            "resourceClaimTemplateName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResourceClaimName,
            ResourceClaimTemplateName,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "resourceClaimName" => Ok(GeneratedField::ResourceClaimName),
                            "resourceClaimTemplateName" => Ok(GeneratedField::ResourceClaimTemplateName),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClaimSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ClaimSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ClaimSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resource_claim_name__ = None;
                let mut resource_claim_template_name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ResourceClaimName => {
                            if resource_claim_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceClaimName"));
                            }
                            resource_claim_name__ = map.next_value()?;
                        }
                        GeneratedField::ResourceClaimTemplateName => {
                            if resource_claim_template_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceClaimTemplateName"));
                            }
                            resource_claim_template_name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ClaimSource {
                    resource_claim_name: resource_claim_name__,
                    resource_claim_template_name: resource_claim_template_name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ClaimSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientIpConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timeout_seconds.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ClientIPConfig", len)?;
        if let Some(v) = self.timeout_seconds.as_ref() {
            struct_ser.serialize_field("timeoutSeconds", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientIpConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timeoutSeconds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimeoutSeconds,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timeoutSeconds" => Ok(GeneratedField::TimeoutSeconds),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientIpConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ClientIPConfig")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ClientIpConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timeout_seconds__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::TimeoutSeconds => {
                            if timeout_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timeoutSeconds"));
                            }
                            timeout_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ClientIpConfig {
                    timeout_seconds: timeout_seconds__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ClientIPConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ComponentCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        if self.error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ComponentCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.error.as_ref() {
            struct_ser.serialize_field("error", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ComponentCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "message",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            Message,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "message" => Ok(GeneratedField::Message),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ComponentCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ComponentCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ComponentCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut message__ = None;
                let mut error__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::Error => {
                            if error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            error__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ComponentCondition {
                    r#type: r#type__,
                    status: status__,
                    message: message__,
                    error: error__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ComponentCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ComponentStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ComponentStatus", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ComponentStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "conditions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Conditions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "conditions" => Ok(GeneratedField::Conditions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ComponentStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ComponentStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ComponentStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut conditions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ComponentStatus {
                    metadata: metadata__,
                    conditions: conditions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ComponentStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ComponentStatusList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ComponentStatusList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ComponentStatusList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ComponentStatusList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ComponentStatusList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ComponentStatusList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ComponentStatusList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ComponentStatusList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMap {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.immutable.is_some() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        if !self.binary_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMap", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.immutable.as_ref() {
            struct_ser.serialize_field("immutable", v)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        if !self.binary_data.is_empty() {
            let v: std::collections::HashMap<_, _> = self.binary_data.iter()
                .map(|(k, v)| (k, pbjson::private::base64::encode(v))).collect();
            struct_ser.serialize_field("binaryData", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMap {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "immutable",
            "data",
            "binaryData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Immutable,
            Data,
            BinaryData,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "immutable" => Ok(GeneratedField::Immutable),
                            "data" => Ok(GeneratedField::Data),
                            "binaryData" => Ok(GeneratedField::BinaryData),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMap;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMap")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMap, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut immutable__ = None;
                let mut data__ = None;
                let mut binary_data__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Immutable => {
                            if immutable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("immutable"));
                            }
                            immutable__ = map.next_value()?;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::BinaryData => {
                            if binary_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("binaryData"));
                            }
                            binary_data__ = Some(
                                map.next_value::<std::collections::HashMap<_, ::pbjson::private::BytesDeserialize<_>>>()?
                                    .into_iter().map(|(k,v)| (k, v.0)).collect()
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMap {
                    metadata: metadata__,
                    immutable: immutable__,
                    data: data__.unwrap_or_default(),
                    binary_data: binary_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMap", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapEnvSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapEnvSource", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapEnvSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapEnvSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapEnvSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapEnvSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapEnvSource {
                    local_object_reference: local_object_reference__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapEnvSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapKeySelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if self.key.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapKeySelector", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapKeySelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "key",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Key,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "key" => Ok(GeneratedField::Key),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapKeySelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapKeySelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapKeySelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut key__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapKeySelector {
                    local_object_reference: local_object_reference__,
                    key: key__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapKeySelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapNodeConfigSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.namespace.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.uid.is_some() {
            len += 1;
        }
        if self.resource_version.is_some() {
            len += 1;
        }
        if self.kubelet_config_key.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapNodeConfigSource", len)?;
        if let Some(v) = self.namespace.as_ref() {
            struct_ser.serialize_field("namespace", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            struct_ser.serialize_field("uid", v)?;
        }
        if let Some(v) = self.resource_version.as_ref() {
            struct_ser.serialize_field("resourceVersion", v)?;
        }
        if let Some(v) = self.kubelet_config_key.as_ref() {
            struct_ser.serialize_field("kubeletConfigKey", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapNodeConfigSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "namespace",
            "name",
            "uid",
            "resourceVersion",
            "kubeletConfigKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Namespace,
            Name,
            Uid,
            ResourceVersion,
            KubeletConfigKey,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "namespace" => Ok(GeneratedField::Namespace),
                            "name" => Ok(GeneratedField::Name),
                            "uid" => Ok(GeneratedField::Uid),
                            "resourceVersion" => Ok(GeneratedField::ResourceVersion),
                            "kubeletConfigKey" => Ok(GeneratedField::KubeletConfigKey),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapNodeConfigSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapNodeConfigSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapNodeConfigSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut namespace__ = None;
                let mut name__ = None;
                let mut uid__ = None;
                let mut resource_version__ = None;
                let mut kubelet_config_key__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Namespace => {
                            if namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespace"));
                            }
                            namespace__ = map.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = map.next_value()?;
                        }
                        GeneratedField::ResourceVersion => {
                            if resource_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceVersion"));
                            }
                            resource_version__ = map.next_value()?;
                        }
                        GeneratedField::KubeletConfigKey => {
                            if kubelet_config_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kubeletConfigKey"));
                            }
                            kubelet_config_key__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapNodeConfigSource {
                    namespace: namespace__,
                    name: name__,
                    uid: uid__,
                    resource_version: resource_version__,
                    kubelet_config_key: kubelet_config_key__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapNodeConfigSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapProjection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapProjection", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapProjection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "items",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Items,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "items" => Ok(GeneratedField::Items),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapProjection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapProjection")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapProjection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut items__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapProjection {
                    local_object_reference: local_object_reference__,
                    items: items__.unwrap_or_default(),
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapProjection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConfigMapVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.default_mode.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ConfigMapVolumeSource", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.default_mode.as_ref() {
            struct_ser.serialize_field("defaultMode", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConfigMapVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "items",
            "defaultMode",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Items,
            DefaultMode,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "items" => Ok(GeneratedField::Items),
                            "defaultMode" => Ok(GeneratedField::DefaultMode),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConfigMapVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ConfigMapVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ConfigMapVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut items__ = None;
                let mut default_mode__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::DefaultMode => {
                            if default_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultMode"));
                            }
                            default_mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConfigMapVolumeSource {
                    local_object_reference: local_object_reference__,
                    items: items__.unwrap_or_default(),
                    default_mode: default_mode__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ConfigMapVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Container {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.image.is_some() {
            len += 1;
        }
        if !self.command.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.working_dir.is_some() {
            len += 1;
        }
        if !self.ports.is_empty() {
            len += 1;
        }
        if !self.env_from.is_empty() {
            len += 1;
        }
        if !self.env.is_empty() {
            len += 1;
        }
        if self.resources.is_some() {
            len += 1;
        }
        if !self.resize_policy.is_empty() {
            len += 1;
        }
        if !self.volume_mounts.is_empty() {
            len += 1;
        }
        if !self.volume_devices.is_empty() {
            len += 1;
        }
        if self.liveness_probe.is_some() {
            len += 1;
        }
        if self.readiness_probe.is_some() {
            len += 1;
        }
        if self.startup_probe.is_some() {
            len += 1;
        }
        if self.lifecycle.is_some() {
            len += 1;
        }
        if self.termination_message_path.is_some() {
            len += 1;
        }
        if self.termination_message_policy.is_some() {
            len += 1;
        }
        if self.image_pull_policy.is_some() {
            len += 1;
        }
        if self.security_context.is_some() {
            len += 1;
        }
        if self.stdin.is_some() {
            len += 1;
        }
        if self.stdin_once.is_some() {
            len += 1;
        }
        if self.tty.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Container", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.image.as_ref() {
            struct_ser.serialize_field("image", v)?;
        }
        if !self.command.is_empty() {
            struct_ser.serialize_field("command", &self.command)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.working_dir.as_ref() {
            struct_ser.serialize_field("workingDir", v)?;
        }
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        if !self.env_from.is_empty() {
            struct_ser.serialize_field("envFrom", &self.env_from)?;
        }
        if !self.env.is_empty() {
            struct_ser.serialize_field("env", &self.env)?;
        }
        if let Some(v) = self.resources.as_ref() {
            struct_ser.serialize_field("resources", v)?;
        }
        if !self.resize_policy.is_empty() {
            struct_ser.serialize_field("resizePolicy", &self.resize_policy)?;
        }
        if !self.volume_mounts.is_empty() {
            struct_ser.serialize_field("volumeMounts", &self.volume_mounts)?;
        }
        if !self.volume_devices.is_empty() {
            struct_ser.serialize_field("volumeDevices", &self.volume_devices)?;
        }
        if let Some(v) = self.liveness_probe.as_ref() {
            struct_ser.serialize_field("livenessProbe", v)?;
        }
        if let Some(v) = self.readiness_probe.as_ref() {
            struct_ser.serialize_field("readinessProbe", v)?;
        }
        if let Some(v) = self.startup_probe.as_ref() {
            struct_ser.serialize_field("startupProbe", v)?;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            struct_ser.serialize_field("lifecycle", v)?;
        }
        if let Some(v) = self.termination_message_path.as_ref() {
            struct_ser.serialize_field("terminationMessagePath", v)?;
        }
        if let Some(v) = self.termination_message_policy.as_ref() {
            struct_ser.serialize_field("terminationMessagePolicy", v)?;
        }
        if let Some(v) = self.image_pull_policy.as_ref() {
            struct_ser.serialize_field("imagePullPolicy", v)?;
        }
        if let Some(v) = self.security_context.as_ref() {
            struct_ser.serialize_field("securityContext", v)?;
        }
        if let Some(v) = self.stdin.as_ref() {
            struct_ser.serialize_field("stdin", v)?;
        }
        if let Some(v) = self.stdin_once.as_ref() {
            struct_ser.serialize_field("stdinOnce", v)?;
        }
        if let Some(v) = self.tty.as_ref() {
            struct_ser.serialize_field("tty", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Container {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "image",
            "command",
            "args",
            "workingDir",
            "ports",
            "envFrom",
            "env",
            "resources",
            "resizePolicy",
            "volumeMounts",
            "volumeDevices",
            "livenessProbe",
            "readinessProbe",
            "startupProbe",
            "lifecycle",
            "terminationMessagePath",
            "terminationMessagePolicy",
            "imagePullPolicy",
            "securityContext",
            "stdin",
            "stdinOnce",
            "tty",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Image,
            Command,
            Args,
            WorkingDir,
            Ports,
            EnvFrom,
            Env,
            Resources,
            ResizePolicy,
            VolumeMounts,
            VolumeDevices,
            LivenessProbe,
            ReadinessProbe,
            StartupProbe,
            Lifecycle,
            TerminationMessagePath,
            TerminationMessagePolicy,
            ImagePullPolicy,
            SecurityContext,
            Stdin,
            StdinOnce,
            Tty,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "image" => Ok(GeneratedField::Image),
                            "command" => Ok(GeneratedField::Command),
                            "args" => Ok(GeneratedField::Args),
                            "workingDir" => Ok(GeneratedField::WorkingDir),
                            "ports" => Ok(GeneratedField::Ports),
                            "envFrom" => Ok(GeneratedField::EnvFrom),
                            "env" => Ok(GeneratedField::Env),
                            "resources" => Ok(GeneratedField::Resources),
                            "resizePolicy" => Ok(GeneratedField::ResizePolicy),
                            "volumeMounts" => Ok(GeneratedField::VolumeMounts),
                            "volumeDevices" => Ok(GeneratedField::VolumeDevices),
                            "livenessProbe" => Ok(GeneratedField::LivenessProbe),
                            "readinessProbe" => Ok(GeneratedField::ReadinessProbe),
                            "startupProbe" => Ok(GeneratedField::StartupProbe),
                            "lifecycle" => Ok(GeneratedField::Lifecycle),
                            "terminationMessagePath" => Ok(GeneratedField::TerminationMessagePath),
                            "terminationMessagePolicy" => Ok(GeneratedField::TerminationMessagePolicy),
                            "imagePullPolicy" => Ok(GeneratedField::ImagePullPolicy),
                            "securityContext" => Ok(GeneratedField::SecurityContext),
                            "stdin" => Ok(GeneratedField::Stdin),
                            "stdinOnce" => Ok(GeneratedField::StdinOnce),
                            "tty" => Ok(GeneratedField::Tty),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Container;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Container")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Container, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut image__ = None;
                let mut command__ = None;
                let mut args__ = None;
                let mut working_dir__ = None;
                let mut ports__ = None;
                let mut env_from__ = None;
                let mut env__ = None;
                let mut resources__ = None;
                let mut resize_policy__ = None;
                let mut volume_mounts__ = None;
                let mut volume_devices__ = None;
                let mut liveness_probe__ = None;
                let mut readiness_probe__ = None;
                let mut startup_probe__ = None;
                let mut lifecycle__ = None;
                let mut termination_message_path__ = None;
                let mut termination_message_policy__ = None;
                let mut image_pull_policy__ = None;
                let mut security_context__ = None;
                let mut stdin__ = None;
                let mut stdin_once__ = None;
                let mut tty__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = map.next_value()?;
                        }
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = Some(map.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map.next_value()?);
                        }
                        GeneratedField::WorkingDir => {
                            if working_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workingDir"));
                            }
                            working_dir__ = map.next_value()?;
                        }
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = Some(map.next_value()?);
                        }
                        GeneratedField::EnvFrom => {
                            if env_from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("envFrom"));
                            }
                            env_from__ = Some(map.next_value()?);
                        }
                        GeneratedField::Env => {
                            if env__.is_some() {
                                return Err(serde::de::Error::duplicate_field("env"));
                            }
                            env__ = Some(map.next_value()?);
                        }
                        GeneratedField::Resources => {
                            if resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resources"));
                            }
                            resources__ = map.next_value()?;
                        }
                        GeneratedField::ResizePolicy => {
                            if resize_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resizePolicy"));
                            }
                            resize_policy__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumeMounts => {
                            if volume_mounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeMounts"));
                            }
                            volume_mounts__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumeDevices => {
                            if volume_devices__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeDevices"));
                            }
                            volume_devices__ = Some(map.next_value()?);
                        }
                        GeneratedField::LivenessProbe => {
                            if liveness_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("livenessProbe"));
                            }
                            liveness_probe__ = map.next_value()?;
                        }
                        GeneratedField::ReadinessProbe => {
                            if readiness_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readinessProbe"));
                            }
                            readiness_probe__ = map.next_value()?;
                        }
                        GeneratedField::StartupProbe => {
                            if startup_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startupProbe"));
                            }
                            startup_probe__ = map.next_value()?;
                        }
                        GeneratedField::Lifecycle => {
                            if lifecycle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lifecycle"));
                            }
                            lifecycle__ = map.next_value()?;
                        }
                        GeneratedField::TerminationMessagePath => {
                            if termination_message_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationMessagePath"));
                            }
                            termination_message_path__ = map.next_value()?;
                        }
                        GeneratedField::TerminationMessagePolicy => {
                            if termination_message_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationMessagePolicy"));
                            }
                            termination_message_policy__ = map.next_value()?;
                        }
                        GeneratedField::ImagePullPolicy => {
                            if image_pull_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imagePullPolicy"));
                            }
                            image_pull_policy__ = map.next_value()?;
                        }
                        GeneratedField::SecurityContext => {
                            if security_context__.is_some() {
                                return Err(serde::de::Error::duplicate_field("securityContext"));
                            }
                            security_context__ = map.next_value()?;
                        }
                        GeneratedField::Stdin => {
                            if stdin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdin"));
                            }
                            stdin__ = map.next_value()?;
                        }
                        GeneratedField::StdinOnce => {
                            if stdin_once__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdinOnce"));
                            }
                            stdin_once__ = map.next_value()?;
                        }
                        GeneratedField::Tty => {
                            if tty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tty"));
                            }
                            tty__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Container {
                    name: name__,
                    image: image__,
                    command: command__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    working_dir: working_dir__,
                    ports: ports__.unwrap_or_default(),
                    env_from: env_from__.unwrap_or_default(),
                    env: env__.unwrap_or_default(),
                    resources: resources__,
                    resize_policy: resize_policy__.unwrap_or_default(),
                    volume_mounts: volume_mounts__.unwrap_or_default(),
                    volume_devices: volume_devices__.unwrap_or_default(),
                    liveness_probe: liveness_probe__,
                    readiness_probe: readiness_probe__,
                    startup_probe: startup_probe__,
                    lifecycle: lifecycle__,
                    termination_message_path: termination_message_path__,
                    termination_message_policy: termination_message_policy__,
                    image_pull_policy: image_pull_policy__,
                    security_context: security_context__,
                    stdin: stdin__,
                    stdin_once: stdin_once__,
                    tty: tty__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Container", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerImage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.names.is_empty() {
            len += 1;
        }
        if self.size_bytes.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerImage", len)?;
        if !self.names.is_empty() {
            struct_ser.serialize_field("names", &self.names)?;
        }
        if let Some(v) = self.size_bytes.as_ref() {
            struct_ser.serialize_field("sizeBytes", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerImage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "names",
            "sizeBytes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Names,
            SizeBytes,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "names" => Ok(GeneratedField::Names),
                            "sizeBytes" => Ok(GeneratedField::SizeBytes),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerImage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerImage")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerImage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut names__ = None;
                let mut size_bytes__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Names => {
                            if names__.is_some() {
                                return Err(serde::de::Error::duplicate_field("names"));
                            }
                            names__ = Some(map.next_value()?);
                        }
                        GeneratedField::SizeBytes => {
                            if size_bytes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sizeBytes"));
                            }
                            size_bytes__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerImage {
                    names: names__.unwrap_or_default(),
                    size_bytes: size_bytes__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerImage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerPort {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.host_port.is_some() {
            len += 1;
        }
        if self.container_port.is_some() {
            len += 1;
        }
        if self.protocol.is_some() {
            len += 1;
        }
        if self.host_ip.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerPort", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.host_port.as_ref() {
            struct_ser.serialize_field("hostPort", v)?;
        }
        if let Some(v) = self.container_port.as_ref() {
            struct_ser.serialize_field("containerPort", v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            struct_ser.serialize_field("protocol", v)?;
        }
        if let Some(v) = self.host_ip.as_ref() {
            struct_ser.serialize_field("hostIP", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerPort {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "hostPort",
            "containerPort",
            "protocol",
            "hostIP",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            HostPort,
            ContainerPort,
            Protocol,
            HostIp,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "hostPort" => Ok(GeneratedField::HostPort),
                            "containerPort" => Ok(GeneratedField::ContainerPort),
                            "protocol" => Ok(GeneratedField::Protocol),
                            "hostIP" => Ok(GeneratedField::HostIp),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerPort;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerPort")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerPort, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut host_port__ = None;
                let mut container_port__ = None;
                let mut protocol__ = None;
                let mut host_ip__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::HostPort => {
                            if host_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostPort"));
                            }
                            host_port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ContainerPort => {
                            if container_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerPort"));
                            }
                            container_port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Protocol => {
                            if protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocol"));
                            }
                            protocol__ = map.next_value()?;
                        }
                        GeneratedField::HostIp => {
                            if host_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostIP"));
                            }
                            host_ip__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerPort {
                    name: name__,
                    host_port: host_port__,
                    container_port: container_port__,
                    protocol: protocol__,
                    host_ip: host_ip__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerPort", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerResizePolicy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.resource_name.is_some() {
            len += 1;
        }
        if self.restart_policy.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerResizePolicy", len)?;
        if let Some(v) = self.resource_name.as_ref() {
            struct_ser.serialize_field("resourceName", v)?;
        }
        if let Some(v) = self.restart_policy.as_ref() {
            struct_ser.serialize_field("restartPolicy", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerResizePolicy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "resourceName",
            "restartPolicy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResourceName,
            RestartPolicy,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "resourceName" => Ok(GeneratedField::ResourceName),
                            "restartPolicy" => Ok(GeneratedField::RestartPolicy),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerResizePolicy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerResizePolicy")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerResizePolicy, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resource_name__ = None;
                let mut restart_policy__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ResourceName => {
                            if resource_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceName"));
                            }
                            resource_name__ = map.next_value()?;
                        }
                        GeneratedField::RestartPolicy => {
                            if restart_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("restartPolicy"));
                            }
                            restart_policy__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerResizePolicy {
                    resource_name: resource_name__,
                    restart_policy: restart_policy__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerResizePolicy", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.waiting.is_some() {
            len += 1;
        }
        if self.running.is_some() {
            len += 1;
        }
        if self.terminated.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerState", len)?;
        if let Some(v) = self.waiting.as_ref() {
            struct_ser.serialize_field("waiting", v)?;
        }
        if let Some(v) = self.running.as_ref() {
            struct_ser.serialize_field("running", v)?;
        }
        if let Some(v) = self.terminated.as_ref() {
            struct_ser.serialize_field("terminated", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "waiting",
            "running",
            "terminated",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Waiting,
            Running,
            Terminated,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "waiting" => Ok(GeneratedField::Waiting),
                            "running" => Ok(GeneratedField::Running),
                            "terminated" => Ok(GeneratedField::Terminated),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerState")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut waiting__ = None;
                let mut running__ = None;
                let mut terminated__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Waiting => {
                            if waiting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("waiting"));
                            }
                            waiting__ = map.next_value()?;
                        }
                        GeneratedField::Running => {
                            if running__.is_some() {
                                return Err(serde::de::Error::duplicate_field("running"));
                            }
                            running__ = map.next_value()?;
                        }
                        GeneratedField::Terminated => {
                            if terminated__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminated"));
                            }
                            terminated__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerState {
                    waiting: waiting__,
                    running: running__,
                    terminated: terminated__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerStateRunning {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.started_at.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerStateRunning", len)?;
        if let Some(v) = self.started_at.as_ref() {
            struct_ser.serialize_field("startedAt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerStateRunning {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "startedAt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartedAt,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "startedAt" => Ok(GeneratedField::StartedAt),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerStateRunning;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerStateRunning")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerStateRunning, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut started_at__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::StartedAt => {
                            if started_at__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startedAt"));
                            }
                            started_at__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerStateRunning {
                    started_at: started_at__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerStateRunning", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerStateTerminated {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.exit_code.is_some() {
            len += 1;
        }
        if self.signal.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        if self.started_at.is_some() {
            len += 1;
        }
        if self.finished_at.is_some() {
            len += 1;
        }
        if self.container_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerStateTerminated", len)?;
        if let Some(v) = self.exit_code.as_ref() {
            struct_ser.serialize_field("exitCode", v)?;
        }
        if let Some(v) = self.signal.as_ref() {
            struct_ser.serialize_field("signal", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.started_at.as_ref() {
            struct_ser.serialize_field("startedAt", v)?;
        }
        if let Some(v) = self.finished_at.as_ref() {
            struct_ser.serialize_field("finishedAt", v)?;
        }
        if let Some(v) = self.container_id.as_ref() {
            struct_ser.serialize_field("containerID", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerStateTerminated {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exitCode",
            "signal",
            "reason",
            "message",
            "startedAt",
            "finishedAt",
            "containerID",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ExitCode,
            Signal,
            Reason,
            Message,
            StartedAt,
            FinishedAt,
            ContainerId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exitCode" => Ok(GeneratedField::ExitCode),
                            "signal" => Ok(GeneratedField::Signal),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            "startedAt" => Ok(GeneratedField::StartedAt),
                            "finishedAt" => Ok(GeneratedField::FinishedAt),
                            "containerID" => Ok(GeneratedField::ContainerId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerStateTerminated;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerStateTerminated")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerStateTerminated, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exit_code__ = None;
                let mut signal__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                let mut started_at__ = None;
                let mut finished_at__ = None;
                let mut container_id__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ExitCode => {
                            if exit_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exitCode"));
                            }
                            exit_code__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Signal => {
                            if signal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signal"));
                            }
                            signal__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::StartedAt => {
                            if started_at__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startedAt"));
                            }
                            started_at__ = map.next_value()?;
                        }
                        GeneratedField::FinishedAt => {
                            if finished_at__.is_some() {
                                return Err(serde::de::Error::duplicate_field("finishedAt"));
                            }
                            finished_at__ = map.next_value()?;
                        }
                        GeneratedField::ContainerId => {
                            if container_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerID"));
                            }
                            container_id__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerStateTerminated {
                    exit_code: exit_code__,
                    signal: signal__,
                    reason: reason__,
                    message: message__,
                    started_at: started_at__,
                    finished_at: finished_at__,
                    container_id: container_id__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerStateTerminated", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerStateWaiting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerStateWaiting", len)?;
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerStateWaiting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerStateWaiting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerStateWaiting")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerStateWaiting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerStateWaiting {
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerStateWaiting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ContainerStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if self.last_state.is_some() {
            len += 1;
        }
        if self.ready.is_some() {
            len += 1;
        }
        if self.restart_count.is_some() {
            len += 1;
        }
        if self.image.is_some() {
            len += 1;
        }
        if self.image_id.is_some() {
            len += 1;
        }
        if self.container_id.is_some() {
            len += 1;
        }
        if self.started.is_some() {
            len += 1;
        }
        if !self.allocated_resources.is_empty() {
            len += 1;
        }
        if self.resources.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ContainerStatus", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("state", v)?;
        }
        if let Some(v) = self.last_state.as_ref() {
            struct_ser.serialize_field("lastState", v)?;
        }
        if let Some(v) = self.ready.as_ref() {
            struct_ser.serialize_field("ready", v)?;
        }
        if let Some(v) = self.restart_count.as_ref() {
            struct_ser.serialize_field("restartCount", v)?;
        }
        if let Some(v) = self.image.as_ref() {
            struct_ser.serialize_field("image", v)?;
        }
        if let Some(v) = self.image_id.as_ref() {
            struct_ser.serialize_field("imageID", v)?;
        }
        if let Some(v) = self.container_id.as_ref() {
            struct_ser.serialize_field("containerID", v)?;
        }
        if let Some(v) = self.started.as_ref() {
            struct_ser.serialize_field("started", v)?;
        }
        if !self.allocated_resources.is_empty() {
            struct_ser.serialize_field("allocatedResources", &self.allocated_resources)?;
        }
        if let Some(v) = self.resources.as_ref() {
            struct_ser.serialize_field("resources", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContainerStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "state",
            "lastState",
            "ready",
            "restartCount",
            "image",
            "imageID",
            "containerID",
            "started",
            "allocatedResources",
            "resources",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            State,
            LastState,
            Ready,
            RestartCount,
            Image,
            ImageId,
            ContainerId,
            Started,
            AllocatedResources,
            Resources,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "state" => Ok(GeneratedField::State),
                            "lastState" => Ok(GeneratedField::LastState),
                            "ready" => Ok(GeneratedField::Ready),
                            "restartCount" => Ok(GeneratedField::RestartCount),
                            "image" => Ok(GeneratedField::Image),
                            "imageID" => Ok(GeneratedField::ImageId),
                            "containerID" => Ok(GeneratedField::ContainerId),
                            "started" => Ok(GeneratedField::Started),
                            "allocatedResources" => Ok(GeneratedField::AllocatedResources),
                            "resources" => Ok(GeneratedField::Resources),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContainerStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ContainerStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ContainerStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut state__ = None;
                let mut last_state__ = None;
                let mut ready__ = None;
                let mut restart_count__ = None;
                let mut image__ = None;
                let mut image_id__ = None;
                let mut container_id__ = None;
                let mut started__ = None;
                let mut allocated_resources__ = None;
                let mut resources__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = map.next_value()?;
                        }
                        GeneratedField::LastState => {
                            if last_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastState"));
                            }
                            last_state__ = map.next_value()?;
                        }
                        GeneratedField::Ready => {
                            if ready__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ready"));
                            }
                            ready__ = map.next_value()?;
                        }
                        GeneratedField::RestartCount => {
                            if restart_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("restartCount"));
                            }
                            restart_count__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = map.next_value()?;
                        }
                        GeneratedField::ImageId => {
                            if image_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageID"));
                            }
                            image_id__ = map.next_value()?;
                        }
                        GeneratedField::ContainerId => {
                            if container_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerID"));
                            }
                            container_id__ = map.next_value()?;
                        }
                        GeneratedField::Started => {
                            if started__.is_some() {
                                return Err(serde::de::Error::duplicate_field("started"));
                            }
                            started__ = map.next_value()?;
                        }
                        GeneratedField::AllocatedResources => {
                            if allocated_resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allocatedResources"));
                            }
                            allocated_resources__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Resources => {
                            if resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resources"));
                            }
                            resources__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ContainerStatus {
                    name: name__,
                    state: state__,
                    last_state: last_state__,
                    ready: ready__,
                    restart_count: restart_count__,
                    image: image__,
                    image_id: image_id__,
                    container_id: container_id__,
                    started: started__,
                    allocated_resources: allocated_resources__.unwrap_or_default(),
                    resources: resources__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ContainerStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DaemonEndpoint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.port.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.DaemonEndpoint", len)?;
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("Port", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DaemonEndpoint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Port",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Port,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Port" => Ok(GeneratedField::Port),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DaemonEndpoint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.DaemonEndpoint")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<DaemonEndpoint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut port__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Port"));
                            }
                            port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DaemonEndpoint {
                    port: port__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.DaemonEndpoint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DownwardApiProjection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.DownwardAPIProjection", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DownwardApiProjection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DownwardApiProjection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.DownwardAPIProjection")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<DownwardApiProjection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DownwardApiProjection {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.DownwardAPIProjection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DownwardApiVolumeFile {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        if self.field_ref.is_some() {
            len += 1;
        }
        if self.resource_field_ref.is_some() {
            len += 1;
        }
        if self.mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.DownwardAPIVolumeFile", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.field_ref.as_ref() {
            struct_ser.serialize_field("fieldRef", v)?;
        }
        if let Some(v) = self.resource_field_ref.as_ref() {
            struct_ser.serialize_field("resourceFieldRef", v)?;
        }
        if let Some(v) = self.mode.as_ref() {
            struct_ser.serialize_field("mode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DownwardApiVolumeFile {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
            "fieldRef",
            "resourceFieldRef",
            "mode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            FieldRef,
            ResourceFieldRef,
            Mode,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            "fieldRef" => Ok(GeneratedField::FieldRef),
                            "resourceFieldRef" => Ok(GeneratedField::ResourceFieldRef),
                            "mode" => Ok(GeneratedField::Mode),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DownwardApiVolumeFile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.DownwardAPIVolumeFile")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<DownwardApiVolumeFile, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                let mut field_ref__ = None;
                let mut resource_field_ref__ = None;
                let mut mode__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::FieldRef => {
                            if field_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldRef"));
                            }
                            field_ref__ = map.next_value()?;
                        }
                        GeneratedField::ResourceFieldRef => {
                            if resource_field_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceFieldRef"));
                            }
                            resource_field_ref__ = map.next_value()?;
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DownwardApiVolumeFile {
                    path: path__,
                    field_ref: field_ref__,
                    resource_field_ref: resource_field_ref__,
                    mode: mode__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.DownwardAPIVolumeFile", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DownwardApiVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        if self.default_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.DownwardAPIVolumeSource", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.default_mode.as_ref() {
            struct_ser.serialize_field("defaultMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DownwardApiVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "defaultMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            DefaultMode,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "defaultMode" => Ok(GeneratedField::DefaultMode),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DownwardApiVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.DownwardAPIVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<DownwardApiVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut default_mode__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::DefaultMode => {
                            if default_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultMode"));
                            }
                            default_mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DownwardApiVolumeSource {
                    items: items__.unwrap_or_default(),
                    default_mode: default_mode__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.DownwardAPIVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EmptyDirVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.medium.is_some() {
            len += 1;
        }
        if self.size_limit.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EmptyDirVolumeSource", len)?;
        if let Some(v) = self.medium.as_ref() {
            struct_ser.serialize_field("medium", v)?;
        }
        if let Some(v) = self.size_limit.as_ref() {
            struct_ser.serialize_field("sizeLimit", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EmptyDirVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "medium",
            "sizeLimit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Medium,
            SizeLimit,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "medium" => Ok(GeneratedField::Medium),
                            "sizeLimit" => Ok(GeneratedField::SizeLimit),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EmptyDirVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EmptyDirVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EmptyDirVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut medium__ = None;
                let mut size_limit__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Medium => {
                            if medium__.is_some() {
                                return Err(serde::de::Error::duplicate_field("medium"));
                            }
                            medium__ = map.next_value()?;
                        }
                        GeneratedField::SizeLimit => {
                            if size_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sizeLimit"));
                            }
                            size_limit__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EmptyDirVolumeSource {
                    medium: medium__,
                    size_limit: size_limit__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EmptyDirVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndpointAddress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ip.is_some() {
            len += 1;
        }
        if self.hostname.is_some() {
            len += 1;
        }
        if self.node_name.is_some() {
            len += 1;
        }
        if self.target_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EndpointAddress", len)?;
        if let Some(v) = self.ip.as_ref() {
            struct_ser.serialize_field("ip", v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            struct_ser.serialize_field("hostname", v)?;
        }
        if let Some(v) = self.node_name.as_ref() {
            struct_ser.serialize_field("nodeName", v)?;
        }
        if let Some(v) = self.target_ref.as_ref() {
            struct_ser.serialize_field("targetRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndpointAddress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ip",
            "hostname",
            "nodeName",
            "targetRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ip,
            Hostname,
            NodeName,
            TargetRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ip" => Ok(GeneratedField::Ip),
                            "hostname" => Ok(GeneratedField::Hostname),
                            "nodeName" => Ok(GeneratedField::NodeName),
                            "targetRef" => Ok(GeneratedField::TargetRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndpointAddress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EndpointAddress")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EndpointAddress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ip__ = None;
                let mut hostname__ = None;
                let mut node_name__ = None;
                let mut target_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ip => {
                            if ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ip"));
                            }
                            ip__ = map.next_value()?;
                        }
                        GeneratedField::Hostname => {
                            if hostname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostname"));
                            }
                            hostname__ = map.next_value()?;
                        }
                        GeneratedField::NodeName => {
                            if node_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeName"));
                            }
                            node_name__ = map.next_value()?;
                        }
                        GeneratedField::TargetRef => {
                            if target_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetRef"));
                            }
                            target_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndpointAddress {
                    ip: ip__,
                    hostname: hostname__,
                    node_name: node_name__,
                    target_ref: target_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EndpointAddress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndpointPort {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.port.is_some() {
            len += 1;
        }
        if self.protocol.is_some() {
            len += 1;
        }
        if self.app_protocol.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EndpointPort", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            struct_ser.serialize_field("protocol", v)?;
        }
        if let Some(v) = self.app_protocol.as_ref() {
            struct_ser.serialize_field("appProtocol", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndpointPort {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "port",
            "protocol",
            "appProtocol",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Port,
            Protocol,
            AppProtocol,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "port" => Ok(GeneratedField::Port),
                            "protocol" => Ok(GeneratedField::Protocol),
                            "appProtocol" => Ok(GeneratedField::AppProtocol),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndpointPort;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EndpointPort")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EndpointPort, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut port__ = None;
                let mut protocol__ = None;
                let mut app_protocol__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Protocol => {
                            if protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocol"));
                            }
                            protocol__ = map.next_value()?;
                        }
                        GeneratedField::AppProtocol => {
                            if app_protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appProtocol"));
                            }
                            app_protocol__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndpointPort {
                    name: name__,
                    port: port__,
                    protocol: protocol__,
                    app_protocol: app_protocol__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EndpointPort", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndpointSubset {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.addresses.is_empty() {
            len += 1;
        }
        if !self.not_ready_addresses.is_empty() {
            len += 1;
        }
        if !self.ports.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EndpointSubset", len)?;
        if !self.addresses.is_empty() {
            struct_ser.serialize_field("addresses", &self.addresses)?;
        }
        if !self.not_ready_addresses.is_empty() {
            struct_ser.serialize_field("notReadyAddresses", &self.not_ready_addresses)?;
        }
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndpointSubset {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "addresses",
            "notReadyAddresses",
            "ports",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Addresses,
            NotReadyAddresses,
            Ports,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "addresses" => Ok(GeneratedField::Addresses),
                            "notReadyAddresses" => Ok(GeneratedField::NotReadyAddresses),
                            "ports" => Ok(GeneratedField::Ports),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndpointSubset;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EndpointSubset")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EndpointSubset, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut addresses__ = None;
                let mut not_ready_addresses__ = None;
                let mut ports__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Addresses => {
                            if addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("addresses"));
                            }
                            addresses__ = Some(map.next_value()?);
                        }
                        GeneratedField::NotReadyAddresses => {
                            if not_ready_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notReadyAddresses"));
                            }
                            not_ready_addresses__ = Some(map.next_value()?);
                        }
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndpointSubset {
                    addresses: addresses__.unwrap_or_default(),
                    not_ready_addresses: not_ready_addresses__.unwrap_or_default(),
                    ports: ports__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EndpointSubset", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Endpoints {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.subsets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Endpoints", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.subsets.is_empty() {
            struct_ser.serialize_field("subsets", &self.subsets)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Endpoints {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "subsets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Subsets,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "subsets" => Ok(GeneratedField::Subsets),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Endpoints;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Endpoints")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Endpoints, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut subsets__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Subsets => {
                            if subsets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subsets"));
                            }
                            subsets__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Endpoints {
                    metadata: metadata__,
                    subsets: subsets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Endpoints", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndpointsList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EndpointsList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndpointsList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndpointsList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EndpointsList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EndpointsList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndpointsList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EndpointsList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnvFromSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.prefix.is_some() {
            len += 1;
        }
        if self.config_map_ref.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EnvFromSource", len)?;
        if let Some(v) = self.prefix.as_ref() {
            struct_ser.serialize_field("prefix", v)?;
        }
        if let Some(v) = self.config_map_ref.as_ref() {
            struct_ser.serialize_field("configMapRef", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnvFromSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prefix",
            "configMapRef",
            "secretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Prefix,
            ConfigMapRef,
            SecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prefix" => Ok(GeneratedField::Prefix),
                            "configMapRef" => Ok(GeneratedField::ConfigMapRef),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnvFromSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EnvFromSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EnvFromSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prefix__ = None;
                let mut config_map_ref__ = None;
                let mut secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Prefix => {
                            if prefix__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prefix"));
                            }
                            prefix__ = map.next_value()?;
                        }
                        GeneratedField::ConfigMapRef => {
                            if config_map_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configMapRef"));
                            }
                            config_map_ref__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EnvFromSource {
                    prefix: prefix__,
                    config_map_ref: config_map_ref__,
                    secret_ref: secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EnvFromSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnvVar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.value_from.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EnvVar", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if let Some(v) = self.value_from.as_ref() {
            struct_ser.serialize_field("valueFrom", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnvVar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
            "valueFrom",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            ValueFrom,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            "valueFrom" => Ok(GeneratedField::ValueFrom),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnvVar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EnvVar")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EnvVar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                let mut value_from__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::ValueFrom => {
                            if value_from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("valueFrom"));
                            }
                            value_from__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EnvVar {
                    name: name__,
                    value: value__,
                    value_from: value_from__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EnvVar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnvVarSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.field_ref.is_some() {
            len += 1;
        }
        if self.resource_field_ref.is_some() {
            len += 1;
        }
        if self.config_map_key_ref.is_some() {
            len += 1;
        }
        if self.secret_key_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EnvVarSource", len)?;
        if let Some(v) = self.field_ref.as_ref() {
            struct_ser.serialize_field("fieldRef", v)?;
        }
        if let Some(v) = self.resource_field_ref.as_ref() {
            struct_ser.serialize_field("resourceFieldRef", v)?;
        }
        if let Some(v) = self.config_map_key_ref.as_ref() {
            struct_ser.serialize_field("configMapKeyRef", v)?;
        }
        if let Some(v) = self.secret_key_ref.as_ref() {
            struct_ser.serialize_field("secretKeyRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnvVarSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "fieldRef",
            "resourceFieldRef",
            "configMapKeyRef",
            "secretKeyRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FieldRef,
            ResourceFieldRef,
            ConfigMapKeyRef,
            SecretKeyRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "fieldRef" => Ok(GeneratedField::FieldRef),
                            "resourceFieldRef" => Ok(GeneratedField::ResourceFieldRef),
                            "configMapKeyRef" => Ok(GeneratedField::ConfigMapKeyRef),
                            "secretKeyRef" => Ok(GeneratedField::SecretKeyRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnvVarSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EnvVarSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EnvVarSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut field_ref__ = None;
                let mut resource_field_ref__ = None;
                let mut config_map_key_ref__ = None;
                let mut secret_key_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::FieldRef => {
                            if field_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldRef"));
                            }
                            field_ref__ = map.next_value()?;
                        }
                        GeneratedField::ResourceFieldRef => {
                            if resource_field_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceFieldRef"));
                            }
                            resource_field_ref__ = map.next_value()?;
                        }
                        GeneratedField::ConfigMapKeyRef => {
                            if config_map_key_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configMapKeyRef"));
                            }
                            config_map_key_ref__ = map.next_value()?;
                        }
                        GeneratedField::SecretKeyRef => {
                            if secret_key_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretKeyRef"));
                            }
                            secret_key_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EnvVarSource {
                    field_ref: field_ref__,
                    resource_field_ref: resource_field_ref__,
                    config_map_key_ref: config_map_key_ref__,
                    secret_key_ref: secret_key_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EnvVarSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EphemeralContainer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ephemeral_container_common.is_some() {
            len += 1;
        }
        if self.target_container_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EphemeralContainer", len)?;
        if let Some(v) = self.ephemeral_container_common.as_ref() {
            struct_ser.serialize_field("ephemeralContainerCommon", v)?;
        }
        if let Some(v) = self.target_container_name.as_ref() {
            struct_ser.serialize_field("targetContainerName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EphemeralContainer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ephemeralContainerCommon",
            "targetContainerName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EphemeralContainerCommon,
            TargetContainerName,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ephemeralContainerCommon" => Ok(GeneratedField::EphemeralContainerCommon),
                            "targetContainerName" => Ok(GeneratedField::TargetContainerName),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EphemeralContainer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EphemeralContainer")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EphemeralContainer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ephemeral_container_common__ = None;
                let mut target_container_name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::EphemeralContainerCommon => {
                            if ephemeral_container_common__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ephemeralContainerCommon"));
                            }
                            ephemeral_container_common__ = map.next_value()?;
                        }
                        GeneratedField::TargetContainerName => {
                            if target_container_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetContainerName"));
                            }
                            target_container_name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EphemeralContainer {
                    ephemeral_container_common: ephemeral_container_common__,
                    target_container_name: target_container_name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EphemeralContainer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EphemeralContainerCommon {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.image.is_some() {
            len += 1;
        }
        if !self.command.is_empty() {
            len += 1;
        }
        if !self.args.is_empty() {
            len += 1;
        }
        if self.working_dir.is_some() {
            len += 1;
        }
        if !self.ports.is_empty() {
            len += 1;
        }
        if !self.env_from.is_empty() {
            len += 1;
        }
        if !self.env.is_empty() {
            len += 1;
        }
        if self.resources.is_some() {
            len += 1;
        }
        if !self.resize_policy.is_empty() {
            len += 1;
        }
        if !self.volume_mounts.is_empty() {
            len += 1;
        }
        if !self.volume_devices.is_empty() {
            len += 1;
        }
        if self.liveness_probe.is_some() {
            len += 1;
        }
        if self.readiness_probe.is_some() {
            len += 1;
        }
        if self.startup_probe.is_some() {
            len += 1;
        }
        if self.lifecycle.is_some() {
            len += 1;
        }
        if self.termination_message_path.is_some() {
            len += 1;
        }
        if self.termination_message_policy.is_some() {
            len += 1;
        }
        if self.image_pull_policy.is_some() {
            len += 1;
        }
        if self.security_context.is_some() {
            len += 1;
        }
        if self.stdin.is_some() {
            len += 1;
        }
        if self.stdin_once.is_some() {
            len += 1;
        }
        if self.tty.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EphemeralContainerCommon", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.image.as_ref() {
            struct_ser.serialize_field("image", v)?;
        }
        if !self.command.is_empty() {
            struct_ser.serialize_field("command", &self.command)?;
        }
        if !self.args.is_empty() {
            struct_ser.serialize_field("args", &self.args)?;
        }
        if let Some(v) = self.working_dir.as_ref() {
            struct_ser.serialize_field("workingDir", v)?;
        }
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        if !self.env_from.is_empty() {
            struct_ser.serialize_field("envFrom", &self.env_from)?;
        }
        if !self.env.is_empty() {
            struct_ser.serialize_field("env", &self.env)?;
        }
        if let Some(v) = self.resources.as_ref() {
            struct_ser.serialize_field("resources", v)?;
        }
        if !self.resize_policy.is_empty() {
            struct_ser.serialize_field("resizePolicy", &self.resize_policy)?;
        }
        if !self.volume_mounts.is_empty() {
            struct_ser.serialize_field("volumeMounts", &self.volume_mounts)?;
        }
        if !self.volume_devices.is_empty() {
            struct_ser.serialize_field("volumeDevices", &self.volume_devices)?;
        }
        if let Some(v) = self.liveness_probe.as_ref() {
            struct_ser.serialize_field("livenessProbe", v)?;
        }
        if let Some(v) = self.readiness_probe.as_ref() {
            struct_ser.serialize_field("readinessProbe", v)?;
        }
        if let Some(v) = self.startup_probe.as_ref() {
            struct_ser.serialize_field("startupProbe", v)?;
        }
        if let Some(v) = self.lifecycle.as_ref() {
            struct_ser.serialize_field("lifecycle", v)?;
        }
        if let Some(v) = self.termination_message_path.as_ref() {
            struct_ser.serialize_field("terminationMessagePath", v)?;
        }
        if let Some(v) = self.termination_message_policy.as_ref() {
            struct_ser.serialize_field("terminationMessagePolicy", v)?;
        }
        if let Some(v) = self.image_pull_policy.as_ref() {
            struct_ser.serialize_field("imagePullPolicy", v)?;
        }
        if let Some(v) = self.security_context.as_ref() {
            struct_ser.serialize_field("securityContext", v)?;
        }
        if let Some(v) = self.stdin.as_ref() {
            struct_ser.serialize_field("stdin", v)?;
        }
        if let Some(v) = self.stdin_once.as_ref() {
            struct_ser.serialize_field("stdinOnce", v)?;
        }
        if let Some(v) = self.tty.as_ref() {
            struct_ser.serialize_field("tty", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EphemeralContainerCommon {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "image",
            "command",
            "args",
            "workingDir",
            "ports",
            "envFrom",
            "env",
            "resources",
            "resizePolicy",
            "volumeMounts",
            "volumeDevices",
            "livenessProbe",
            "readinessProbe",
            "startupProbe",
            "lifecycle",
            "terminationMessagePath",
            "terminationMessagePolicy",
            "imagePullPolicy",
            "securityContext",
            "stdin",
            "stdinOnce",
            "tty",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Image,
            Command,
            Args,
            WorkingDir,
            Ports,
            EnvFrom,
            Env,
            Resources,
            ResizePolicy,
            VolumeMounts,
            VolumeDevices,
            LivenessProbe,
            ReadinessProbe,
            StartupProbe,
            Lifecycle,
            TerminationMessagePath,
            TerminationMessagePolicy,
            ImagePullPolicy,
            SecurityContext,
            Stdin,
            StdinOnce,
            Tty,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "image" => Ok(GeneratedField::Image),
                            "command" => Ok(GeneratedField::Command),
                            "args" => Ok(GeneratedField::Args),
                            "workingDir" => Ok(GeneratedField::WorkingDir),
                            "ports" => Ok(GeneratedField::Ports),
                            "envFrom" => Ok(GeneratedField::EnvFrom),
                            "env" => Ok(GeneratedField::Env),
                            "resources" => Ok(GeneratedField::Resources),
                            "resizePolicy" => Ok(GeneratedField::ResizePolicy),
                            "volumeMounts" => Ok(GeneratedField::VolumeMounts),
                            "volumeDevices" => Ok(GeneratedField::VolumeDevices),
                            "livenessProbe" => Ok(GeneratedField::LivenessProbe),
                            "readinessProbe" => Ok(GeneratedField::ReadinessProbe),
                            "startupProbe" => Ok(GeneratedField::StartupProbe),
                            "lifecycle" => Ok(GeneratedField::Lifecycle),
                            "terminationMessagePath" => Ok(GeneratedField::TerminationMessagePath),
                            "terminationMessagePolicy" => Ok(GeneratedField::TerminationMessagePolicy),
                            "imagePullPolicy" => Ok(GeneratedField::ImagePullPolicy),
                            "securityContext" => Ok(GeneratedField::SecurityContext),
                            "stdin" => Ok(GeneratedField::Stdin),
                            "stdinOnce" => Ok(GeneratedField::StdinOnce),
                            "tty" => Ok(GeneratedField::Tty),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EphemeralContainerCommon;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EphemeralContainerCommon")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EphemeralContainerCommon, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut image__ = None;
                let mut command__ = None;
                let mut args__ = None;
                let mut working_dir__ = None;
                let mut ports__ = None;
                let mut env_from__ = None;
                let mut env__ = None;
                let mut resources__ = None;
                let mut resize_policy__ = None;
                let mut volume_mounts__ = None;
                let mut volume_devices__ = None;
                let mut liveness_probe__ = None;
                let mut readiness_probe__ = None;
                let mut startup_probe__ = None;
                let mut lifecycle__ = None;
                let mut termination_message_path__ = None;
                let mut termination_message_policy__ = None;
                let mut image_pull_policy__ = None;
                let mut security_context__ = None;
                let mut stdin__ = None;
                let mut stdin_once__ = None;
                let mut tty__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = map.next_value()?;
                        }
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = Some(map.next_value()?);
                        }
                        GeneratedField::Args => {
                            if args__.is_some() {
                                return Err(serde::de::Error::duplicate_field("args"));
                            }
                            args__ = Some(map.next_value()?);
                        }
                        GeneratedField::WorkingDir => {
                            if working_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workingDir"));
                            }
                            working_dir__ = map.next_value()?;
                        }
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = Some(map.next_value()?);
                        }
                        GeneratedField::EnvFrom => {
                            if env_from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("envFrom"));
                            }
                            env_from__ = Some(map.next_value()?);
                        }
                        GeneratedField::Env => {
                            if env__.is_some() {
                                return Err(serde::de::Error::duplicate_field("env"));
                            }
                            env__ = Some(map.next_value()?);
                        }
                        GeneratedField::Resources => {
                            if resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resources"));
                            }
                            resources__ = map.next_value()?;
                        }
                        GeneratedField::ResizePolicy => {
                            if resize_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resizePolicy"));
                            }
                            resize_policy__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumeMounts => {
                            if volume_mounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeMounts"));
                            }
                            volume_mounts__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumeDevices => {
                            if volume_devices__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeDevices"));
                            }
                            volume_devices__ = Some(map.next_value()?);
                        }
                        GeneratedField::LivenessProbe => {
                            if liveness_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("livenessProbe"));
                            }
                            liveness_probe__ = map.next_value()?;
                        }
                        GeneratedField::ReadinessProbe => {
                            if readiness_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readinessProbe"));
                            }
                            readiness_probe__ = map.next_value()?;
                        }
                        GeneratedField::StartupProbe => {
                            if startup_probe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startupProbe"));
                            }
                            startup_probe__ = map.next_value()?;
                        }
                        GeneratedField::Lifecycle => {
                            if lifecycle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lifecycle"));
                            }
                            lifecycle__ = map.next_value()?;
                        }
                        GeneratedField::TerminationMessagePath => {
                            if termination_message_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationMessagePath"));
                            }
                            termination_message_path__ = map.next_value()?;
                        }
                        GeneratedField::TerminationMessagePolicy => {
                            if termination_message_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationMessagePolicy"));
                            }
                            termination_message_policy__ = map.next_value()?;
                        }
                        GeneratedField::ImagePullPolicy => {
                            if image_pull_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imagePullPolicy"));
                            }
                            image_pull_policy__ = map.next_value()?;
                        }
                        GeneratedField::SecurityContext => {
                            if security_context__.is_some() {
                                return Err(serde::de::Error::duplicate_field("securityContext"));
                            }
                            security_context__ = map.next_value()?;
                        }
                        GeneratedField::Stdin => {
                            if stdin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdin"));
                            }
                            stdin__ = map.next_value()?;
                        }
                        GeneratedField::StdinOnce => {
                            if stdin_once__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdinOnce"));
                            }
                            stdin_once__ = map.next_value()?;
                        }
                        GeneratedField::Tty => {
                            if tty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tty"));
                            }
                            tty__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EphemeralContainerCommon {
                    name: name__,
                    image: image__,
                    command: command__.unwrap_or_default(),
                    args: args__.unwrap_or_default(),
                    working_dir: working_dir__,
                    ports: ports__.unwrap_or_default(),
                    env_from: env_from__.unwrap_or_default(),
                    env: env__.unwrap_or_default(),
                    resources: resources__,
                    resize_policy: resize_policy__.unwrap_or_default(),
                    volume_mounts: volume_mounts__.unwrap_or_default(),
                    volume_devices: volume_devices__.unwrap_or_default(),
                    liveness_probe: liveness_probe__,
                    readiness_probe: readiness_probe__,
                    startup_probe: startup_probe__,
                    lifecycle: lifecycle__,
                    termination_message_path: termination_message_path__,
                    termination_message_policy: termination_message_policy__,
                    image_pull_policy: image_pull_policy__,
                    security_context: security_context__,
                    stdin: stdin__,
                    stdin_once: stdin_once__,
                    tty: tty__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EphemeralContainerCommon", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EphemeralVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_claim_template.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EphemeralVolumeSource", len)?;
        if let Some(v) = self.volume_claim_template.as_ref() {
            struct_ser.serialize_field("volumeClaimTemplate", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EphemeralVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeClaimTemplate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeClaimTemplate,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeClaimTemplate" => Ok(GeneratedField::VolumeClaimTemplate),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EphemeralVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EphemeralVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EphemeralVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_claim_template__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeClaimTemplate => {
                            if volume_claim_template__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeClaimTemplate"));
                            }
                            volume_claim_template__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EphemeralVolumeSource {
                    volume_claim_template: volume_claim_template__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EphemeralVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Event {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.involved_object.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        if self.source.is_some() {
            len += 1;
        }
        if self.first_timestamp.is_some() {
            len += 1;
        }
        if self.last_timestamp.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.event_time.is_some() {
            len += 1;
        }
        if self.series.is_some() {
            len += 1;
        }
        if self.action.is_some() {
            len += 1;
        }
        if self.related.is_some() {
            len += 1;
        }
        if self.reporting_component.is_some() {
            len += 1;
        }
        if self.reporting_instance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Event", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.involved_object.as_ref() {
            struct_ser.serialize_field("involvedObject", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        if let Some(v) = self.first_timestamp.as_ref() {
            struct_ser.serialize_field("firstTimestamp", v)?;
        }
        if let Some(v) = self.last_timestamp.as_ref() {
            struct_ser.serialize_field("lastTimestamp", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("count", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.event_time.as_ref() {
            struct_ser.serialize_field("eventTime", v)?;
        }
        if let Some(v) = self.series.as_ref() {
            struct_ser.serialize_field("series", v)?;
        }
        if let Some(v) = self.action.as_ref() {
            struct_ser.serialize_field("action", v)?;
        }
        if let Some(v) = self.related.as_ref() {
            struct_ser.serialize_field("related", v)?;
        }
        if let Some(v) = self.reporting_component.as_ref() {
            struct_ser.serialize_field("reportingComponent", v)?;
        }
        if let Some(v) = self.reporting_instance.as_ref() {
            struct_ser.serialize_field("reportingInstance", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Event {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "involvedObject",
            "reason",
            "message",
            "source",
            "firstTimestamp",
            "lastTimestamp",
            "count",
            "type",
            "eventTime",
            "series",
            "action",
            "related",
            "reportingComponent",
            "reportingInstance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            InvolvedObject,
            Reason,
            Message,
            Source,
            FirstTimestamp,
            LastTimestamp,
            Count,
            Type,
            EventTime,
            Series,
            Action,
            Related,
            ReportingComponent,
            ReportingInstance,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "involvedObject" => Ok(GeneratedField::InvolvedObject),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            "source" => Ok(GeneratedField::Source),
                            "firstTimestamp" => Ok(GeneratedField::FirstTimestamp),
                            "lastTimestamp" => Ok(GeneratedField::LastTimestamp),
                            "count" => Ok(GeneratedField::Count),
                            "type" => Ok(GeneratedField::Type),
                            "eventTime" => Ok(GeneratedField::EventTime),
                            "series" => Ok(GeneratedField::Series),
                            "action" => Ok(GeneratedField::Action),
                            "related" => Ok(GeneratedField::Related),
                            "reportingComponent" => Ok(GeneratedField::ReportingComponent),
                            "reportingInstance" => Ok(GeneratedField::ReportingInstance),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Event;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Event")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Event, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut involved_object__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                let mut source__ = None;
                let mut first_timestamp__ = None;
                let mut last_timestamp__ = None;
                let mut count__ = None;
                let mut r#type__ = None;
                let mut event_time__ = None;
                let mut series__ = None;
                let mut action__ = None;
                let mut related__ = None;
                let mut reporting_component__ = None;
                let mut reporting_instance__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::InvolvedObject => {
                            if involved_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("involvedObject"));
                            }
                            involved_object__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = map.next_value()?;
                        }
                        GeneratedField::FirstTimestamp => {
                            if first_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firstTimestamp"));
                            }
                            first_timestamp__ = map.next_value()?;
                        }
                        GeneratedField::LastTimestamp => {
                            if last_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTimestamp"));
                            }
                            last_timestamp__ = map.next_value()?;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::EventTime => {
                            if event_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eventTime"));
                            }
                            event_time__ = map.next_value()?;
                        }
                        GeneratedField::Series => {
                            if series__.is_some() {
                                return Err(serde::de::Error::duplicate_field("series"));
                            }
                            series__ = map.next_value()?;
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = map.next_value()?;
                        }
                        GeneratedField::Related => {
                            if related__.is_some() {
                                return Err(serde::de::Error::duplicate_field("related"));
                            }
                            related__ = map.next_value()?;
                        }
                        GeneratedField::ReportingComponent => {
                            if reporting_component__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reportingComponent"));
                            }
                            reporting_component__ = map.next_value()?;
                        }
                        GeneratedField::ReportingInstance => {
                            if reporting_instance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reportingInstance"));
                            }
                            reporting_instance__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Event {
                    metadata: metadata__,
                    involved_object: involved_object__,
                    reason: reason__,
                    message: message__,
                    source: source__,
                    first_timestamp: first_timestamp__,
                    last_timestamp: last_timestamp__,
                    count: count__,
                    r#type: r#type__,
                    event_time: event_time__,
                    series: series__,
                    action: action__,
                    related: related__,
                    reporting_component: reporting_component__,
                    reporting_instance: reporting_instance__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Event", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EventList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EventList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EventList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EventList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EventList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EventList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EventList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EventSeries {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.count.is_some() {
            len += 1;
        }
        if self.last_observed_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EventSeries", len)?;
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("count", v)?;
        }
        if let Some(v) = self.last_observed_time.as_ref() {
            struct_ser.serialize_field("lastObservedTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EventSeries {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "count",
            "lastObservedTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Count,
            LastObservedTime,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "count" => Ok(GeneratedField::Count),
                            "lastObservedTime" => Ok(GeneratedField::LastObservedTime),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSeries;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EventSeries")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EventSeries, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut count__ = None;
                let mut last_observed_time__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastObservedTime => {
                            if last_observed_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastObservedTime"));
                            }
                            last_observed_time__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EventSeries {
                    count: count__,
                    last_observed_time: last_observed_time__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EventSeries", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EventSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.component.is_some() {
            len += 1;
        }
        if self.host.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.EventSource", len)?;
        if let Some(v) = self.component.as_ref() {
            struct_ser.serialize_field("component", v)?;
        }
        if let Some(v) = self.host.as_ref() {
            struct_ser.serialize_field("host", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EventSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "component",
            "host",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Component,
            Host,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "component" => Ok(GeneratedField::Component),
                            "host" => Ok(GeneratedField::Host),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.EventSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<EventSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut component__ = None;
                let mut host__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Component => {
                            if component__.is_some() {
                                return Err(serde::de::Error::duplicate_field("component"));
                            }
                            component__ = map.next_value()?;
                        }
                        GeneratedField::Host => {
                            if host__.is_some() {
                                return Err(serde::de::Error::duplicate_field("host"));
                            }
                            host__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EventSource {
                    component: component__,
                    host: host__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.EventSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.command.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ExecAction", len)?;
        if !self.command.is_empty() {
            struct_ser.serialize_field("command", &self.command)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "command",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Command,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "command" => Ok(GeneratedField::Command),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ExecAction")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ExecAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut command__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecAction {
                    command: command__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ExecAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FcVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.target_ww_ns.is_empty() {
            len += 1;
        }
        if self.lun.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if !self.wwids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.FCVolumeSource", len)?;
        if !self.target_ww_ns.is_empty() {
            struct_ser.serialize_field("targetWWNs", &self.target_ww_ns)?;
        }
        if let Some(v) = self.lun.as_ref() {
            struct_ser.serialize_field("lun", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if !self.wwids.is_empty() {
            struct_ser.serialize_field("wwids", &self.wwids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FcVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "targetWWNs",
            "lun",
            "fsType",
            "readOnly",
            "wwids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetWwNs,
            Lun,
            FsType,
            ReadOnly,
            Wwids,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "targetWWNs" => Ok(GeneratedField::TargetWwNs),
                            "lun" => Ok(GeneratedField::Lun),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "wwids" => Ok(GeneratedField::Wwids),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FcVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.FCVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<FcVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_ww_ns__ = None;
                let mut lun__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut wwids__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::TargetWwNs => {
                            if target_ww_ns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetWWNs"));
                            }
                            target_ww_ns__ = Some(map.next_value()?);
                        }
                        GeneratedField::Lun => {
                            if lun__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lun"));
                            }
                            lun__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Wwids => {
                            if wwids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wwids"));
                            }
                            wwids__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FcVolumeSource {
                    target_ww_ns: target_ww_ns__.unwrap_or_default(),
                    lun: lun__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    wwids: wwids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.FCVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FlexPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.driver.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.FlexPersistentVolumeSource", len)?;
        if let Some(v) = self.driver.as_ref() {
            struct_ser.serialize_field("driver", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FlexPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "driver",
            "fsType",
            "secretRef",
            "readOnly",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Driver,
            FsType,
            SecretRef,
            ReadOnly,
            Options,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "driver" => Ok(GeneratedField::Driver),
                            "fsType" => Ok(GeneratedField::FsType),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "options" => Ok(GeneratedField::Options),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FlexPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.FlexPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<FlexPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut driver__ = None;
                let mut fs_type__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                let mut options__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Driver => {
                            if driver__.is_some() {
                                return Err(serde::de::Error::duplicate_field("driver"));
                            }
                            driver__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FlexPersistentVolumeSource {
                    driver: driver__,
                    fs_type: fs_type__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.FlexPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FlexVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.driver.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.FlexVolumeSource", len)?;
        if let Some(v) = self.driver.as_ref() {
            struct_ser.serialize_field("driver", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FlexVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "driver",
            "fsType",
            "secretRef",
            "readOnly",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Driver,
            FsType,
            SecretRef,
            ReadOnly,
            Options,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "driver" => Ok(GeneratedField::Driver),
                            "fsType" => Ok(GeneratedField::FsType),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "options" => Ok(GeneratedField::Options),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FlexVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.FlexVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<FlexVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut driver__ = None;
                let mut fs_type__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                let mut options__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Driver => {
                            if driver__.is_some() {
                                return Err(serde::de::Error::duplicate_field("driver"));
                            }
                            driver__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FlexVolumeSource {
                    driver: driver__,
                    fs_type: fs_type__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.FlexVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FlockerVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dataset_name.is_some() {
            len += 1;
        }
        if self.dataset_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.FlockerVolumeSource", len)?;
        if let Some(v) = self.dataset_name.as_ref() {
            struct_ser.serialize_field("datasetName", v)?;
        }
        if let Some(v) = self.dataset_uuid.as_ref() {
            struct_ser.serialize_field("datasetUUID", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FlockerVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "datasetName",
            "datasetUUID",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DatasetName,
            DatasetUuid,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "datasetName" => Ok(GeneratedField::DatasetName),
                            "datasetUUID" => Ok(GeneratedField::DatasetUuid),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FlockerVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.FlockerVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<FlockerVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dataset_name__ = None;
                let mut dataset_uuid__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::DatasetName => {
                            if dataset_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datasetName"));
                            }
                            dataset_name__ = map.next_value()?;
                        }
                        GeneratedField::DatasetUuid => {
                            if dataset_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datasetUUID"));
                            }
                            dataset_uuid__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FlockerVolumeSource {
                    dataset_name: dataset_name__,
                    dataset_uuid: dataset_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.FlockerVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GcePersistentDiskVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pd_name.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.partition.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.GCEPersistentDiskVolumeSource", len)?;
        if let Some(v) = self.pd_name.as_ref() {
            struct_ser.serialize_field("pdName", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.partition.as_ref() {
            struct_ser.serialize_field("partition", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GcePersistentDiskVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pdName",
            "fsType",
            "partition",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PdName,
            FsType,
            Partition,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pdName" => Ok(GeneratedField::PdName),
                            "fsType" => Ok(GeneratedField::FsType),
                            "partition" => Ok(GeneratedField::Partition),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GcePersistentDiskVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.GCEPersistentDiskVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<GcePersistentDiskVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pd_name__ = None;
                let mut fs_type__ = None;
                let mut partition__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PdName => {
                            if pd_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pdName"));
                            }
                            pd_name__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::Partition => {
                            if partition__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partition"));
                            }
                            partition__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GcePersistentDiskVolumeSource {
                    pd_name: pd_name__,
                    fs_type: fs_type__,
                    partition: partition__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.GCEPersistentDiskVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GrpcAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.port.is_some() {
            len += 1;
        }
        if self.service.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.GRPCAction", len)?;
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.service.as_ref() {
            struct_ser.serialize_field("service", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GrpcAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "port",
            "service",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Port,
            Service,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "port" => Ok(GeneratedField::Port),
                            "service" => Ok(GeneratedField::Service),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GrpcAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.GRPCAction")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<GrpcAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut port__ = None;
                let mut service__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Service => {
                            if service__.is_some() {
                                return Err(serde::de::Error::duplicate_field("service"));
                            }
                            service__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GrpcAction {
                    port: port__,
                    service: service__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.GRPCAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GitRepoVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.repository.is_some() {
            len += 1;
        }
        if self.revision.is_some() {
            len += 1;
        }
        if self.directory.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.GitRepoVolumeSource", len)?;
        if let Some(v) = self.repository.as_ref() {
            struct_ser.serialize_field("repository", v)?;
        }
        if let Some(v) = self.revision.as_ref() {
            struct_ser.serialize_field("revision", v)?;
        }
        if let Some(v) = self.directory.as_ref() {
            struct_ser.serialize_field("directory", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GitRepoVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "repository",
            "revision",
            "directory",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Repository,
            Revision,
            Directory,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "repository" => Ok(GeneratedField::Repository),
                            "revision" => Ok(GeneratedField::Revision),
                            "directory" => Ok(GeneratedField::Directory),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GitRepoVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.GitRepoVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<GitRepoVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut repository__ = None;
                let mut revision__ = None;
                let mut directory__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Repository => {
                            if repository__.is_some() {
                                return Err(serde::de::Error::duplicate_field("repository"));
                            }
                            repository__ = map.next_value()?;
                        }
                        GeneratedField::Revision => {
                            if revision__.is_some() {
                                return Err(serde::de::Error::duplicate_field("revision"));
                            }
                            revision__ = map.next_value()?;
                        }
                        GeneratedField::Directory => {
                            if directory__.is_some() {
                                return Err(serde::de::Error::duplicate_field("directory"));
                            }
                            directory__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GitRepoVolumeSource {
                    repository: repository__,
                    revision: revision__,
                    directory: directory__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.GitRepoVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GlusterfsPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.endpoints.is_some() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.endpoints_namespace.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.GlusterfsPersistentVolumeSource", len)?;
        if let Some(v) = self.endpoints.as_ref() {
            struct_ser.serialize_field("endpoints", v)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.endpoints_namespace.as_ref() {
            struct_ser.serialize_field("endpointsNamespace", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GlusterfsPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "endpoints",
            "path",
            "readOnly",
            "endpointsNamespace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Endpoints,
            Path,
            ReadOnly,
            EndpointsNamespace,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "endpoints" => Ok(GeneratedField::Endpoints),
                            "path" => Ok(GeneratedField::Path),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "endpointsNamespace" => Ok(GeneratedField::EndpointsNamespace),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GlusterfsPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.GlusterfsPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<GlusterfsPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut endpoints__ = None;
                let mut path__ = None;
                let mut read_only__ = None;
                let mut endpoints_namespace__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Endpoints => {
                            if endpoints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endpoints"));
                            }
                            endpoints__ = map.next_value()?;
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::EndpointsNamespace => {
                            if endpoints_namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endpointsNamespace"));
                            }
                            endpoints_namespace__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GlusterfsPersistentVolumeSource {
                    endpoints: endpoints__,
                    path: path__,
                    read_only: read_only__,
                    endpoints_namespace: endpoints_namespace__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.GlusterfsPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GlusterfsVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.endpoints.is_some() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.GlusterfsVolumeSource", len)?;
        if let Some(v) = self.endpoints.as_ref() {
            struct_ser.serialize_field("endpoints", v)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GlusterfsVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "endpoints",
            "path",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Endpoints,
            Path,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "endpoints" => Ok(GeneratedField::Endpoints),
                            "path" => Ok(GeneratedField::Path),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GlusterfsVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.GlusterfsVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<GlusterfsVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut endpoints__ = None;
                let mut path__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Endpoints => {
                            if endpoints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endpoints"));
                            }
                            endpoints__ = map.next_value()?;
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GlusterfsVolumeSource {
                    endpoints: endpoints__,
                    path: path__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.GlusterfsVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HttpGetAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        if self.port.is_some() {
            len += 1;
        }
        if self.host.is_some() {
            len += 1;
        }
        if self.scheme.is_some() {
            len += 1;
        }
        if !self.http_headers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.HTTPGetAction", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.host.as_ref() {
            struct_ser.serialize_field("host", v)?;
        }
        if let Some(v) = self.scheme.as_ref() {
            struct_ser.serialize_field("scheme", v)?;
        }
        if !self.http_headers.is_empty() {
            struct_ser.serialize_field("httpHeaders", &self.http_headers)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HttpGetAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
            "port",
            "host",
            "scheme",
            "httpHeaders",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            Port,
            Host,
            Scheme,
            HttpHeaders,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            "port" => Ok(GeneratedField::Port),
                            "host" => Ok(GeneratedField::Host),
                            "scheme" => Ok(GeneratedField::Scheme),
                            "httpHeaders" => Ok(GeneratedField::HttpHeaders),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HttpGetAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.HTTPGetAction")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<HttpGetAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                let mut port__ = None;
                let mut host__ = None;
                let mut scheme__ = None;
                let mut http_headers__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = map.next_value()?;
                        }
                        GeneratedField::Host => {
                            if host__.is_some() {
                                return Err(serde::de::Error::duplicate_field("host"));
                            }
                            host__ = map.next_value()?;
                        }
                        GeneratedField::Scheme => {
                            if scheme__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheme"));
                            }
                            scheme__ = map.next_value()?;
                        }
                        GeneratedField::HttpHeaders => {
                            if http_headers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("httpHeaders"));
                            }
                            http_headers__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(HttpGetAction {
                    path: path__,
                    port: port__,
                    host: host__,
                    scheme: scheme__,
                    http_headers: http_headers__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.HTTPGetAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HttpHeader {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.HTTPHeader", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HttpHeader {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HttpHeader;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.HTTPHeader")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<HttpHeader, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(HttpHeader {
                    name: name__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.HTTPHeader", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HostAlias {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ip.is_some() {
            len += 1;
        }
        if !self.hostnames.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.HostAlias", len)?;
        if let Some(v) = self.ip.as_ref() {
            struct_ser.serialize_field("ip", v)?;
        }
        if !self.hostnames.is_empty() {
            struct_ser.serialize_field("hostnames", &self.hostnames)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HostAlias {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ip",
            "hostnames",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ip,
            Hostnames,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ip" => Ok(GeneratedField::Ip),
                            "hostnames" => Ok(GeneratedField::Hostnames),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HostAlias;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.HostAlias")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<HostAlias, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ip__ = None;
                let mut hostnames__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ip => {
                            if ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ip"));
                            }
                            ip__ = map.next_value()?;
                        }
                        GeneratedField::Hostnames => {
                            if hostnames__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostnames"));
                            }
                            hostnames__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(HostAlias {
                    ip: ip__,
                    hostnames: hostnames__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.HostAlias", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HostPathVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.HostPathVolumeSource", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HostPathVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            Type,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            "type" => Ok(GeneratedField::Type),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HostPathVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.HostPathVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<HostPathVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                let mut r#type__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(HostPathVolumeSource {
                    path: path__,
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.HostPathVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IscsiPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_portal.is_some() {
            len += 1;
        }
        if self.iqn.is_some() {
            len += 1;
        }
        if self.lun.is_some() {
            len += 1;
        }
        if self.iscsi_interface.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if !self.portals.is_empty() {
            len += 1;
        }
        if self.chap_auth_discovery.is_some() {
            len += 1;
        }
        if self.chap_auth_session.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.initiator_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ISCSIPersistentVolumeSource", len)?;
        if let Some(v) = self.target_portal.as_ref() {
            struct_ser.serialize_field("targetPortal", v)?;
        }
        if let Some(v) = self.iqn.as_ref() {
            struct_ser.serialize_field("iqn", v)?;
        }
        if let Some(v) = self.lun.as_ref() {
            struct_ser.serialize_field("lun", v)?;
        }
        if let Some(v) = self.iscsi_interface.as_ref() {
            struct_ser.serialize_field("iscsiInterface", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if !self.portals.is_empty() {
            struct_ser.serialize_field("portals", &self.portals)?;
        }
        if let Some(v) = self.chap_auth_discovery.as_ref() {
            struct_ser.serialize_field("chapAuthDiscovery", v)?;
        }
        if let Some(v) = self.chap_auth_session.as_ref() {
            struct_ser.serialize_field("chapAuthSession", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.initiator_name.as_ref() {
            struct_ser.serialize_field("initiatorName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IscsiPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "targetPortal",
            "iqn",
            "lun",
            "iscsiInterface",
            "fsType",
            "readOnly",
            "portals",
            "chapAuthDiscovery",
            "chapAuthSession",
            "secretRef",
            "initiatorName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetPortal,
            Iqn,
            Lun,
            IscsiInterface,
            FsType,
            ReadOnly,
            Portals,
            ChapAuthDiscovery,
            ChapAuthSession,
            SecretRef,
            InitiatorName,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "targetPortal" => Ok(GeneratedField::TargetPortal),
                            "iqn" => Ok(GeneratedField::Iqn),
                            "lun" => Ok(GeneratedField::Lun),
                            "iscsiInterface" => Ok(GeneratedField::IscsiInterface),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "portals" => Ok(GeneratedField::Portals),
                            "chapAuthDiscovery" => Ok(GeneratedField::ChapAuthDiscovery),
                            "chapAuthSession" => Ok(GeneratedField::ChapAuthSession),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "initiatorName" => Ok(GeneratedField::InitiatorName),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IscsiPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ISCSIPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<IscsiPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_portal__ = None;
                let mut iqn__ = None;
                let mut lun__ = None;
                let mut iscsi_interface__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut portals__ = None;
                let mut chap_auth_discovery__ = None;
                let mut chap_auth_session__ = None;
                let mut secret_ref__ = None;
                let mut initiator_name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::TargetPortal => {
                            if target_portal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetPortal"));
                            }
                            target_portal__ = map.next_value()?;
                        }
                        GeneratedField::Iqn => {
                            if iqn__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iqn"));
                            }
                            iqn__ = map.next_value()?;
                        }
                        GeneratedField::Lun => {
                            if lun__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lun"));
                            }
                            lun__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IscsiInterface => {
                            if iscsi_interface__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iscsiInterface"));
                            }
                            iscsi_interface__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Portals => {
                            if portals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portals"));
                            }
                            portals__ = Some(map.next_value()?);
                        }
                        GeneratedField::ChapAuthDiscovery => {
                            if chap_auth_discovery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chapAuthDiscovery"));
                            }
                            chap_auth_discovery__ = map.next_value()?;
                        }
                        GeneratedField::ChapAuthSession => {
                            if chap_auth_session__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chapAuthSession"));
                            }
                            chap_auth_session__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::InitiatorName => {
                            if initiator_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initiatorName"));
                            }
                            initiator_name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(IscsiPersistentVolumeSource {
                    target_portal: target_portal__,
                    iqn: iqn__,
                    lun: lun__,
                    iscsi_interface: iscsi_interface__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    portals: portals__.unwrap_or_default(),
                    chap_auth_discovery: chap_auth_discovery__,
                    chap_auth_session: chap_auth_session__,
                    secret_ref: secret_ref__,
                    initiator_name: initiator_name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ISCSIPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IscsiVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_portal.is_some() {
            len += 1;
        }
        if self.iqn.is_some() {
            len += 1;
        }
        if self.lun.is_some() {
            len += 1;
        }
        if self.iscsi_interface.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if !self.portals.is_empty() {
            len += 1;
        }
        if self.chap_auth_discovery.is_some() {
            len += 1;
        }
        if self.chap_auth_session.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.initiator_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ISCSIVolumeSource", len)?;
        if let Some(v) = self.target_portal.as_ref() {
            struct_ser.serialize_field("targetPortal", v)?;
        }
        if let Some(v) = self.iqn.as_ref() {
            struct_ser.serialize_field("iqn", v)?;
        }
        if let Some(v) = self.lun.as_ref() {
            struct_ser.serialize_field("lun", v)?;
        }
        if let Some(v) = self.iscsi_interface.as_ref() {
            struct_ser.serialize_field("iscsiInterface", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if !self.portals.is_empty() {
            struct_ser.serialize_field("portals", &self.portals)?;
        }
        if let Some(v) = self.chap_auth_discovery.as_ref() {
            struct_ser.serialize_field("chapAuthDiscovery", v)?;
        }
        if let Some(v) = self.chap_auth_session.as_ref() {
            struct_ser.serialize_field("chapAuthSession", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.initiator_name.as_ref() {
            struct_ser.serialize_field("initiatorName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IscsiVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "targetPortal",
            "iqn",
            "lun",
            "iscsiInterface",
            "fsType",
            "readOnly",
            "portals",
            "chapAuthDiscovery",
            "chapAuthSession",
            "secretRef",
            "initiatorName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetPortal,
            Iqn,
            Lun,
            IscsiInterface,
            FsType,
            ReadOnly,
            Portals,
            ChapAuthDiscovery,
            ChapAuthSession,
            SecretRef,
            InitiatorName,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "targetPortal" => Ok(GeneratedField::TargetPortal),
                            "iqn" => Ok(GeneratedField::Iqn),
                            "lun" => Ok(GeneratedField::Lun),
                            "iscsiInterface" => Ok(GeneratedField::IscsiInterface),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "portals" => Ok(GeneratedField::Portals),
                            "chapAuthDiscovery" => Ok(GeneratedField::ChapAuthDiscovery),
                            "chapAuthSession" => Ok(GeneratedField::ChapAuthSession),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "initiatorName" => Ok(GeneratedField::InitiatorName),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IscsiVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ISCSIVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<IscsiVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_portal__ = None;
                let mut iqn__ = None;
                let mut lun__ = None;
                let mut iscsi_interface__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut portals__ = None;
                let mut chap_auth_discovery__ = None;
                let mut chap_auth_session__ = None;
                let mut secret_ref__ = None;
                let mut initiator_name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::TargetPortal => {
                            if target_portal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetPortal"));
                            }
                            target_portal__ = map.next_value()?;
                        }
                        GeneratedField::Iqn => {
                            if iqn__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iqn"));
                            }
                            iqn__ = map.next_value()?;
                        }
                        GeneratedField::Lun => {
                            if lun__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lun"));
                            }
                            lun__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IscsiInterface => {
                            if iscsi_interface__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iscsiInterface"));
                            }
                            iscsi_interface__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::Portals => {
                            if portals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portals"));
                            }
                            portals__ = Some(map.next_value()?);
                        }
                        GeneratedField::ChapAuthDiscovery => {
                            if chap_auth_discovery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chapAuthDiscovery"));
                            }
                            chap_auth_discovery__ = map.next_value()?;
                        }
                        GeneratedField::ChapAuthSession => {
                            if chap_auth_session__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chapAuthSession"));
                            }
                            chap_auth_session__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::InitiatorName => {
                            if initiator_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initiatorName"));
                            }
                            initiator_name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(IscsiVolumeSource {
                    target_portal: target_portal__,
                    iqn: iqn__,
                    lun: lun__,
                    iscsi_interface: iscsi_interface__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    portals: portals__.unwrap_or_default(),
                    chap_auth_discovery: chap_auth_discovery__,
                    chap_auth_session: chap_auth_session__,
                    secret_ref: secret_ref__,
                    initiator_name: initiator_name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ISCSIVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for KeyToPath {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.KeyToPath", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.mode.as_ref() {
            struct_ser.serialize_field("mode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for KeyToPath {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "path",
            "mode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Path,
            Mode,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "path" => Ok(GeneratedField::Path),
                            "mode" => Ok(GeneratedField::Mode),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = KeyToPath;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.KeyToPath")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<KeyToPath, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut path__ = None;
                let mut mode__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(KeyToPath {
                    key: key__,
                    path: path__,
                    mode: mode__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.KeyToPath", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Lifecycle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.post_start.is_some() {
            len += 1;
        }
        if self.pre_stop.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Lifecycle", len)?;
        if let Some(v) = self.post_start.as_ref() {
            struct_ser.serialize_field("postStart", v)?;
        }
        if let Some(v) = self.pre_stop.as_ref() {
            struct_ser.serialize_field("preStop", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Lifecycle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "postStart",
            "preStop",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PostStart,
            PreStop,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "postStart" => Ok(GeneratedField::PostStart),
                            "preStop" => Ok(GeneratedField::PreStop),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Lifecycle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Lifecycle")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Lifecycle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut post_start__ = None;
                let mut pre_stop__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PostStart => {
                            if post_start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("postStart"));
                            }
                            post_start__ = map.next_value()?;
                        }
                        GeneratedField::PreStop => {
                            if pre_stop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preStop"));
                            }
                            pre_stop__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Lifecycle {
                    post_start: post_start__,
                    pre_stop: pre_stop__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Lifecycle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifecycleHandler {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.exec.is_some() {
            len += 1;
        }
        if self.http_get.is_some() {
            len += 1;
        }
        if self.tcp_socket.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LifecycleHandler", len)?;
        if let Some(v) = self.exec.as_ref() {
            struct_ser.serialize_field("exec", v)?;
        }
        if let Some(v) = self.http_get.as_ref() {
            struct_ser.serialize_field("httpGet", v)?;
        }
        if let Some(v) = self.tcp_socket.as_ref() {
            struct_ser.serialize_field("tcpSocket", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifecycleHandler {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exec",
            "httpGet",
            "tcpSocket",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Exec,
            HttpGet,
            TcpSocket,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exec" => Ok(GeneratedField::Exec),
                            "httpGet" => Ok(GeneratedField::HttpGet),
                            "tcpSocket" => Ok(GeneratedField::TcpSocket),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifecycleHandler;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LifecycleHandler")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LifecycleHandler, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exec__ = None;
                let mut http_get__ = None;
                let mut tcp_socket__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Exec => {
                            if exec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exec"));
                            }
                            exec__ = map.next_value()?;
                        }
                        GeneratedField::HttpGet => {
                            if http_get__.is_some() {
                                return Err(serde::de::Error::duplicate_field("httpGet"));
                            }
                            http_get__ = map.next_value()?;
                        }
                        GeneratedField::TcpSocket => {
                            if tcp_socket__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tcpSocket"));
                            }
                            tcp_socket__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LifecycleHandler {
                    exec: exec__,
                    http_get: http_get__,
                    tcp_socket: tcp_socket__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LifecycleHandler", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LimitRange {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LimitRange", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LimitRange {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitRange;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LimitRange")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LimitRange, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LimitRange {
                    metadata: metadata__,
                    spec: spec__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LimitRange", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LimitRangeItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if !self.max.is_empty() {
            len += 1;
        }
        if !self.min.is_empty() {
            len += 1;
        }
        if !self.default.is_empty() {
            len += 1;
        }
        if !self.default_request.is_empty() {
            len += 1;
        }
        if !self.max_limit_request_ratio.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LimitRangeItem", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if !self.max.is_empty() {
            struct_ser.serialize_field("max", &self.max)?;
        }
        if !self.min.is_empty() {
            struct_ser.serialize_field("min", &self.min)?;
        }
        if !self.default.is_empty() {
            struct_ser.serialize_field("default", &self.default)?;
        }
        if !self.default_request.is_empty() {
            struct_ser.serialize_field("defaultRequest", &self.default_request)?;
        }
        if !self.max_limit_request_ratio.is_empty() {
            struct_ser.serialize_field("maxLimitRequestRatio", &self.max_limit_request_ratio)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LimitRangeItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "max",
            "min",
            "default",
            "defaultRequest",
            "maxLimitRequestRatio",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Max,
            Min,
            Default,
            DefaultRequest,
            MaxLimitRequestRatio,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "max" => Ok(GeneratedField::Max),
                            "min" => Ok(GeneratedField::Min),
                            "default" => Ok(GeneratedField::Default),
                            "defaultRequest" => Ok(GeneratedField::DefaultRequest),
                            "maxLimitRequestRatio" => Ok(GeneratedField::MaxLimitRequestRatio),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitRangeItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LimitRangeItem")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LimitRangeItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut max__ = None;
                let mut min__ = None;
                let mut default__ = None;
                let mut default_request__ = None;
                let mut max_limit_request_ratio__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Max => {
                            if max__.is_some() {
                                return Err(serde::de::Error::duplicate_field("max"));
                            }
                            max__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Min => {
                            if min__.is_some() {
                                return Err(serde::de::Error::duplicate_field("min"));
                            }
                            min__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Default => {
                            if default__.is_some() {
                                return Err(serde::de::Error::duplicate_field("default"));
                            }
                            default__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::DefaultRequest => {
                            if default_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultRequest"));
                            }
                            default_request__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::MaxLimitRequestRatio => {
                            if max_limit_request_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxLimitRequestRatio"));
                            }
                            max_limit_request_ratio__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LimitRangeItem {
                    r#type: r#type__,
                    max: max__.unwrap_or_default(),
                    min: min__.unwrap_or_default(),
                    default: default__.unwrap_or_default(),
                    default_request: default_request__.unwrap_or_default(),
                    max_limit_request_ratio: max_limit_request_ratio__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LimitRangeItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LimitRangeList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LimitRangeList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LimitRangeList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitRangeList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LimitRangeList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LimitRangeList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LimitRangeList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LimitRangeList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LimitRangeSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.limits.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LimitRangeSpec", len)?;
        if !self.limits.is_empty() {
            struct_ser.serialize_field("limits", &self.limits)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LimitRangeSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "limits",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Limits,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "limits" => Ok(GeneratedField::Limits),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitRangeSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LimitRangeSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LimitRangeSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut limits__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Limits => {
                            if limits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limits"));
                            }
                            limits__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LimitRangeSpec {
                    limits: limits__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LimitRangeSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.List", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.List")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(List {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LoadBalancerIngress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ip.is_some() {
            len += 1;
        }
        if self.hostname.is_some() {
            len += 1;
        }
        if !self.ports.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LoadBalancerIngress", len)?;
        if let Some(v) = self.ip.as_ref() {
            struct_ser.serialize_field("ip", v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            struct_ser.serialize_field("hostname", v)?;
        }
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LoadBalancerIngress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ip",
            "hostname",
            "ports",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ip,
            Hostname,
            Ports,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ip" => Ok(GeneratedField::Ip),
                            "hostname" => Ok(GeneratedField::Hostname),
                            "ports" => Ok(GeneratedField::Ports),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LoadBalancerIngress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LoadBalancerIngress")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LoadBalancerIngress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ip__ = None;
                let mut hostname__ = None;
                let mut ports__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ip => {
                            if ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ip"));
                            }
                            ip__ = map.next_value()?;
                        }
                        GeneratedField::Hostname => {
                            if hostname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostname"));
                            }
                            hostname__ = map.next_value()?;
                        }
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LoadBalancerIngress {
                    ip: ip__,
                    hostname: hostname__,
                    ports: ports__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LoadBalancerIngress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LoadBalancerStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ingress.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LoadBalancerStatus", len)?;
        if !self.ingress.is_empty() {
            struct_ser.serialize_field("ingress", &self.ingress)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LoadBalancerStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ingress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ingress,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ingress" => Ok(GeneratedField::Ingress),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LoadBalancerStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LoadBalancerStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LoadBalancerStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ingress__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ingress => {
                            if ingress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ingress"));
                            }
                            ingress__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LoadBalancerStatus {
                    ingress: ingress__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LoadBalancerStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LocalObjectReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LocalObjectReference", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LocalObjectReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LocalObjectReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LocalObjectReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LocalObjectReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LocalObjectReference {
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LocalObjectReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LocalVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.LocalVolumeSource", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LocalVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
            "fsType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            FsType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            "fsType" => Ok(GeneratedField::FsType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LocalVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.LocalVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<LocalVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                let mut fs_type__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LocalVolumeSource {
                    path: path__,
                    fs_type: fs_type__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.LocalVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NfsVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.server.is_some() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NFSVolumeSource", len)?;
        if let Some(v) = self.server.as_ref() {
            struct_ser.serialize_field("server", v)?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NfsVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "server",
            "path",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Server,
            Path,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "server" => Ok(GeneratedField::Server),
                            "path" => Ok(GeneratedField::Path),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NfsVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NFSVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NfsVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut server__ = None;
                let mut path__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Server => {
                            if server__.is_some() {
                                return Err(serde::de::Error::duplicate_field("server"));
                            }
                            server__ = map.next_value()?;
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NfsVolumeSource {
                    server: server__,
                    path: path__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NFSVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Namespace {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Namespace", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Namespace {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Namespace;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Namespace")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Namespace, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Namespace {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Namespace", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamespaceCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.last_transition_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NamespaceCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.last_transition_time.as_ref() {
            struct_ser.serialize_field("lastTransitionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamespaceCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "lastTransitionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            LastTransitionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "lastTransitionTime" => Ok(GeneratedField::LastTransitionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamespaceCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NamespaceCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NamespaceCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut last_transition_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::LastTransitionTime => {
                            if last_transition_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTransitionTime"));
                            }
                            last_transition_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NamespaceCondition {
                    r#type: r#type__,
                    status: status__,
                    last_transition_time: last_transition_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NamespaceCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamespaceList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NamespaceList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamespaceList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamespaceList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NamespaceList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NamespaceList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NamespaceList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NamespaceList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamespaceSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.finalizers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NamespaceSpec", len)?;
        if !self.finalizers.is_empty() {
            struct_ser.serialize_field("finalizers", &self.finalizers)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamespaceSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "finalizers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Finalizers,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "finalizers" => Ok(GeneratedField::Finalizers),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamespaceSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NamespaceSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NamespaceSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finalizers__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Finalizers => {
                            if finalizers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("finalizers"));
                            }
                            finalizers__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NamespaceSpec {
                    finalizers: finalizers__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NamespaceSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NamespaceStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.phase.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NamespaceStatus", len)?;
        if let Some(v) = self.phase.as_ref() {
            struct_ser.serialize_field("phase", v)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NamespaceStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "phase",
            "conditions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Phase,
            Conditions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "phase" => Ok(GeneratedField::Phase),
                            "conditions" => Ok(GeneratedField::Conditions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NamespaceStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NamespaceStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NamespaceStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut phase__ = None;
                let mut conditions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = map.next_value()?;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NamespaceStatus {
                    phase: phase__,
                    conditions: conditions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NamespaceStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Node {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Node", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Node {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Node;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Node")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Node, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Node {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Node", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeAddress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.address.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeAddress", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeAddress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "address",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Address,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "address" => Ok(GeneratedField::Address),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeAddress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeAddress")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeAddress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut address__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeAddress {
                    r#type: r#type__,
                    address: address__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeAddress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeAffinity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.required_during_scheduling_ignored_during_execution.is_some() {
            len += 1;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeAffinity", len)?;
        if let Some(v) = self.required_during_scheduling_ignored_during_execution.as_ref() {
            struct_ser.serialize_field("requiredDuringSchedulingIgnoredDuringExecution", v)?;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            struct_ser.serialize_field("preferredDuringSchedulingIgnoredDuringExecution", &self.preferred_during_scheduling_ignored_during_execution)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeAffinity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "requiredDuringSchedulingIgnoredDuringExecution",
            "preferredDuringSchedulingIgnoredDuringExecution",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequiredDuringSchedulingIgnoredDuringExecution,
            PreferredDuringSchedulingIgnoredDuringExecution,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requiredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution),
                            "preferredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeAffinity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeAffinity")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeAffinity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut required_during_scheduling_ignored_during_execution__ = None;
                let mut preferred_during_scheduling_ignored_during_execution__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution => {
                            if required_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requiredDuringSchedulingIgnoredDuringExecution"));
                            }
                            required_during_scheduling_ignored_during_execution__ = map.next_value()?;
                        }
                        GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution => {
                            if preferred_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preferredDuringSchedulingIgnoredDuringExecution"));
                            }
                            preferred_during_scheduling_ignored_during_execution__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeAffinity {
                    required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution__,
                    preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeAffinity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.last_heartbeat_time.is_some() {
            len += 1;
        }
        if self.last_transition_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.last_heartbeat_time.as_ref() {
            struct_ser.serialize_field("lastHeartbeatTime", v)?;
        }
        if let Some(v) = self.last_transition_time.as_ref() {
            struct_ser.serialize_field("lastTransitionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "lastHeartbeatTime",
            "lastTransitionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            LastHeartbeatTime,
            LastTransitionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "lastHeartbeatTime" => Ok(GeneratedField::LastHeartbeatTime),
                            "lastTransitionTime" => Ok(GeneratedField::LastTransitionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut last_heartbeat_time__ = None;
                let mut last_transition_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::LastHeartbeatTime => {
                            if last_heartbeat_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastHeartbeatTime"));
                            }
                            last_heartbeat_time__ = map.next_value()?;
                        }
                        GeneratedField::LastTransitionTime => {
                            if last_transition_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTransitionTime"));
                            }
                            last_transition_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeCondition {
                    r#type: r#type__,
                    status: status__,
                    last_heartbeat_time: last_heartbeat_time__,
                    last_transition_time: last_transition_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeConfigSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.config_map.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeConfigSource", len)?;
        if let Some(v) = self.config_map.as_ref() {
            struct_ser.serialize_field("configMap", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeConfigSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "configMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfigMap,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "configMap" => Ok(GeneratedField::ConfigMap),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeConfigSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeConfigSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeConfigSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut config_map__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ConfigMap => {
                            if config_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configMap"));
                            }
                            config_map__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeConfigSource {
                    config_map: config_map__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeConfigSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeConfigStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.assigned.is_some() {
            len += 1;
        }
        if self.active.is_some() {
            len += 1;
        }
        if self.last_known_good.is_some() {
            len += 1;
        }
        if self.error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeConfigStatus", len)?;
        if let Some(v) = self.assigned.as_ref() {
            struct_ser.serialize_field("assigned", v)?;
        }
        if let Some(v) = self.active.as_ref() {
            struct_ser.serialize_field("active", v)?;
        }
        if let Some(v) = self.last_known_good.as_ref() {
            struct_ser.serialize_field("lastKnownGood", v)?;
        }
        if let Some(v) = self.error.as_ref() {
            struct_ser.serialize_field("error", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeConfigStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "assigned",
            "active",
            "lastKnownGood",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Assigned,
            Active,
            LastKnownGood,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "assigned" => Ok(GeneratedField::Assigned),
                            "active" => Ok(GeneratedField::Active),
                            "lastKnownGood" => Ok(GeneratedField::LastKnownGood),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeConfigStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeConfigStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeConfigStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut assigned__ = None;
                let mut active__ = None;
                let mut last_known_good__ = None;
                let mut error__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Assigned => {
                            if assigned__.is_some() {
                                return Err(serde::de::Error::duplicate_field("assigned"));
                            }
                            assigned__ = map.next_value()?;
                        }
                        GeneratedField::Active => {
                            if active__.is_some() {
                                return Err(serde::de::Error::duplicate_field("active"));
                            }
                            active__ = map.next_value()?;
                        }
                        GeneratedField::LastKnownGood => {
                            if last_known_good__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastKnownGood"));
                            }
                            last_known_good__ = map.next_value()?;
                        }
                        GeneratedField::Error => {
                            if error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            error__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeConfigStatus {
                    assigned: assigned__,
                    active: active__,
                    last_known_good: last_known_good__,
                    error: error__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeConfigStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeDaemonEndpoints {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kubelet_endpoint.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeDaemonEndpoints", len)?;
        if let Some(v) = self.kubelet_endpoint.as_ref() {
            struct_ser.serialize_field("kubeletEndpoint", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeDaemonEndpoints {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kubeletEndpoint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            KubeletEndpoint,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kubeletEndpoint" => Ok(GeneratedField::KubeletEndpoint),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeDaemonEndpoints;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeDaemonEndpoints")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeDaemonEndpoints, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kubelet_endpoint__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::KubeletEndpoint => {
                            if kubelet_endpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kubeletEndpoint"));
                            }
                            kubelet_endpoint__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeDaemonEndpoints {
                    kubelet_endpoint: kubelet_endpoint__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeDaemonEndpoints", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeProxyOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeProxyOptions", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeProxyOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeProxyOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeProxyOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeProxyOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeProxyOptions {
                    path: path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeProxyOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeResources {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.capacity.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeResources", len)?;
        if !self.capacity.is_empty() {
            struct_ser.serialize_field("capacity", &self.capacity)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeResources {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capacity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capacity,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capacity" => Ok(GeneratedField::Capacity),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeResources;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeResources")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeResources, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capacity__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeResources {
                    capacity: capacity__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeResources", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeSelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.node_selector_terms.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeSelector", len)?;
        if !self.node_selector_terms.is_empty() {
            struct_ser.serialize_field("nodeSelectorTerms", &self.node_selector_terms)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeSelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "nodeSelectorTerms",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NodeSelectorTerms,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nodeSelectorTerms" => Ok(GeneratedField::NodeSelectorTerms),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeSelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeSelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeSelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut node_selector_terms__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::NodeSelectorTerms => {
                            if node_selector_terms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeSelectorTerms"));
                            }
                            node_selector_terms__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeSelector {
                    node_selector_terms: node_selector_terms__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeSelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeSelectorRequirement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.operator.is_some() {
            len += 1;
        }
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeSelectorRequirement", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            struct_ser.serialize_field("operator", v)?;
        }
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeSelectorRequirement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "operator",
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Operator,
            Values,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "operator" => Ok(GeneratedField::Operator),
                            "values" => Ok(GeneratedField::Values),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeSelectorRequirement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeSelectorRequirement")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeSelectorRequirement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut operator__ = None;
                let mut values__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Operator => {
                            if operator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operator"));
                            }
                            operator__ = map.next_value()?;
                        }
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeSelectorRequirement {
                    key: key__,
                    operator: operator__,
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeSelectorRequirement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeSelectorTerm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.match_expressions.is_empty() {
            len += 1;
        }
        if !self.match_fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeSelectorTerm", len)?;
        if !self.match_expressions.is_empty() {
            struct_ser.serialize_field("matchExpressions", &self.match_expressions)?;
        }
        if !self.match_fields.is_empty() {
            struct_ser.serialize_field("matchFields", &self.match_fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeSelectorTerm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "matchExpressions",
            "matchFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MatchExpressions,
            MatchFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "matchExpressions" => Ok(GeneratedField::MatchExpressions),
                            "matchFields" => Ok(GeneratedField::MatchFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeSelectorTerm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeSelectorTerm")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeSelectorTerm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut match_expressions__ = None;
                let mut match_fields__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::MatchExpressions => {
                            if match_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matchExpressions"));
                            }
                            match_expressions__ = Some(map.next_value()?);
                        }
                        GeneratedField::MatchFields => {
                            if match_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matchFields"));
                            }
                            match_fields__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeSelectorTerm {
                    match_expressions: match_expressions__.unwrap_or_default(),
                    match_fields: match_fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeSelectorTerm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pod_cidr.is_some() {
            len += 1;
        }
        if !self.pod_cid_rs.is_empty() {
            len += 1;
        }
        if self.provider_id.is_some() {
            len += 1;
        }
        if self.unschedulable.is_some() {
            len += 1;
        }
        if !self.taints.is_empty() {
            len += 1;
        }
        if self.config_source.is_some() {
            len += 1;
        }
        if self.external_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeSpec", len)?;
        if let Some(v) = self.pod_cidr.as_ref() {
            struct_ser.serialize_field("podCIDR", v)?;
        }
        if !self.pod_cid_rs.is_empty() {
            struct_ser.serialize_field("podCIDRs", &self.pod_cid_rs)?;
        }
        if let Some(v) = self.provider_id.as_ref() {
            struct_ser.serialize_field("providerID", v)?;
        }
        if let Some(v) = self.unschedulable.as_ref() {
            struct_ser.serialize_field("unschedulable", v)?;
        }
        if !self.taints.is_empty() {
            struct_ser.serialize_field("taints", &self.taints)?;
        }
        if let Some(v) = self.config_source.as_ref() {
            struct_ser.serialize_field("configSource", v)?;
        }
        if let Some(v) = self.external_id.as_ref() {
            struct_ser.serialize_field("externalID", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "podCIDR",
            "podCIDRs",
            "providerID",
            "unschedulable",
            "taints",
            "configSource",
            "externalID",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PodCidr,
            PodCidRs,
            ProviderId,
            Unschedulable,
            Taints,
            ConfigSource,
            ExternalId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "podCIDR" => Ok(GeneratedField::PodCidr),
                            "podCIDRs" => Ok(GeneratedField::PodCidRs),
                            "providerID" => Ok(GeneratedField::ProviderId),
                            "unschedulable" => Ok(GeneratedField::Unschedulable),
                            "taints" => Ok(GeneratedField::Taints),
                            "configSource" => Ok(GeneratedField::ConfigSource),
                            "externalID" => Ok(GeneratedField::ExternalId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pod_cidr__ = None;
                let mut pod_cid_rs__ = None;
                let mut provider_id__ = None;
                let mut unschedulable__ = None;
                let mut taints__ = None;
                let mut config_source__ = None;
                let mut external_id__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PodCidr => {
                            if pod_cidr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podCIDR"));
                            }
                            pod_cidr__ = map.next_value()?;
                        }
                        GeneratedField::PodCidRs => {
                            if pod_cid_rs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podCIDRs"));
                            }
                            pod_cid_rs__ = Some(map.next_value()?);
                        }
                        GeneratedField::ProviderId => {
                            if provider_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("providerID"));
                            }
                            provider_id__ = map.next_value()?;
                        }
                        GeneratedField::Unschedulable => {
                            if unschedulable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unschedulable"));
                            }
                            unschedulable__ = map.next_value()?;
                        }
                        GeneratedField::Taints => {
                            if taints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("taints"));
                            }
                            taints__ = Some(map.next_value()?);
                        }
                        GeneratedField::ConfigSource => {
                            if config_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configSource"));
                            }
                            config_source__ = map.next_value()?;
                        }
                        GeneratedField::ExternalId => {
                            if external_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("externalID"));
                            }
                            external_id__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeSpec {
                    pod_cidr: pod_cidr__,
                    pod_cid_rs: pod_cid_rs__.unwrap_or_default(),
                    provider_id: provider_id__,
                    unschedulable: unschedulable__,
                    taints: taints__.unwrap_or_default(),
                    config_source: config_source__,
                    external_id: external_id__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.capacity.is_empty() {
            len += 1;
        }
        if !self.allocatable.is_empty() {
            len += 1;
        }
        if self.phase.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        if !self.addresses.is_empty() {
            len += 1;
        }
        if self.daemon_endpoints.is_some() {
            len += 1;
        }
        if self.node_info.is_some() {
            len += 1;
        }
        if !self.images.is_empty() {
            len += 1;
        }
        if !self.volumes_in_use.is_empty() {
            len += 1;
        }
        if !self.volumes_attached.is_empty() {
            len += 1;
        }
        if self.config.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeStatus", len)?;
        if !self.capacity.is_empty() {
            struct_ser.serialize_field("capacity", &self.capacity)?;
        }
        if !self.allocatable.is_empty() {
            struct_ser.serialize_field("allocatable", &self.allocatable)?;
        }
        if let Some(v) = self.phase.as_ref() {
            struct_ser.serialize_field("phase", v)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        if !self.addresses.is_empty() {
            struct_ser.serialize_field("addresses", &self.addresses)?;
        }
        if let Some(v) = self.daemon_endpoints.as_ref() {
            struct_ser.serialize_field("daemonEndpoints", v)?;
        }
        if let Some(v) = self.node_info.as_ref() {
            struct_ser.serialize_field("nodeInfo", v)?;
        }
        if !self.images.is_empty() {
            struct_ser.serialize_field("images", &self.images)?;
        }
        if !self.volumes_in_use.is_empty() {
            struct_ser.serialize_field("volumesInUse", &self.volumes_in_use)?;
        }
        if !self.volumes_attached.is_empty() {
            struct_ser.serialize_field("volumesAttached", &self.volumes_attached)?;
        }
        if let Some(v) = self.config.as_ref() {
            struct_ser.serialize_field("config", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capacity",
            "allocatable",
            "phase",
            "conditions",
            "addresses",
            "daemonEndpoints",
            "nodeInfo",
            "images",
            "volumesInUse",
            "volumesAttached",
            "config",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capacity,
            Allocatable,
            Phase,
            Conditions,
            Addresses,
            DaemonEndpoints,
            NodeInfo,
            Images,
            VolumesInUse,
            VolumesAttached,
            Config,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capacity" => Ok(GeneratedField::Capacity),
                            "allocatable" => Ok(GeneratedField::Allocatable),
                            "phase" => Ok(GeneratedField::Phase),
                            "conditions" => Ok(GeneratedField::Conditions),
                            "addresses" => Ok(GeneratedField::Addresses),
                            "daemonEndpoints" => Ok(GeneratedField::DaemonEndpoints),
                            "nodeInfo" => Ok(GeneratedField::NodeInfo),
                            "images" => Ok(GeneratedField::Images),
                            "volumesInUse" => Ok(GeneratedField::VolumesInUse),
                            "volumesAttached" => Ok(GeneratedField::VolumesAttached),
                            "config" => Ok(GeneratedField::Config),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capacity__ = None;
                let mut allocatable__ = None;
                let mut phase__ = None;
                let mut conditions__ = None;
                let mut addresses__ = None;
                let mut daemon_endpoints__ = None;
                let mut node_info__ = None;
                let mut images__ = None;
                let mut volumes_in_use__ = None;
                let mut volumes_attached__ = None;
                let mut config__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Allocatable => {
                            if allocatable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allocatable"));
                            }
                            allocatable__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = map.next_value()?;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::Addresses => {
                            if addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("addresses"));
                            }
                            addresses__ = Some(map.next_value()?);
                        }
                        GeneratedField::DaemonEndpoints => {
                            if daemon_endpoints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("daemonEndpoints"));
                            }
                            daemon_endpoints__ = map.next_value()?;
                        }
                        GeneratedField::NodeInfo => {
                            if node_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeInfo"));
                            }
                            node_info__ = map.next_value()?;
                        }
                        GeneratedField::Images => {
                            if images__.is_some() {
                                return Err(serde::de::Error::duplicate_field("images"));
                            }
                            images__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumesInUse => {
                            if volumes_in_use__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumesInUse"));
                            }
                            volumes_in_use__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumesAttached => {
                            if volumes_attached__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumesAttached"));
                            }
                            volumes_attached__ = Some(map.next_value()?);
                        }
                        GeneratedField::Config => {
                            if config__.is_some() {
                                return Err(serde::de::Error::duplicate_field("config"));
                            }
                            config__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeStatus {
                    capacity: capacity__.unwrap_or_default(),
                    allocatable: allocatable__.unwrap_or_default(),
                    phase: phase__,
                    conditions: conditions__.unwrap_or_default(),
                    addresses: addresses__.unwrap_or_default(),
                    daemon_endpoints: daemon_endpoints__,
                    node_info: node_info__,
                    images: images__.unwrap_or_default(),
                    volumes_in_use: volumes_in_use__.unwrap_or_default(),
                    volumes_attached: volumes_attached__.unwrap_or_default(),
                    config: config__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NodeSystemInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.machine_id.is_some() {
            len += 1;
        }
        if self.system_uuid.is_some() {
            len += 1;
        }
        if self.boot_id.is_some() {
            len += 1;
        }
        if self.kernel_version.is_some() {
            len += 1;
        }
        if self.os_image.is_some() {
            len += 1;
        }
        if self.container_runtime_version.is_some() {
            len += 1;
        }
        if self.kubelet_version.is_some() {
            len += 1;
        }
        if self.kube_proxy_version.is_some() {
            len += 1;
        }
        if self.operating_system.is_some() {
            len += 1;
        }
        if self.architecture.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.NodeSystemInfo", len)?;
        if let Some(v) = self.machine_id.as_ref() {
            struct_ser.serialize_field("machineID", v)?;
        }
        if let Some(v) = self.system_uuid.as_ref() {
            struct_ser.serialize_field("systemUUID", v)?;
        }
        if let Some(v) = self.boot_id.as_ref() {
            struct_ser.serialize_field("bootID", v)?;
        }
        if let Some(v) = self.kernel_version.as_ref() {
            struct_ser.serialize_field("kernelVersion", v)?;
        }
        if let Some(v) = self.os_image.as_ref() {
            struct_ser.serialize_field("osImage", v)?;
        }
        if let Some(v) = self.container_runtime_version.as_ref() {
            struct_ser.serialize_field("containerRuntimeVersion", v)?;
        }
        if let Some(v) = self.kubelet_version.as_ref() {
            struct_ser.serialize_field("kubeletVersion", v)?;
        }
        if let Some(v) = self.kube_proxy_version.as_ref() {
            struct_ser.serialize_field("kubeProxyVersion", v)?;
        }
        if let Some(v) = self.operating_system.as_ref() {
            struct_ser.serialize_field("operatingSystem", v)?;
        }
        if let Some(v) = self.architecture.as_ref() {
            struct_ser.serialize_field("architecture", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NodeSystemInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "machineID",
            "systemUUID",
            "bootID",
            "kernelVersion",
            "osImage",
            "containerRuntimeVersion",
            "kubeletVersion",
            "kubeProxyVersion",
            "operatingSystem",
            "architecture",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MachineId,
            SystemUuid,
            BootId,
            KernelVersion,
            OsImage,
            ContainerRuntimeVersion,
            KubeletVersion,
            KubeProxyVersion,
            OperatingSystem,
            Architecture,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "machineID" => Ok(GeneratedField::MachineId),
                            "systemUUID" => Ok(GeneratedField::SystemUuid),
                            "bootID" => Ok(GeneratedField::BootId),
                            "kernelVersion" => Ok(GeneratedField::KernelVersion),
                            "osImage" => Ok(GeneratedField::OsImage),
                            "containerRuntimeVersion" => Ok(GeneratedField::ContainerRuntimeVersion),
                            "kubeletVersion" => Ok(GeneratedField::KubeletVersion),
                            "kubeProxyVersion" => Ok(GeneratedField::KubeProxyVersion),
                            "operatingSystem" => Ok(GeneratedField::OperatingSystem),
                            "architecture" => Ok(GeneratedField::Architecture),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NodeSystemInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.NodeSystemInfo")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<NodeSystemInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut machine_id__ = None;
                let mut system_uuid__ = None;
                let mut boot_id__ = None;
                let mut kernel_version__ = None;
                let mut os_image__ = None;
                let mut container_runtime_version__ = None;
                let mut kubelet_version__ = None;
                let mut kube_proxy_version__ = None;
                let mut operating_system__ = None;
                let mut architecture__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::MachineId => {
                            if machine_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("machineID"));
                            }
                            machine_id__ = map.next_value()?;
                        }
                        GeneratedField::SystemUuid => {
                            if system_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemUUID"));
                            }
                            system_uuid__ = map.next_value()?;
                        }
                        GeneratedField::BootId => {
                            if boot_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bootID"));
                            }
                            boot_id__ = map.next_value()?;
                        }
                        GeneratedField::KernelVersion => {
                            if kernel_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kernelVersion"));
                            }
                            kernel_version__ = map.next_value()?;
                        }
                        GeneratedField::OsImage => {
                            if os_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("osImage"));
                            }
                            os_image__ = map.next_value()?;
                        }
                        GeneratedField::ContainerRuntimeVersion => {
                            if container_runtime_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerRuntimeVersion"));
                            }
                            container_runtime_version__ = map.next_value()?;
                        }
                        GeneratedField::KubeletVersion => {
                            if kubelet_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kubeletVersion"));
                            }
                            kubelet_version__ = map.next_value()?;
                        }
                        GeneratedField::KubeProxyVersion => {
                            if kube_proxy_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kubeProxyVersion"));
                            }
                            kube_proxy_version__ = map.next_value()?;
                        }
                        GeneratedField::OperatingSystem => {
                            if operating_system__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operatingSystem"));
                            }
                            operating_system__ = map.next_value()?;
                        }
                        GeneratedField::Architecture => {
                            if architecture__.is_some() {
                                return Err(serde::de::Error::duplicate_field("architecture"));
                            }
                            architecture__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NodeSystemInfo {
                    machine_id: machine_id__,
                    system_uuid: system_uuid__,
                    boot_id: boot_id__,
                    kernel_version: kernel_version__,
                    os_image: os_image__,
                    container_runtime_version: container_runtime_version__,
                    kubelet_version: kubelet_version__,
                    kube_proxy_version: kube_proxy_version__,
                    operating_system: operating_system__,
                    architecture: architecture__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.NodeSystemInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ObjectFieldSelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.api_version.is_some() {
            len += 1;
        }
        if self.field_path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ObjectFieldSelector", len)?;
        if let Some(v) = self.api_version.as_ref() {
            struct_ser.serialize_field("apiVersion", v)?;
        }
        if let Some(v) = self.field_path.as_ref() {
            struct_ser.serialize_field("fieldPath", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ObjectFieldSelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "apiVersion",
            "fieldPath",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ApiVersion,
            FieldPath,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "apiVersion" => Ok(GeneratedField::ApiVersion),
                            "fieldPath" => Ok(GeneratedField::FieldPath),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ObjectFieldSelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ObjectFieldSelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ObjectFieldSelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut api_version__ = None;
                let mut field_path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ApiVersion => {
                            if api_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apiVersion"));
                            }
                            api_version__ = map.next_value()?;
                        }
                        GeneratedField::FieldPath => {
                            if field_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldPath"));
                            }
                            field_path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ObjectFieldSelector {
                    api_version: api_version__,
                    field_path: field_path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ObjectFieldSelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ObjectReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.namespace.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.uid.is_some() {
            len += 1;
        }
        if self.api_version.is_some() {
            len += 1;
        }
        if self.resource_version.is_some() {
            len += 1;
        }
        if self.field_path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ObjectReference", len)?;
        if let Some(v) = self.kind.as_ref() {
            struct_ser.serialize_field("kind", v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            struct_ser.serialize_field("namespace", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.uid.as_ref() {
            struct_ser.serialize_field("uid", v)?;
        }
        if let Some(v) = self.api_version.as_ref() {
            struct_ser.serialize_field("apiVersion", v)?;
        }
        if let Some(v) = self.resource_version.as_ref() {
            struct_ser.serialize_field("resourceVersion", v)?;
        }
        if let Some(v) = self.field_path.as_ref() {
            struct_ser.serialize_field("fieldPath", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ObjectReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "namespace",
            "name",
            "uid",
            "apiVersion",
            "resourceVersion",
            "fieldPath",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Namespace,
            Name,
            Uid,
            ApiVersion,
            ResourceVersion,
            FieldPath,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "namespace" => Ok(GeneratedField::Namespace),
                            "name" => Ok(GeneratedField::Name),
                            "uid" => Ok(GeneratedField::Uid),
                            "apiVersion" => Ok(GeneratedField::ApiVersion),
                            "resourceVersion" => Ok(GeneratedField::ResourceVersion),
                            "fieldPath" => Ok(GeneratedField::FieldPath),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ObjectReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ObjectReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ObjectReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut namespace__ = None;
                let mut name__ = None;
                let mut uid__ = None;
                let mut api_version__ = None;
                let mut resource_version__ = None;
                let mut field_path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map.next_value()?;
                        }
                        GeneratedField::Namespace => {
                            if namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespace"));
                            }
                            namespace__ = map.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = map.next_value()?;
                        }
                        GeneratedField::ApiVersion => {
                            if api_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apiVersion"));
                            }
                            api_version__ = map.next_value()?;
                        }
                        GeneratedField::ResourceVersion => {
                            if resource_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceVersion"));
                            }
                            resource_version__ = map.next_value()?;
                        }
                        GeneratedField::FieldPath => {
                            if field_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldPath"));
                            }
                            field_path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ObjectReference {
                    kind: kind__,
                    namespace: namespace__,
                    name: name__,
                    uid: uid__,
                    api_version: api_version__,
                    resource_version: resource_version__,
                    field_path: field_path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ObjectReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolume", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolume")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolume, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolume {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolume", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaim {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaim", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaim {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaim;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaim")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaim, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaim {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaim", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.last_probe_time.is_some() {
            len += 1;
        }
        if self.last_transition_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.last_probe_time.as_ref() {
            struct_ser.serialize_field("lastProbeTime", v)?;
        }
        if let Some(v) = self.last_transition_time.as_ref() {
            struct_ser.serialize_field("lastTransitionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "lastProbeTime",
            "lastTransitionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            LastProbeTime,
            LastTransitionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "lastProbeTime" => Ok(GeneratedField::LastProbeTime),
                            "lastTransitionTime" => Ok(GeneratedField::LastTransitionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut last_probe_time__ = None;
                let mut last_transition_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::LastProbeTime => {
                            if last_probe_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastProbeTime"));
                            }
                            last_probe_time__ = map.next_value()?;
                        }
                        GeneratedField::LastTransitionTime => {
                            if last_transition_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTransitionTime"));
                            }
                            last_transition_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimCondition {
                    r#type: r#type__,
                    status: status__,
                    last_probe_time: last_probe_time__,
                    last_transition_time: last_transition_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.access_modes.is_empty() {
            len += 1;
        }
        if self.selector.is_some() {
            len += 1;
        }
        if self.resources.is_some() {
            len += 1;
        }
        if self.volume_name.is_some() {
            len += 1;
        }
        if self.storage_class_name.is_some() {
            len += 1;
        }
        if self.volume_mode.is_some() {
            len += 1;
        }
        if self.data_source.is_some() {
            len += 1;
        }
        if self.data_source_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimSpec", len)?;
        if !self.access_modes.is_empty() {
            struct_ser.serialize_field("accessModes", &self.access_modes)?;
        }
        if let Some(v) = self.selector.as_ref() {
            struct_ser.serialize_field("selector", v)?;
        }
        if let Some(v) = self.resources.as_ref() {
            struct_ser.serialize_field("resources", v)?;
        }
        if let Some(v) = self.volume_name.as_ref() {
            struct_ser.serialize_field("volumeName", v)?;
        }
        if let Some(v) = self.storage_class_name.as_ref() {
            struct_ser.serialize_field("storageClassName", v)?;
        }
        if let Some(v) = self.volume_mode.as_ref() {
            struct_ser.serialize_field("volumeMode", v)?;
        }
        if let Some(v) = self.data_source.as_ref() {
            struct_ser.serialize_field("dataSource", v)?;
        }
        if let Some(v) = self.data_source_ref.as_ref() {
            struct_ser.serialize_field("dataSourceRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "accessModes",
            "selector",
            "resources",
            "volumeName",
            "storageClassName",
            "volumeMode",
            "dataSource",
            "dataSourceRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccessModes,
            Selector,
            Resources,
            VolumeName,
            StorageClassName,
            VolumeMode,
            DataSource,
            DataSourceRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accessModes" => Ok(GeneratedField::AccessModes),
                            "selector" => Ok(GeneratedField::Selector),
                            "resources" => Ok(GeneratedField::Resources),
                            "volumeName" => Ok(GeneratedField::VolumeName),
                            "storageClassName" => Ok(GeneratedField::StorageClassName),
                            "volumeMode" => Ok(GeneratedField::VolumeMode),
                            "dataSource" => Ok(GeneratedField::DataSource),
                            "dataSourceRef" => Ok(GeneratedField::DataSourceRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut access_modes__ = None;
                let mut selector__ = None;
                let mut resources__ = None;
                let mut volume_name__ = None;
                let mut storage_class_name__ = None;
                let mut volume_mode__ = None;
                let mut data_source__ = None;
                let mut data_source_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::AccessModes => {
                            if access_modes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessModes"));
                            }
                            access_modes__ = Some(map.next_value()?);
                        }
                        GeneratedField::Selector => {
                            if selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selector"));
                            }
                            selector__ = map.next_value()?;
                        }
                        GeneratedField::Resources => {
                            if resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resources"));
                            }
                            resources__ = map.next_value()?;
                        }
                        GeneratedField::VolumeName => {
                            if volume_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeName"));
                            }
                            volume_name__ = map.next_value()?;
                        }
                        GeneratedField::StorageClassName => {
                            if storage_class_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageClassName"));
                            }
                            storage_class_name__ = map.next_value()?;
                        }
                        GeneratedField::VolumeMode => {
                            if volume_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeMode"));
                            }
                            volume_mode__ = map.next_value()?;
                        }
                        GeneratedField::DataSource => {
                            if data_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataSource"));
                            }
                            data_source__ = map.next_value()?;
                        }
                        GeneratedField::DataSourceRef => {
                            if data_source_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataSourceRef"));
                            }
                            data_source_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimSpec {
                    access_modes: access_modes__.unwrap_or_default(),
                    selector: selector__,
                    resources: resources__,
                    volume_name: volume_name__,
                    storage_class_name: storage_class_name__,
                    volume_mode: volume_mode__,
                    data_source: data_source__,
                    data_source_ref: data_source_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.phase.is_some() {
            len += 1;
        }
        if !self.access_modes.is_empty() {
            len += 1;
        }
        if !self.capacity.is_empty() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        if !self.allocated_resources.is_empty() {
            len += 1;
        }
        if self.resize_status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimStatus", len)?;
        if let Some(v) = self.phase.as_ref() {
            struct_ser.serialize_field("phase", v)?;
        }
        if !self.access_modes.is_empty() {
            struct_ser.serialize_field("accessModes", &self.access_modes)?;
        }
        if !self.capacity.is_empty() {
            struct_ser.serialize_field("capacity", &self.capacity)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        if !self.allocated_resources.is_empty() {
            struct_ser.serialize_field("allocatedResources", &self.allocated_resources)?;
        }
        if let Some(v) = self.resize_status.as_ref() {
            struct_ser.serialize_field("resizeStatus", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "phase",
            "accessModes",
            "capacity",
            "conditions",
            "allocatedResources",
            "resizeStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Phase,
            AccessModes,
            Capacity,
            Conditions,
            AllocatedResources,
            ResizeStatus,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "phase" => Ok(GeneratedField::Phase),
                            "accessModes" => Ok(GeneratedField::AccessModes),
                            "capacity" => Ok(GeneratedField::Capacity),
                            "conditions" => Ok(GeneratedField::Conditions),
                            "allocatedResources" => Ok(GeneratedField::AllocatedResources),
                            "resizeStatus" => Ok(GeneratedField::ResizeStatus),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut phase__ = None;
                let mut access_modes__ = None;
                let mut capacity__ = None;
                let mut conditions__ = None;
                let mut allocated_resources__ = None;
                let mut resize_status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = map.next_value()?;
                        }
                        GeneratedField::AccessModes => {
                            if access_modes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessModes"));
                            }
                            access_modes__ = Some(map.next_value()?);
                        }
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::AllocatedResources => {
                            if allocated_resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allocatedResources"));
                            }
                            allocated_resources__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::ResizeStatus => {
                            if resize_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resizeStatus"));
                            }
                            resize_status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimStatus {
                    phase: phase__,
                    access_modes: access_modes__.unwrap_or_default(),
                    capacity: capacity__.unwrap_or_default(),
                    conditions: conditions__.unwrap_or_default(),
                    allocated_resources: allocated_resources__.unwrap_or_default(),
                    resize_status: resize_status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimTemplate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimTemplate", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimTemplate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimTemplate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimTemplate")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimTemplate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimTemplate {
                    metadata: metadata__,
                    spec: spec__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimTemplate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeClaimVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.claim_name.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource", len)?;
        if let Some(v) = self.claim_name.as_ref() {
            struct_ser.serialize_field("claimName", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeClaimVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "claimName",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClaimName,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "claimName" => Ok(GeneratedField::ClaimName),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeClaimVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeClaimVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut claim_name__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ClaimName => {
                            if claim_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("claimName"));
                            }
                            claim_name__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeClaimVolumeSource {
                    claim_name: claim_name__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.gce_persistent_disk.is_some() {
            len += 1;
        }
        if self.aws_elastic_block_store.is_some() {
            len += 1;
        }
        if self.host_path.is_some() {
            len += 1;
        }
        if self.glusterfs.is_some() {
            len += 1;
        }
        if self.nfs.is_some() {
            len += 1;
        }
        if self.rbd.is_some() {
            len += 1;
        }
        if self.iscsi.is_some() {
            len += 1;
        }
        if self.cinder.is_some() {
            len += 1;
        }
        if self.cephfs.is_some() {
            len += 1;
        }
        if self.fc.is_some() {
            len += 1;
        }
        if self.flocker.is_some() {
            len += 1;
        }
        if self.flex_volume.is_some() {
            len += 1;
        }
        if self.azure_file.is_some() {
            len += 1;
        }
        if self.vsphere_volume.is_some() {
            len += 1;
        }
        if self.quobyte.is_some() {
            len += 1;
        }
        if self.azure_disk.is_some() {
            len += 1;
        }
        if self.photon_persistent_disk.is_some() {
            len += 1;
        }
        if self.portworx_volume.is_some() {
            len += 1;
        }
        if self.scale_io.is_some() {
            len += 1;
        }
        if self.local.is_some() {
            len += 1;
        }
        if self.storageos.is_some() {
            len += 1;
        }
        if self.csi.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeSource", len)?;
        if let Some(v) = self.gce_persistent_disk.as_ref() {
            struct_ser.serialize_field("gcePersistentDisk", v)?;
        }
        if let Some(v) = self.aws_elastic_block_store.as_ref() {
            struct_ser.serialize_field("awsElasticBlockStore", v)?;
        }
        if let Some(v) = self.host_path.as_ref() {
            struct_ser.serialize_field("hostPath", v)?;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            struct_ser.serialize_field("glusterfs", v)?;
        }
        if let Some(v) = self.nfs.as_ref() {
            struct_ser.serialize_field("nfs", v)?;
        }
        if let Some(v) = self.rbd.as_ref() {
            struct_ser.serialize_field("rbd", v)?;
        }
        if let Some(v) = self.iscsi.as_ref() {
            struct_ser.serialize_field("iscsi", v)?;
        }
        if let Some(v) = self.cinder.as_ref() {
            struct_ser.serialize_field("cinder", v)?;
        }
        if let Some(v) = self.cephfs.as_ref() {
            struct_ser.serialize_field("cephfs", v)?;
        }
        if let Some(v) = self.fc.as_ref() {
            struct_ser.serialize_field("fc", v)?;
        }
        if let Some(v) = self.flocker.as_ref() {
            struct_ser.serialize_field("flocker", v)?;
        }
        if let Some(v) = self.flex_volume.as_ref() {
            struct_ser.serialize_field("flexVolume", v)?;
        }
        if let Some(v) = self.azure_file.as_ref() {
            struct_ser.serialize_field("azureFile", v)?;
        }
        if let Some(v) = self.vsphere_volume.as_ref() {
            struct_ser.serialize_field("vsphereVolume", v)?;
        }
        if let Some(v) = self.quobyte.as_ref() {
            struct_ser.serialize_field("quobyte", v)?;
        }
        if let Some(v) = self.azure_disk.as_ref() {
            struct_ser.serialize_field("azureDisk", v)?;
        }
        if let Some(v) = self.photon_persistent_disk.as_ref() {
            struct_ser.serialize_field("photonPersistentDisk", v)?;
        }
        if let Some(v) = self.portworx_volume.as_ref() {
            struct_ser.serialize_field("portworxVolume", v)?;
        }
        if let Some(v) = self.scale_io.as_ref() {
            struct_ser.serialize_field("scaleIO", v)?;
        }
        if let Some(v) = self.local.as_ref() {
            struct_ser.serialize_field("local", v)?;
        }
        if let Some(v) = self.storageos.as_ref() {
            struct_ser.serialize_field("storageos", v)?;
        }
        if let Some(v) = self.csi.as_ref() {
            struct_ser.serialize_field("csi", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "gcePersistentDisk",
            "awsElasticBlockStore",
            "hostPath",
            "glusterfs",
            "nfs",
            "rbd",
            "iscsi",
            "cinder",
            "cephfs",
            "fc",
            "flocker",
            "flexVolume",
            "azureFile",
            "vsphereVolume",
            "quobyte",
            "azureDisk",
            "photonPersistentDisk",
            "portworxVolume",
            "scaleIO",
            "local",
            "storageos",
            "csi",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GcePersistentDisk,
            AwsElasticBlockStore,
            HostPath,
            Glusterfs,
            Nfs,
            Rbd,
            Iscsi,
            Cinder,
            Cephfs,
            Fc,
            Flocker,
            FlexVolume,
            AzureFile,
            VsphereVolume,
            Quobyte,
            AzureDisk,
            PhotonPersistentDisk,
            PortworxVolume,
            ScaleIo,
            Local,
            Storageos,
            Csi,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "gcePersistentDisk" => Ok(GeneratedField::GcePersistentDisk),
                            "awsElasticBlockStore" => Ok(GeneratedField::AwsElasticBlockStore),
                            "hostPath" => Ok(GeneratedField::HostPath),
                            "glusterfs" => Ok(GeneratedField::Glusterfs),
                            "nfs" => Ok(GeneratedField::Nfs),
                            "rbd" => Ok(GeneratedField::Rbd),
                            "iscsi" => Ok(GeneratedField::Iscsi),
                            "cinder" => Ok(GeneratedField::Cinder),
                            "cephfs" => Ok(GeneratedField::Cephfs),
                            "fc" => Ok(GeneratedField::Fc),
                            "flocker" => Ok(GeneratedField::Flocker),
                            "flexVolume" => Ok(GeneratedField::FlexVolume),
                            "azureFile" => Ok(GeneratedField::AzureFile),
                            "vsphereVolume" => Ok(GeneratedField::VsphereVolume),
                            "quobyte" => Ok(GeneratedField::Quobyte),
                            "azureDisk" => Ok(GeneratedField::AzureDisk),
                            "photonPersistentDisk" => Ok(GeneratedField::PhotonPersistentDisk),
                            "portworxVolume" => Ok(GeneratedField::PortworxVolume),
                            "scaleIO" => Ok(GeneratedField::ScaleIo),
                            "local" => Ok(GeneratedField::Local),
                            "storageos" => Ok(GeneratedField::Storageos),
                            "csi" => Ok(GeneratedField::Csi),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gce_persistent_disk__ = None;
                let mut aws_elastic_block_store__ = None;
                let mut host_path__ = None;
                let mut glusterfs__ = None;
                let mut nfs__ = None;
                let mut rbd__ = None;
                let mut iscsi__ = None;
                let mut cinder__ = None;
                let mut cephfs__ = None;
                let mut fc__ = None;
                let mut flocker__ = None;
                let mut flex_volume__ = None;
                let mut azure_file__ = None;
                let mut vsphere_volume__ = None;
                let mut quobyte__ = None;
                let mut azure_disk__ = None;
                let mut photon_persistent_disk__ = None;
                let mut portworx_volume__ = None;
                let mut scale_io__ = None;
                let mut local__ = None;
                let mut storageos__ = None;
                let mut csi__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::GcePersistentDisk => {
                            if gce_persistent_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gcePersistentDisk"));
                            }
                            gce_persistent_disk__ = map.next_value()?;
                        }
                        GeneratedField::AwsElasticBlockStore => {
                            if aws_elastic_block_store__.is_some() {
                                return Err(serde::de::Error::duplicate_field("awsElasticBlockStore"));
                            }
                            aws_elastic_block_store__ = map.next_value()?;
                        }
                        GeneratedField::HostPath => {
                            if host_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostPath"));
                            }
                            host_path__ = map.next_value()?;
                        }
                        GeneratedField::Glusterfs => {
                            if glusterfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("glusterfs"));
                            }
                            glusterfs__ = map.next_value()?;
                        }
                        GeneratedField::Nfs => {
                            if nfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nfs"));
                            }
                            nfs__ = map.next_value()?;
                        }
                        GeneratedField::Rbd => {
                            if rbd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rbd"));
                            }
                            rbd__ = map.next_value()?;
                        }
                        GeneratedField::Iscsi => {
                            if iscsi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iscsi"));
                            }
                            iscsi__ = map.next_value()?;
                        }
                        GeneratedField::Cinder => {
                            if cinder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cinder"));
                            }
                            cinder__ = map.next_value()?;
                        }
                        GeneratedField::Cephfs => {
                            if cephfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cephfs"));
                            }
                            cephfs__ = map.next_value()?;
                        }
                        GeneratedField::Fc => {
                            if fc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fc"));
                            }
                            fc__ = map.next_value()?;
                        }
                        GeneratedField::Flocker => {
                            if flocker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("flocker"));
                            }
                            flocker__ = map.next_value()?;
                        }
                        GeneratedField::FlexVolume => {
                            if flex_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("flexVolume"));
                            }
                            flex_volume__ = map.next_value()?;
                        }
                        GeneratedField::AzureFile => {
                            if azure_file__.is_some() {
                                return Err(serde::de::Error::duplicate_field("azureFile"));
                            }
                            azure_file__ = map.next_value()?;
                        }
                        GeneratedField::VsphereVolume => {
                            if vsphere_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vsphereVolume"));
                            }
                            vsphere_volume__ = map.next_value()?;
                        }
                        GeneratedField::Quobyte => {
                            if quobyte__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quobyte"));
                            }
                            quobyte__ = map.next_value()?;
                        }
                        GeneratedField::AzureDisk => {
                            if azure_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("azureDisk"));
                            }
                            azure_disk__ = map.next_value()?;
                        }
                        GeneratedField::PhotonPersistentDisk => {
                            if photon_persistent_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("photonPersistentDisk"));
                            }
                            photon_persistent_disk__ = map.next_value()?;
                        }
                        GeneratedField::PortworxVolume => {
                            if portworx_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portworxVolume"));
                            }
                            portworx_volume__ = map.next_value()?;
                        }
                        GeneratedField::ScaleIo => {
                            if scale_io__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scaleIO"));
                            }
                            scale_io__ = map.next_value()?;
                        }
                        GeneratedField::Local => {
                            if local__.is_some() {
                                return Err(serde::de::Error::duplicate_field("local"));
                            }
                            local__ = map.next_value()?;
                        }
                        GeneratedField::Storageos => {
                            if storageos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageos"));
                            }
                            storageos__ = map.next_value()?;
                        }
                        GeneratedField::Csi => {
                            if csi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("csi"));
                            }
                            csi__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeSource {
                    gce_persistent_disk: gce_persistent_disk__,
                    aws_elastic_block_store: aws_elastic_block_store__,
                    host_path: host_path__,
                    glusterfs: glusterfs__,
                    nfs: nfs__,
                    rbd: rbd__,
                    iscsi: iscsi__,
                    cinder: cinder__,
                    cephfs: cephfs__,
                    fc: fc__,
                    flocker: flocker__,
                    flex_volume: flex_volume__,
                    azure_file: azure_file__,
                    vsphere_volume: vsphere_volume__,
                    quobyte: quobyte__,
                    azure_disk: azure_disk__,
                    photon_persistent_disk: photon_persistent_disk__,
                    portworx_volume: portworx_volume__,
                    scale_io: scale_io__,
                    local: local__,
                    storageos: storageos__,
                    csi: csi__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.capacity.is_empty() {
            len += 1;
        }
        if self.persistent_volume_source.is_some() {
            len += 1;
        }
        if !self.access_modes.is_empty() {
            len += 1;
        }
        if self.claim_ref.is_some() {
            len += 1;
        }
        if self.persistent_volume_reclaim_policy.is_some() {
            len += 1;
        }
        if self.storage_class_name.is_some() {
            len += 1;
        }
        if !self.mount_options.is_empty() {
            len += 1;
        }
        if self.volume_mode.is_some() {
            len += 1;
        }
        if self.node_affinity.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeSpec", len)?;
        if !self.capacity.is_empty() {
            struct_ser.serialize_field("capacity", &self.capacity)?;
        }
        if let Some(v) = self.persistent_volume_source.as_ref() {
            struct_ser.serialize_field("persistentVolumeSource", v)?;
        }
        if !self.access_modes.is_empty() {
            struct_ser.serialize_field("accessModes", &self.access_modes)?;
        }
        if let Some(v) = self.claim_ref.as_ref() {
            struct_ser.serialize_field("claimRef", v)?;
        }
        if let Some(v) = self.persistent_volume_reclaim_policy.as_ref() {
            struct_ser.serialize_field("persistentVolumeReclaimPolicy", v)?;
        }
        if let Some(v) = self.storage_class_name.as_ref() {
            struct_ser.serialize_field("storageClassName", v)?;
        }
        if !self.mount_options.is_empty() {
            struct_ser.serialize_field("mountOptions", &self.mount_options)?;
        }
        if let Some(v) = self.volume_mode.as_ref() {
            struct_ser.serialize_field("volumeMode", v)?;
        }
        if let Some(v) = self.node_affinity.as_ref() {
            struct_ser.serialize_field("nodeAffinity", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capacity",
            "persistentVolumeSource",
            "accessModes",
            "claimRef",
            "persistentVolumeReclaimPolicy",
            "storageClassName",
            "mountOptions",
            "volumeMode",
            "nodeAffinity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capacity,
            PersistentVolumeSource,
            AccessModes,
            ClaimRef,
            PersistentVolumeReclaimPolicy,
            StorageClassName,
            MountOptions,
            VolumeMode,
            NodeAffinity,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capacity" => Ok(GeneratedField::Capacity),
                            "persistentVolumeSource" => Ok(GeneratedField::PersistentVolumeSource),
                            "accessModes" => Ok(GeneratedField::AccessModes),
                            "claimRef" => Ok(GeneratedField::ClaimRef),
                            "persistentVolumeReclaimPolicy" => Ok(GeneratedField::PersistentVolumeReclaimPolicy),
                            "storageClassName" => Ok(GeneratedField::StorageClassName),
                            "mountOptions" => Ok(GeneratedField::MountOptions),
                            "volumeMode" => Ok(GeneratedField::VolumeMode),
                            "nodeAffinity" => Ok(GeneratedField::NodeAffinity),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capacity__ = None;
                let mut persistent_volume_source__ = None;
                let mut access_modes__ = None;
                let mut claim_ref__ = None;
                let mut persistent_volume_reclaim_policy__ = None;
                let mut storage_class_name__ = None;
                let mut mount_options__ = None;
                let mut volume_mode__ = None;
                let mut node_affinity__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::PersistentVolumeSource => {
                            if persistent_volume_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("persistentVolumeSource"));
                            }
                            persistent_volume_source__ = map.next_value()?;
                        }
                        GeneratedField::AccessModes => {
                            if access_modes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accessModes"));
                            }
                            access_modes__ = Some(map.next_value()?);
                        }
                        GeneratedField::ClaimRef => {
                            if claim_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("claimRef"));
                            }
                            claim_ref__ = map.next_value()?;
                        }
                        GeneratedField::PersistentVolumeReclaimPolicy => {
                            if persistent_volume_reclaim_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("persistentVolumeReclaimPolicy"));
                            }
                            persistent_volume_reclaim_policy__ = map.next_value()?;
                        }
                        GeneratedField::StorageClassName => {
                            if storage_class_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageClassName"));
                            }
                            storage_class_name__ = map.next_value()?;
                        }
                        GeneratedField::MountOptions => {
                            if mount_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mountOptions"));
                            }
                            mount_options__ = Some(map.next_value()?);
                        }
                        GeneratedField::VolumeMode => {
                            if volume_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeMode"));
                            }
                            volume_mode__ = map.next_value()?;
                        }
                        GeneratedField::NodeAffinity => {
                            if node_affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeAffinity"));
                            }
                            node_affinity__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeSpec {
                    capacity: capacity__.unwrap_or_default(),
                    persistent_volume_source: persistent_volume_source__,
                    access_modes: access_modes__.unwrap_or_default(),
                    claim_ref: claim_ref__,
                    persistent_volume_reclaim_policy: persistent_volume_reclaim_policy__,
                    storage_class_name: storage_class_name__,
                    mount_options: mount_options__.unwrap_or_default(),
                    volume_mode: volume_mode__,
                    node_affinity: node_affinity__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersistentVolumeStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.phase.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PersistentVolumeStatus", len)?;
        if let Some(v) = self.phase.as_ref() {
            struct_ser.serialize_field("phase", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersistentVolumeStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "phase",
            "message",
            "reason",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Phase,
            Message,
            Reason,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "phase" => Ok(GeneratedField::Phase),
                            "message" => Ok(GeneratedField::Message),
                            "reason" => Ok(GeneratedField::Reason),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersistentVolumeStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PersistentVolumeStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PersistentVolumeStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut phase__ = None;
                let mut message__ = None;
                let mut reason__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PersistentVolumeStatus {
                    phase: phase__,
                    message: message__,
                    reason: reason__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PersistentVolumeStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhotonPersistentDiskVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pd_id.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource", len)?;
        if let Some(v) = self.pd_id.as_ref() {
            struct_ser.serialize_field("pdID", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhotonPersistentDiskVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pdID",
            "fsType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PdId,
            FsType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pdID" => Ok(GeneratedField::PdId),
                            "fsType" => Ok(GeneratedField::FsType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhotonPersistentDiskVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PhotonPersistentDiskVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pd_id__ = None;
                let mut fs_type__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PdId => {
                            if pd_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pdID"));
                            }
                            pd_id__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PhotonPersistentDiskVolumeSource {
                    pd_id: pd_id__,
                    fs_type: fs_type__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Pod {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Pod", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Pod {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Pod;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Pod")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Pod, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Pod {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Pod", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodAffinity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.required_during_scheduling_ignored_during_execution.is_empty() {
            len += 1;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodAffinity", len)?;
        if !self.required_during_scheduling_ignored_during_execution.is_empty() {
            struct_ser.serialize_field("requiredDuringSchedulingIgnoredDuringExecution", &self.required_during_scheduling_ignored_during_execution)?;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            struct_ser.serialize_field("preferredDuringSchedulingIgnoredDuringExecution", &self.preferred_during_scheduling_ignored_during_execution)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodAffinity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "requiredDuringSchedulingIgnoredDuringExecution",
            "preferredDuringSchedulingIgnoredDuringExecution",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequiredDuringSchedulingIgnoredDuringExecution,
            PreferredDuringSchedulingIgnoredDuringExecution,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requiredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution),
                            "preferredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodAffinity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodAffinity")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodAffinity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut required_during_scheduling_ignored_during_execution__ = None;
                let mut preferred_during_scheduling_ignored_during_execution__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution => {
                            if required_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requiredDuringSchedulingIgnoredDuringExecution"));
                            }
                            required_during_scheduling_ignored_during_execution__ = Some(map.next_value()?);
                        }
                        GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution => {
                            if preferred_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preferredDuringSchedulingIgnoredDuringExecution"));
                            }
                            preferred_during_scheduling_ignored_during_execution__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodAffinity {
                    required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution__.unwrap_or_default(),
                    preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodAffinity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodAffinityTerm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.label_selector.is_some() {
            len += 1;
        }
        if !self.namespaces.is_empty() {
            len += 1;
        }
        if self.topology_key.is_some() {
            len += 1;
        }
        if self.namespace_selector.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodAffinityTerm", len)?;
        if let Some(v) = self.label_selector.as_ref() {
            struct_ser.serialize_field("labelSelector", v)?;
        }
        if !self.namespaces.is_empty() {
            struct_ser.serialize_field("namespaces", &self.namespaces)?;
        }
        if let Some(v) = self.topology_key.as_ref() {
            struct_ser.serialize_field("topologyKey", v)?;
        }
        if let Some(v) = self.namespace_selector.as_ref() {
            struct_ser.serialize_field("namespaceSelector", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodAffinityTerm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "labelSelector",
            "namespaces",
            "topologyKey",
            "namespaceSelector",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LabelSelector,
            Namespaces,
            TopologyKey,
            NamespaceSelector,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "labelSelector" => Ok(GeneratedField::LabelSelector),
                            "namespaces" => Ok(GeneratedField::Namespaces),
                            "topologyKey" => Ok(GeneratedField::TopologyKey),
                            "namespaceSelector" => Ok(GeneratedField::NamespaceSelector),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodAffinityTerm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodAffinityTerm")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodAffinityTerm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut label_selector__ = None;
                let mut namespaces__ = None;
                let mut topology_key__ = None;
                let mut namespace_selector__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LabelSelector => {
                            if label_selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("labelSelector"));
                            }
                            label_selector__ = map.next_value()?;
                        }
                        GeneratedField::Namespaces => {
                            if namespaces__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespaces"));
                            }
                            namespaces__ = Some(map.next_value()?);
                        }
                        GeneratedField::TopologyKey => {
                            if topology_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("topologyKey"));
                            }
                            topology_key__ = map.next_value()?;
                        }
                        GeneratedField::NamespaceSelector => {
                            if namespace_selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespaceSelector"));
                            }
                            namespace_selector__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodAffinityTerm {
                    label_selector: label_selector__,
                    namespaces: namespaces__.unwrap_or_default(),
                    topology_key: topology_key__,
                    namespace_selector: namespace_selector__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodAffinityTerm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodAntiAffinity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.required_during_scheduling_ignored_during_execution.is_empty() {
            len += 1;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodAntiAffinity", len)?;
        if !self.required_during_scheduling_ignored_during_execution.is_empty() {
            struct_ser.serialize_field("requiredDuringSchedulingIgnoredDuringExecution", &self.required_during_scheduling_ignored_during_execution)?;
        }
        if !self.preferred_during_scheduling_ignored_during_execution.is_empty() {
            struct_ser.serialize_field("preferredDuringSchedulingIgnoredDuringExecution", &self.preferred_during_scheduling_ignored_during_execution)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodAntiAffinity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "requiredDuringSchedulingIgnoredDuringExecution",
            "preferredDuringSchedulingIgnoredDuringExecution",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequiredDuringSchedulingIgnoredDuringExecution,
            PreferredDuringSchedulingIgnoredDuringExecution,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requiredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution),
                            "preferredDuringSchedulingIgnoredDuringExecution" => Ok(GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodAntiAffinity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodAntiAffinity")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodAntiAffinity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut required_during_scheduling_ignored_during_execution__ = None;
                let mut preferred_during_scheduling_ignored_during_execution__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::RequiredDuringSchedulingIgnoredDuringExecution => {
                            if required_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requiredDuringSchedulingIgnoredDuringExecution"));
                            }
                            required_during_scheduling_ignored_during_execution__ = Some(map.next_value()?);
                        }
                        GeneratedField::PreferredDuringSchedulingIgnoredDuringExecution => {
                            if preferred_during_scheduling_ignored_during_execution__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preferredDuringSchedulingIgnoredDuringExecution"));
                            }
                            preferred_during_scheduling_ignored_during_execution__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodAntiAffinity {
                    required_during_scheduling_ignored_during_execution: required_during_scheduling_ignored_during_execution__.unwrap_or_default(),
                    preferred_during_scheduling_ignored_during_execution: preferred_during_scheduling_ignored_during_execution__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodAntiAffinity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodAttachOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stdin.is_some() {
            len += 1;
        }
        if self.stdout.is_some() {
            len += 1;
        }
        if self.stderr.is_some() {
            len += 1;
        }
        if self.tty.is_some() {
            len += 1;
        }
        if self.container.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodAttachOptions", len)?;
        if let Some(v) = self.stdin.as_ref() {
            struct_ser.serialize_field("stdin", v)?;
        }
        if let Some(v) = self.stdout.as_ref() {
            struct_ser.serialize_field("stdout", v)?;
        }
        if let Some(v) = self.stderr.as_ref() {
            struct_ser.serialize_field("stderr", v)?;
        }
        if let Some(v) = self.tty.as_ref() {
            struct_ser.serialize_field("tty", v)?;
        }
        if let Some(v) = self.container.as_ref() {
            struct_ser.serialize_field("container", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodAttachOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stdin",
            "stdout",
            "stderr",
            "tty",
            "container",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Stdin,
            Stdout,
            Stderr,
            Tty,
            Container,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stdin" => Ok(GeneratedField::Stdin),
                            "stdout" => Ok(GeneratedField::Stdout),
                            "stderr" => Ok(GeneratedField::Stderr),
                            "tty" => Ok(GeneratedField::Tty),
                            "container" => Ok(GeneratedField::Container),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodAttachOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodAttachOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodAttachOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stdin__ = None;
                let mut stdout__ = None;
                let mut stderr__ = None;
                let mut tty__ = None;
                let mut container__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Stdin => {
                            if stdin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdin"));
                            }
                            stdin__ = map.next_value()?;
                        }
                        GeneratedField::Stdout => {
                            if stdout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdout"));
                            }
                            stdout__ = map.next_value()?;
                        }
                        GeneratedField::Stderr => {
                            if stderr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stderr"));
                            }
                            stderr__ = map.next_value()?;
                        }
                        GeneratedField::Tty => {
                            if tty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tty"));
                            }
                            tty__ = map.next_value()?;
                        }
                        GeneratedField::Container => {
                            if container__.is_some() {
                                return Err(serde::de::Error::duplicate_field("container"));
                            }
                            container__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodAttachOptions {
                    stdin: stdin__,
                    stdout: stdout__,
                    stderr: stderr__,
                    tty: tty__,
                    container: container__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodAttachOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.last_probe_time.is_some() {
            len += 1;
        }
        if self.last_transition_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.last_probe_time.as_ref() {
            struct_ser.serialize_field("lastProbeTime", v)?;
        }
        if let Some(v) = self.last_transition_time.as_ref() {
            struct_ser.serialize_field("lastTransitionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "lastProbeTime",
            "lastTransitionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            LastProbeTime,
            LastTransitionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "lastProbeTime" => Ok(GeneratedField::LastProbeTime),
                            "lastTransitionTime" => Ok(GeneratedField::LastTransitionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut last_probe_time__ = None;
                let mut last_transition_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::LastProbeTime => {
                            if last_probe_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastProbeTime"));
                            }
                            last_probe_time__ = map.next_value()?;
                        }
                        GeneratedField::LastTransitionTime => {
                            if last_transition_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTransitionTime"));
                            }
                            last_transition_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodCondition {
                    r#type: r#type__,
                    status: status__,
                    last_probe_time: last_probe_time__,
                    last_transition_time: last_transition_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodDnsConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.nameservers.is_empty() {
            len += 1;
        }
        if !self.searches.is_empty() {
            len += 1;
        }
        if !self.options.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodDNSConfig", len)?;
        if !self.nameservers.is_empty() {
            struct_ser.serialize_field("nameservers", &self.nameservers)?;
        }
        if !self.searches.is_empty() {
            struct_ser.serialize_field("searches", &self.searches)?;
        }
        if !self.options.is_empty() {
            struct_ser.serialize_field("options", &self.options)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodDnsConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "nameservers",
            "searches",
            "options",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Nameservers,
            Searches,
            Options,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nameservers" => Ok(GeneratedField::Nameservers),
                            "searches" => Ok(GeneratedField::Searches),
                            "options" => Ok(GeneratedField::Options),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodDnsConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodDNSConfig")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodDnsConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut nameservers__ = None;
                let mut searches__ = None;
                let mut options__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Nameservers => {
                            if nameservers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nameservers"));
                            }
                            nameservers__ = Some(map.next_value()?);
                        }
                        GeneratedField::Searches => {
                            if searches__.is_some() {
                                return Err(serde::de::Error::duplicate_field("searches"));
                            }
                            searches__ = Some(map.next_value()?);
                        }
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("options"));
                            }
                            options__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodDnsConfig {
                    nameservers: nameservers__.unwrap_or_default(),
                    searches: searches__.unwrap_or_default(),
                    options: options__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodDNSConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodDnsConfigOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodDNSConfigOption", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodDnsConfigOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodDnsConfigOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodDNSConfigOption")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodDnsConfigOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodDnsConfigOption {
                    name: name__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodDNSConfigOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodExecOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stdin.is_some() {
            len += 1;
        }
        if self.stdout.is_some() {
            len += 1;
        }
        if self.stderr.is_some() {
            len += 1;
        }
        if self.tty.is_some() {
            len += 1;
        }
        if self.container.is_some() {
            len += 1;
        }
        if !self.command.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodExecOptions", len)?;
        if let Some(v) = self.stdin.as_ref() {
            struct_ser.serialize_field("stdin", v)?;
        }
        if let Some(v) = self.stdout.as_ref() {
            struct_ser.serialize_field("stdout", v)?;
        }
        if let Some(v) = self.stderr.as_ref() {
            struct_ser.serialize_field("stderr", v)?;
        }
        if let Some(v) = self.tty.as_ref() {
            struct_ser.serialize_field("tty", v)?;
        }
        if let Some(v) = self.container.as_ref() {
            struct_ser.serialize_field("container", v)?;
        }
        if !self.command.is_empty() {
            struct_ser.serialize_field("command", &self.command)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodExecOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stdin",
            "stdout",
            "stderr",
            "tty",
            "container",
            "command",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Stdin,
            Stdout,
            Stderr,
            Tty,
            Container,
            Command,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stdin" => Ok(GeneratedField::Stdin),
                            "stdout" => Ok(GeneratedField::Stdout),
                            "stderr" => Ok(GeneratedField::Stderr),
                            "tty" => Ok(GeneratedField::Tty),
                            "container" => Ok(GeneratedField::Container),
                            "command" => Ok(GeneratedField::Command),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodExecOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodExecOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodExecOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stdin__ = None;
                let mut stdout__ = None;
                let mut stderr__ = None;
                let mut tty__ = None;
                let mut container__ = None;
                let mut command__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Stdin => {
                            if stdin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdin"));
                            }
                            stdin__ = map.next_value()?;
                        }
                        GeneratedField::Stdout => {
                            if stdout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stdout"));
                            }
                            stdout__ = map.next_value()?;
                        }
                        GeneratedField::Stderr => {
                            if stderr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stderr"));
                            }
                            stderr__ = map.next_value()?;
                        }
                        GeneratedField::Tty => {
                            if tty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tty"));
                            }
                            tty__ = map.next_value()?;
                        }
                        GeneratedField::Container => {
                            if container__.is_some() {
                                return Err(serde::de::Error::duplicate_field("container"));
                            }
                            container__ = map.next_value()?;
                        }
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodExecOptions {
                    stdin: stdin__,
                    stdout: stdout__,
                    stderr: stderr__,
                    tty: tty__,
                    container: container__,
                    command: command__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodExecOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodIp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ip.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodIP", len)?;
        if let Some(v) = self.ip.as_ref() {
            struct_ser.serialize_field("ip", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodIp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ip",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ip,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ip" => Ok(GeneratedField::Ip),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodIp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodIP")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodIp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ip__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ip => {
                            if ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ip"));
                            }
                            ip__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodIp {
                    ip: ip__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodIP", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodLogOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.container.is_some() {
            len += 1;
        }
        if self.follow.is_some() {
            len += 1;
        }
        if self.previous.is_some() {
            len += 1;
        }
        if self.since_seconds.is_some() {
            len += 1;
        }
        if self.since_time.is_some() {
            len += 1;
        }
        if self.timestamps.is_some() {
            len += 1;
        }
        if self.tail_lines.is_some() {
            len += 1;
        }
        if self.limit_bytes.is_some() {
            len += 1;
        }
        if self.insecure_skip_tls_verify_backend.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodLogOptions", len)?;
        if let Some(v) = self.container.as_ref() {
            struct_ser.serialize_field("container", v)?;
        }
        if let Some(v) = self.follow.as_ref() {
            struct_ser.serialize_field("follow", v)?;
        }
        if let Some(v) = self.previous.as_ref() {
            struct_ser.serialize_field("previous", v)?;
        }
        if let Some(v) = self.since_seconds.as_ref() {
            struct_ser.serialize_field("sinceSeconds", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.since_time.as_ref() {
            struct_ser.serialize_field("sinceTime", v)?;
        }
        if let Some(v) = self.timestamps.as_ref() {
            struct_ser.serialize_field("timestamps", v)?;
        }
        if let Some(v) = self.tail_lines.as_ref() {
            struct_ser.serialize_field("tailLines", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.limit_bytes.as_ref() {
            struct_ser.serialize_field("limitBytes", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.insecure_skip_tls_verify_backend.as_ref() {
            struct_ser.serialize_field("insecureSkipTLSVerifyBackend", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodLogOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "container",
            "follow",
            "previous",
            "sinceSeconds",
            "sinceTime",
            "timestamps",
            "tailLines",
            "limitBytes",
            "insecureSkipTLSVerifyBackend",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Container,
            Follow,
            Previous,
            SinceSeconds,
            SinceTime,
            Timestamps,
            TailLines,
            LimitBytes,
            InsecureSkipTlsVerifyBackend,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "container" => Ok(GeneratedField::Container),
                            "follow" => Ok(GeneratedField::Follow),
                            "previous" => Ok(GeneratedField::Previous),
                            "sinceSeconds" => Ok(GeneratedField::SinceSeconds),
                            "sinceTime" => Ok(GeneratedField::SinceTime),
                            "timestamps" => Ok(GeneratedField::Timestamps),
                            "tailLines" => Ok(GeneratedField::TailLines),
                            "limitBytes" => Ok(GeneratedField::LimitBytes),
                            "insecureSkipTLSVerifyBackend" => Ok(GeneratedField::InsecureSkipTlsVerifyBackend),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodLogOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodLogOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodLogOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut container__ = None;
                let mut follow__ = None;
                let mut previous__ = None;
                let mut since_seconds__ = None;
                let mut since_time__ = None;
                let mut timestamps__ = None;
                let mut tail_lines__ = None;
                let mut limit_bytes__ = None;
                let mut insecure_skip_tls_verify_backend__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Container => {
                            if container__.is_some() {
                                return Err(serde::de::Error::duplicate_field("container"));
                            }
                            container__ = map.next_value()?;
                        }
                        GeneratedField::Follow => {
                            if follow__.is_some() {
                                return Err(serde::de::Error::duplicate_field("follow"));
                            }
                            follow__ = map.next_value()?;
                        }
                        GeneratedField::Previous => {
                            if previous__.is_some() {
                                return Err(serde::de::Error::duplicate_field("previous"));
                            }
                            previous__ = map.next_value()?;
                        }
                        GeneratedField::SinceSeconds => {
                            if since_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sinceSeconds"));
                            }
                            since_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SinceTime => {
                            if since_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sinceTime"));
                            }
                            since_time__ = map.next_value()?;
                        }
                        GeneratedField::Timestamps => {
                            if timestamps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamps"));
                            }
                            timestamps__ = map.next_value()?;
                        }
                        GeneratedField::TailLines => {
                            if tail_lines__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tailLines"));
                            }
                            tail_lines__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LimitBytes => {
                            if limit_bytes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limitBytes"));
                            }
                            limit_bytes__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InsecureSkipTlsVerifyBackend => {
                            if insecure_skip_tls_verify_backend__.is_some() {
                                return Err(serde::de::Error::duplicate_field("insecureSkipTLSVerifyBackend"));
                            }
                            insecure_skip_tls_verify_backend__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodLogOptions {
                    container: container__,
                    follow: follow__,
                    previous: previous__,
                    since_seconds: since_seconds__,
                    since_time: since_time__,
                    timestamps: timestamps__,
                    tail_lines: tail_lines__,
                    limit_bytes: limit_bytes__,
                    insecure_skip_tls_verify_backend: insecure_skip_tls_verify_backend__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodLogOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodOs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodOS", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodOs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodOs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodOS")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodOs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodOs {
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodOS", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodPortForwardOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ports.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodPortForwardOptions", len)?;
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodPortForwardOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ports",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ports,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ports" => Ok(GeneratedField::Ports),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodPortForwardOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodPortForwardOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodPortForwardOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ports__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = 
                                Some(map.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodPortForwardOptions {
                    ports: ports__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodPortForwardOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodProxyOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodProxyOptions", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodProxyOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodProxyOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodProxyOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodProxyOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodProxyOptions {
                    path: path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodProxyOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodReadinessGate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.condition_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodReadinessGate", len)?;
        if let Some(v) = self.condition_type.as_ref() {
            struct_ser.serialize_field("conditionType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodReadinessGate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "conditionType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConditionType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "conditionType" => Ok(GeneratedField::ConditionType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodReadinessGate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodReadinessGate")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodReadinessGate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut condition_type__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ConditionType => {
                            if condition_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditionType"));
                            }
                            condition_type__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodReadinessGate {
                    condition_type: condition_type__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodReadinessGate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodResourceClaim {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.source.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodResourceClaim", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodResourceClaim {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "source",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Source,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "source" => Ok(GeneratedField::Source),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodResourceClaim;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodResourceClaim")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodResourceClaim, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut source__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodResourceClaim {
                    name: name__,
                    source: source__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodResourceClaim", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodSchedulingGate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodSchedulingGate", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodSchedulingGate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodSchedulingGate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodSchedulingGate")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodSchedulingGate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodSchedulingGate {
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodSchedulingGate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodSecurityContext {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.se_linux_options.is_some() {
            len += 1;
        }
        if self.windows_options.is_some() {
            len += 1;
        }
        if self.run_as_user.is_some() {
            len += 1;
        }
        if self.run_as_group.is_some() {
            len += 1;
        }
        if self.run_as_non_root.is_some() {
            len += 1;
        }
        if !self.supplemental_groups.is_empty() {
            len += 1;
        }
        if self.fs_group.is_some() {
            len += 1;
        }
        if !self.sysctls.is_empty() {
            len += 1;
        }
        if self.fs_group_change_policy.is_some() {
            len += 1;
        }
        if self.seccomp_profile.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodSecurityContext", len)?;
        if let Some(v) = self.se_linux_options.as_ref() {
            struct_ser.serialize_field("seLinuxOptions", v)?;
        }
        if let Some(v) = self.windows_options.as_ref() {
            struct_ser.serialize_field("windowsOptions", v)?;
        }
        if let Some(v) = self.run_as_user.as_ref() {
            struct_ser.serialize_field("runAsUser", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.run_as_group.as_ref() {
            struct_ser.serialize_field("runAsGroup", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.run_as_non_root.as_ref() {
            struct_ser.serialize_field("runAsNonRoot", v)?;
        }
        if !self.supplemental_groups.is_empty() {
            struct_ser.serialize_field("supplementalGroups", &self.supplemental_groups.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.fs_group.as_ref() {
            struct_ser.serialize_field("fsGroup", ToString::to_string(&v).as_str())?;
        }
        if !self.sysctls.is_empty() {
            struct_ser.serialize_field("sysctls", &self.sysctls)?;
        }
        if let Some(v) = self.fs_group_change_policy.as_ref() {
            struct_ser.serialize_field("fsGroupChangePolicy", v)?;
        }
        if let Some(v) = self.seccomp_profile.as_ref() {
            struct_ser.serialize_field("seccompProfile", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodSecurityContext {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "seLinuxOptions",
            "windowsOptions",
            "runAsUser",
            "runAsGroup",
            "runAsNonRoot",
            "supplementalGroups",
            "fsGroup",
            "sysctls",
            "fsGroupChangePolicy",
            "seccompProfile",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeLinuxOptions,
            WindowsOptions,
            RunAsUser,
            RunAsGroup,
            RunAsNonRoot,
            SupplementalGroups,
            FsGroup,
            Sysctls,
            FsGroupChangePolicy,
            SeccompProfile,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "seLinuxOptions" => Ok(GeneratedField::SeLinuxOptions),
                            "windowsOptions" => Ok(GeneratedField::WindowsOptions),
                            "runAsUser" => Ok(GeneratedField::RunAsUser),
                            "runAsGroup" => Ok(GeneratedField::RunAsGroup),
                            "runAsNonRoot" => Ok(GeneratedField::RunAsNonRoot),
                            "supplementalGroups" => Ok(GeneratedField::SupplementalGroups),
                            "fsGroup" => Ok(GeneratedField::FsGroup),
                            "sysctls" => Ok(GeneratedField::Sysctls),
                            "fsGroupChangePolicy" => Ok(GeneratedField::FsGroupChangePolicy),
                            "seccompProfile" => Ok(GeneratedField::SeccompProfile),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodSecurityContext;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodSecurityContext")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodSecurityContext, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut se_linux_options__ = None;
                let mut windows_options__ = None;
                let mut run_as_user__ = None;
                let mut run_as_group__ = None;
                let mut run_as_non_root__ = None;
                let mut supplemental_groups__ = None;
                let mut fs_group__ = None;
                let mut sysctls__ = None;
                let mut fs_group_change_policy__ = None;
                let mut seccomp_profile__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::SeLinuxOptions => {
                            if se_linux_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seLinuxOptions"));
                            }
                            se_linux_options__ = map.next_value()?;
                        }
                        GeneratedField::WindowsOptions => {
                            if windows_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowsOptions"));
                            }
                            windows_options__ = map.next_value()?;
                        }
                        GeneratedField::RunAsUser => {
                            if run_as_user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsUser"));
                            }
                            run_as_user__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunAsGroup => {
                            if run_as_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsGroup"));
                            }
                            run_as_group__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunAsNonRoot => {
                            if run_as_non_root__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsNonRoot"));
                            }
                            run_as_non_root__ = map.next_value()?;
                        }
                        GeneratedField::SupplementalGroups => {
                            if supplemental_groups__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supplementalGroups"));
                            }
                            supplemental_groups__ = 
                                Some(map.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::FsGroup => {
                            if fs_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsGroup"));
                            }
                            fs_group__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Sysctls => {
                            if sysctls__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sysctls"));
                            }
                            sysctls__ = Some(map.next_value()?);
                        }
                        GeneratedField::FsGroupChangePolicy => {
                            if fs_group_change_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsGroupChangePolicy"));
                            }
                            fs_group_change_policy__ = map.next_value()?;
                        }
                        GeneratedField::SeccompProfile => {
                            if seccomp_profile__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seccompProfile"));
                            }
                            seccomp_profile__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodSecurityContext {
                    se_linux_options: se_linux_options__,
                    windows_options: windows_options__,
                    run_as_user: run_as_user__,
                    run_as_group: run_as_group__,
                    run_as_non_root: run_as_non_root__,
                    supplemental_groups: supplemental_groups__.unwrap_or_default(),
                    fs_group: fs_group__,
                    sysctls: sysctls__.unwrap_or_default(),
                    fs_group_change_policy: fs_group_change_policy__,
                    seccomp_profile: seccomp_profile__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodSecurityContext", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pod_controller.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodSignature", len)?;
        if let Some(v) = self.pod_controller.as_ref() {
            struct_ser.serialize_field("podController", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "podController",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PodController,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "podController" => Ok(GeneratedField::PodController),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodSignature")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pod_controller__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PodController => {
                            if pod_controller__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podController"));
                            }
                            pod_controller__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodSignature {
                    pod_controller: pod_controller__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.volumes.is_empty() {
            len += 1;
        }
        if !self.init_containers.is_empty() {
            len += 1;
        }
        if !self.containers.is_empty() {
            len += 1;
        }
        if !self.ephemeral_containers.is_empty() {
            len += 1;
        }
        if self.restart_policy.is_some() {
            len += 1;
        }
        if self.termination_grace_period_seconds.is_some() {
            len += 1;
        }
        if self.active_deadline_seconds.is_some() {
            len += 1;
        }
        if self.dns_policy.is_some() {
            len += 1;
        }
        if !self.node_selector.is_empty() {
            len += 1;
        }
        if self.service_account_name.is_some() {
            len += 1;
        }
        if self.service_account.is_some() {
            len += 1;
        }
        if self.automount_service_account_token.is_some() {
            len += 1;
        }
        if self.node_name.is_some() {
            len += 1;
        }
        if self.host_network.is_some() {
            len += 1;
        }
        if self.host_pid.is_some() {
            len += 1;
        }
        if self.host_ipc.is_some() {
            len += 1;
        }
        if self.share_process_namespace.is_some() {
            len += 1;
        }
        if self.security_context.is_some() {
            len += 1;
        }
        if !self.image_pull_secrets.is_empty() {
            len += 1;
        }
        if self.hostname.is_some() {
            len += 1;
        }
        if self.subdomain.is_some() {
            len += 1;
        }
        if self.affinity.is_some() {
            len += 1;
        }
        if self.scheduler_name.is_some() {
            len += 1;
        }
        if !self.tolerations.is_empty() {
            len += 1;
        }
        if !self.host_aliases.is_empty() {
            len += 1;
        }
        if self.priority_class_name.is_some() {
            len += 1;
        }
        if self.priority.is_some() {
            len += 1;
        }
        if self.dns_config.is_some() {
            len += 1;
        }
        if !self.readiness_gates.is_empty() {
            len += 1;
        }
        if self.runtime_class_name.is_some() {
            len += 1;
        }
        if self.enable_service_links.is_some() {
            len += 1;
        }
        if self.preemption_policy.is_some() {
            len += 1;
        }
        if !self.overhead.is_empty() {
            len += 1;
        }
        if !self.topology_spread_constraints.is_empty() {
            len += 1;
        }
        if self.set_hostname_as_fqdn.is_some() {
            len += 1;
        }
        if self.os.is_some() {
            len += 1;
        }
        if self.host_users.is_some() {
            len += 1;
        }
        if !self.scheduling_gates.is_empty() {
            len += 1;
        }
        if !self.resource_claims.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodSpec", len)?;
        if !self.volumes.is_empty() {
            struct_ser.serialize_field("volumes", &self.volumes)?;
        }
        if !self.init_containers.is_empty() {
            struct_ser.serialize_field("initContainers", &self.init_containers)?;
        }
        if !self.containers.is_empty() {
            struct_ser.serialize_field("containers", &self.containers)?;
        }
        if !self.ephemeral_containers.is_empty() {
            struct_ser.serialize_field("ephemeralContainers", &self.ephemeral_containers)?;
        }
        if let Some(v) = self.restart_policy.as_ref() {
            struct_ser.serialize_field("restartPolicy", v)?;
        }
        if let Some(v) = self.termination_grace_period_seconds.as_ref() {
            struct_ser.serialize_field("terminationGracePeriodSeconds", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.active_deadline_seconds.as_ref() {
            struct_ser.serialize_field("activeDeadlineSeconds", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.dns_policy.as_ref() {
            struct_ser.serialize_field("dnsPolicy", v)?;
        }
        if !self.node_selector.is_empty() {
            struct_ser.serialize_field("nodeSelector", &self.node_selector)?;
        }
        if let Some(v) = self.service_account_name.as_ref() {
            struct_ser.serialize_field("serviceAccountName", v)?;
        }
        if let Some(v) = self.service_account.as_ref() {
            struct_ser.serialize_field("serviceAccount", v)?;
        }
        if let Some(v) = self.automount_service_account_token.as_ref() {
            struct_ser.serialize_field("automountServiceAccountToken", v)?;
        }
        if let Some(v) = self.node_name.as_ref() {
            struct_ser.serialize_field("nodeName", v)?;
        }
        if let Some(v) = self.host_network.as_ref() {
            struct_ser.serialize_field("hostNetwork", v)?;
        }
        if let Some(v) = self.host_pid.as_ref() {
            struct_ser.serialize_field("hostPID", v)?;
        }
        if let Some(v) = self.host_ipc.as_ref() {
            struct_ser.serialize_field("hostIPC", v)?;
        }
        if let Some(v) = self.share_process_namespace.as_ref() {
            struct_ser.serialize_field("shareProcessNamespace", v)?;
        }
        if let Some(v) = self.security_context.as_ref() {
            struct_ser.serialize_field("securityContext", v)?;
        }
        if !self.image_pull_secrets.is_empty() {
            struct_ser.serialize_field("imagePullSecrets", &self.image_pull_secrets)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            struct_ser.serialize_field("hostname", v)?;
        }
        if let Some(v) = self.subdomain.as_ref() {
            struct_ser.serialize_field("subdomain", v)?;
        }
        if let Some(v) = self.affinity.as_ref() {
            struct_ser.serialize_field("affinity", v)?;
        }
        if let Some(v) = self.scheduler_name.as_ref() {
            struct_ser.serialize_field("schedulerName", v)?;
        }
        if !self.tolerations.is_empty() {
            struct_ser.serialize_field("tolerations", &self.tolerations)?;
        }
        if !self.host_aliases.is_empty() {
            struct_ser.serialize_field("hostAliases", &self.host_aliases)?;
        }
        if let Some(v) = self.priority_class_name.as_ref() {
            struct_ser.serialize_field("priorityClassName", v)?;
        }
        if let Some(v) = self.priority.as_ref() {
            struct_ser.serialize_field("priority", v)?;
        }
        if let Some(v) = self.dns_config.as_ref() {
            struct_ser.serialize_field("dnsConfig", v)?;
        }
        if !self.readiness_gates.is_empty() {
            struct_ser.serialize_field("readinessGates", &self.readiness_gates)?;
        }
        if let Some(v) = self.runtime_class_name.as_ref() {
            struct_ser.serialize_field("runtimeClassName", v)?;
        }
        if let Some(v) = self.enable_service_links.as_ref() {
            struct_ser.serialize_field("enableServiceLinks", v)?;
        }
        if let Some(v) = self.preemption_policy.as_ref() {
            struct_ser.serialize_field("preemptionPolicy", v)?;
        }
        if !self.overhead.is_empty() {
            struct_ser.serialize_field("overhead", &self.overhead)?;
        }
        if !self.topology_spread_constraints.is_empty() {
            struct_ser.serialize_field("topologySpreadConstraints", &self.topology_spread_constraints)?;
        }
        if let Some(v) = self.set_hostname_as_fqdn.as_ref() {
            struct_ser.serialize_field("setHostnameAsFQDN", v)?;
        }
        if let Some(v) = self.os.as_ref() {
            struct_ser.serialize_field("os", v)?;
        }
        if let Some(v) = self.host_users.as_ref() {
            struct_ser.serialize_field("hostUsers", v)?;
        }
        if !self.scheduling_gates.is_empty() {
            struct_ser.serialize_field("schedulingGates", &self.scheduling_gates)?;
        }
        if !self.resource_claims.is_empty() {
            struct_ser.serialize_field("resourceClaims", &self.resource_claims)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumes",
            "initContainers",
            "containers",
            "ephemeralContainers",
            "restartPolicy",
            "terminationGracePeriodSeconds",
            "activeDeadlineSeconds",
            "dnsPolicy",
            "nodeSelector",
            "serviceAccountName",
            "serviceAccount",
            "automountServiceAccountToken",
            "nodeName",
            "hostNetwork",
            "hostPID",
            "hostIPC",
            "shareProcessNamespace",
            "securityContext",
            "imagePullSecrets",
            "hostname",
            "subdomain",
            "affinity",
            "schedulerName",
            "tolerations",
            "hostAliases",
            "priorityClassName",
            "priority",
            "dnsConfig",
            "readinessGates",
            "runtimeClassName",
            "enableServiceLinks",
            "preemptionPolicy",
            "overhead",
            "topologySpreadConstraints",
            "setHostnameAsFQDN",
            "os",
            "hostUsers",
            "schedulingGates",
            "resourceClaims",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Volumes,
            InitContainers,
            Containers,
            EphemeralContainers,
            RestartPolicy,
            TerminationGracePeriodSeconds,
            ActiveDeadlineSeconds,
            DnsPolicy,
            NodeSelector,
            ServiceAccountName,
            ServiceAccount,
            AutomountServiceAccountToken,
            NodeName,
            HostNetwork,
            HostPid,
            HostIpc,
            ShareProcessNamespace,
            SecurityContext,
            ImagePullSecrets,
            Hostname,
            Subdomain,
            Affinity,
            SchedulerName,
            Tolerations,
            HostAliases,
            PriorityClassName,
            Priority,
            DnsConfig,
            ReadinessGates,
            RuntimeClassName,
            EnableServiceLinks,
            PreemptionPolicy,
            Overhead,
            TopologySpreadConstraints,
            SetHostnameAsFqdn,
            Os,
            HostUsers,
            SchedulingGates,
            ResourceClaims,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumes" => Ok(GeneratedField::Volumes),
                            "initContainers" => Ok(GeneratedField::InitContainers),
                            "containers" => Ok(GeneratedField::Containers),
                            "ephemeralContainers" => Ok(GeneratedField::EphemeralContainers),
                            "restartPolicy" => Ok(GeneratedField::RestartPolicy),
                            "terminationGracePeriodSeconds" => Ok(GeneratedField::TerminationGracePeriodSeconds),
                            "activeDeadlineSeconds" => Ok(GeneratedField::ActiveDeadlineSeconds),
                            "dnsPolicy" => Ok(GeneratedField::DnsPolicy),
                            "nodeSelector" => Ok(GeneratedField::NodeSelector),
                            "serviceAccountName" => Ok(GeneratedField::ServiceAccountName),
                            "serviceAccount" => Ok(GeneratedField::ServiceAccount),
                            "automountServiceAccountToken" => Ok(GeneratedField::AutomountServiceAccountToken),
                            "nodeName" => Ok(GeneratedField::NodeName),
                            "hostNetwork" => Ok(GeneratedField::HostNetwork),
                            "hostPID" => Ok(GeneratedField::HostPid),
                            "hostIPC" => Ok(GeneratedField::HostIpc),
                            "shareProcessNamespace" => Ok(GeneratedField::ShareProcessNamespace),
                            "securityContext" => Ok(GeneratedField::SecurityContext),
                            "imagePullSecrets" => Ok(GeneratedField::ImagePullSecrets),
                            "hostname" => Ok(GeneratedField::Hostname),
                            "subdomain" => Ok(GeneratedField::Subdomain),
                            "affinity" => Ok(GeneratedField::Affinity),
                            "schedulerName" => Ok(GeneratedField::SchedulerName),
                            "tolerations" => Ok(GeneratedField::Tolerations),
                            "hostAliases" => Ok(GeneratedField::HostAliases),
                            "priorityClassName" => Ok(GeneratedField::PriorityClassName),
                            "priority" => Ok(GeneratedField::Priority),
                            "dnsConfig" => Ok(GeneratedField::DnsConfig),
                            "readinessGates" => Ok(GeneratedField::ReadinessGates),
                            "runtimeClassName" => Ok(GeneratedField::RuntimeClassName),
                            "enableServiceLinks" => Ok(GeneratedField::EnableServiceLinks),
                            "preemptionPolicy" => Ok(GeneratedField::PreemptionPolicy),
                            "overhead" => Ok(GeneratedField::Overhead),
                            "topologySpreadConstraints" => Ok(GeneratedField::TopologySpreadConstraints),
                            "setHostnameAsFQDN" => Ok(GeneratedField::SetHostnameAsFqdn),
                            "os" => Ok(GeneratedField::Os),
                            "hostUsers" => Ok(GeneratedField::HostUsers),
                            "schedulingGates" => Ok(GeneratedField::SchedulingGates),
                            "resourceClaims" => Ok(GeneratedField::ResourceClaims),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volumes__ = None;
                let mut init_containers__ = None;
                let mut containers__ = None;
                let mut ephemeral_containers__ = None;
                let mut restart_policy__ = None;
                let mut termination_grace_period_seconds__ = None;
                let mut active_deadline_seconds__ = None;
                let mut dns_policy__ = None;
                let mut node_selector__ = None;
                let mut service_account_name__ = None;
                let mut service_account__ = None;
                let mut automount_service_account_token__ = None;
                let mut node_name__ = None;
                let mut host_network__ = None;
                let mut host_pid__ = None;
                let mut host_ipc__ = None;
                let mut share_process_namespace__ = None;
                let mut security_context__ = None;
                let mut image_pull_secrets__ = None;
                let mut hostname__ = None;
                let mut subdomain__ = None;
                let mut affinity__ = None;
                let mut scheduler_name__ = None;
                let mut tolerations__ = None;
                let mut host_aliases__ = None;
                let mut priority_class_name__ = None;
                let mut priority__ = None;
                let mut dns_config__ = None;
                let mut readiness_gates__ = None;
                let mut runtime_class_name__ = None;
                let mut enable_service_links__ = None;
                let mut preemption_policy__ = None;
                let mut overhead__ = None;
                let mut topology_spread_constraints__ = None;
                let mut set_hostname_as_fqdn__ = None;
                let mut os__ = None;
                let mut host_users__ = None;
                let mut scheduling_gates__ = None;
                let mut resource_claims__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Volumes => {
                            if volumes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumes"));
                            }
                            volumes__ = Some(map.next_value()?);
                        }
                        GeneratedField::InitContainers => {
                            if init_containers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initContainers"));
                            }
                            init_containers__ = Some(map.next_value()?);
                        }
                        GeneratedField::Containers => {
                            if containers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containers"));
                            }
                            containers__ = Some(map.next_value()?);
                        }
                        GeneratedField::EphemeralContainers => {
                            if ephemeral_containers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ephemeralContainers"));
                            }
                            ephemeral_containers__ = Some(map.next_value()?);
                        }
                        GeneratedField::RestartPolicy => {
                            if restart_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("restartPolicy"));
                            }
                            restart_policy__ = map.next_value()?;
                        }
                        GeneratedField::TerminationGracePeriodSeconds => {
                            if termination_grace_period_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationGracePeriodSeconds"));
                            }
                            termination_grace_period_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActiveDeadlineSeconds => {
                            if active_deadline_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activeDeadlineSeconds"));
                            }
                            active_deadline_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DnsPolicy => {
                            if dns_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dnsPolicy"));
                            }
                            dns_policy__ = map.next_value()?;
                        }
                        GeneratedField::NodeSelector => {
                            if node_selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeSelector"));
                            }
                            node_selector__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::ServiceAccountName => {
                            if service_account_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serviceAccountName"));
                            }
                            service_account_name__ = map.next_value()?;
                        }
                        GeneratedField::ServiceAccount => {
                            if service_account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serviceAccount"));
                            }
                            service_account__ = map.next_value()?;
                        }
                        GeneratedField::AutomountServiceAccountToken => {
                            if automount_service_account_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("automountServiceAccountToken"));
                            }
                            automount_service_account_token__ = map.next_value()?;
                        }
                        GeneratedField::NodeName => {
                            if node_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeName"));
                            }
                            node_name__ = map.next_value()?;
                        }
                        GeneratedField::HostNetwork => {
                            if host_network__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostNetwork"));
                            }
                            host_network__ = map.next_value()?;
                        }
                        GeneratedField::HostPid => {
                            if host_pid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostPID"));
                            }
                            host_pid__ = map.next_value()?;
                        }
                        GeneratedField::HostIpc => {
                            if host_ipc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostIPC"));
                            }
                            host_ipc__ = map.next_value()?;
                        }
                        GeneratedField::ShareProcessNamespace => {
                            if share_process_namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shareProcessNamespace"));
                            }
                            share_process_namespace__ = map.next_value()?;
                        }
                        GeneratedField::SecurityContext => {
                            if security_context__.is_some() {
                                return Err(serde::de::Error::duplicate_field("securityContext"));
                            }
                            security_context__ = map.next_value()?;
                        }
                        GeneratedField::ImagePullSecrets => {
                            if image_pull_secrets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imagePullSecrets"));
                            }
                            image_pull_secrets__ = Some(map.next_value()?);
                        }
                        GeneratedField::Hostname => {
                            if hostname__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostname"));
                            }
                            hostname__ = map.next_value()?;
                        }
                        GeneratedField::Subdomain => {
                            if subdomain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subdomain"));
                            }
                            subdomain__ = map.next_value()?;
                        }
                        GeneratedField::Affinity => {
                            if affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("affinity"));
                            }
                            affinity__ = map.next_value()?;
                        }
                        GeneratedField::SchedulerName => {
                            if scheduler_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schedulerName"));
                            }
                            scheduler_name__ = map.next_value()?;
                        }
                        GeneratedField::Tolerations => {
                            if tolerations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tolerations"));
                            }
                            tolerations__ = Some(map.next_value()?);
                        }
                        GeneratedField::HostAliases => {
                            if host_aliases__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostAliases"));
                            }
                            host_aliases__ = Some(map.next_value()?);
                        }
                        GeneratedField::PriorityClassName => {
                            if priority_class_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("priorityClassName"));
                            }
                            priority_class_name__ = map.next_value()?;
                        }
                        GeneratedField::Priority => {
                            if priority__.is_some() {
                                return Err(serde::de::Error::duplicate_field("priority"));
                            }
                            priority__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DnsConfig => {
                            if dns_config__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dnsConfig"));
                            }
                            dns_config__ = map.next_value()?;
                        }
                        GeneratedField::ReadinessGates => {
                            if readiness_gates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readinessGates"));
                            }
                            readiness_gates__ = Some(map.next_value()?);
                        }
                        GeneratedField::RuntimeClassName => {
                            if runtime_class_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runtimeClassName"));
                            }
                            runtime_class_name__ = map.next_value()?;
                        }
                        GeneratedField::EnableServiceLinks => {
                            if enable_service_links__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enableServiceLinks"));
                            }
                            enable_service_links__ = map.next_value()?;
                        }
                        GeneratedField::PreemptionPolicy => {
                            if preemption_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preemptionPolicy"));
                            }
                            preemption_policy__ = map.next_value()?;
                        }
                        GeneratedField::Overhead => {
                            if overhead__.is_some() {
                                return Err(serde::de::Error::duplicate_field("overhead"));
                            }
                            overhead__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::TopologySpreadConstraints => {
                            if topology_spread_constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("topologySpreadConstraints"));
                            }
                            topology_spread_constraints__ = Some(map.next_value()?);
                        }
                        GeneratedField::SetHostnameAsFqdn => {
                            if set_hostname_as_fqdn__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setHostnameAsFQDN"));
                            }
                            set_hostname_as_fqdn__ = map.next_value()?;
                        }
                        GeneratedField::Os => {
                            if os__.is_some() {
                                return Err(serde::de::Error::duplicate_field("os"));
                            }
                            os__ = map.next_value()?;
                        }
                        GeneratedField::HostUsers => {
                            if host_users__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostUsers"));
                            }
                            host_users__ = map.next_value()?;
                        }
                        GeneratedField::SchedulingGates => {
                            if scheduling_gates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("schedulingGates"));
                            }
                            scheduling_gates__ = Some(map.next_value()?);
                        }
                        GeneratedField::ResourceClaims => {
                            if resource_claims__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resourceClaims"));
                            }
                            resource_claims__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodSpec {
                    volumes: volumes__.unwrap_or_default(),
                    init_containers: init_containers__.unwrap_or_default(),
                    containers: containers__.unwrap_or_default(),
                    ephemeral_containers: ephemeral_containers__.unwrap_or_default(),
                    restart_policy: restart_policy__,
                    termination_grace_period_seconds: termination_grace_period_seconds__,
                    active_deadline_seconds: active_deadline_seconds__,
                    dns_policy: dns_policy__,
                    node_selector: node_selector__.unwrap_or_default(),
                    service_account_name: service_account_name__,
                    service_account: service_account__,
                    automount_service_account_token: automount_service_account_token__,
                    node_name: node_name__,
                    host_network: host_network__,
                    host_pid: host_pid__,
                    host_ipc: host_ipc__,
                    share_process_namespace: share_process_namespace__,
                    security_context: security_context__,
                    image_pull_secrets: image_pull_secrets__.unwrap_or_default(),
                    hostname: hostname__,
                    subdomain: subdomain__,
                    affinity: affinity__,
                    scheduler_name: scheduler_name__,
                    tolerations: tolerations__.unwrap_or_default(),
                    host_aliases: host_aliases__.unwrap_or_default(),
                    priority_class_name: priority_class_name__,
                    priority: priority__,
                    dns_config: dns_config__,
                    readiness_gates: readiness_gates__.unwrap_or_default(),
                    runtime_class_name: runtime_class_name__,
                    enable_service_links: enable_service_links__,
                    preemption_policy: preemption_policy__,
                    overhead: overhead__.unwrap_or_default(),
                    topology_spread_constraints: topology_spread_constraints__.unwrap_or_default(),
                    set_hostname_as_fqdn: set_hostname_as_fqdn__,
                    os: os__,
                    host_users: host_users__,
                    scheduling_gates: scheduling_gates__.unwrap_or_default(),
                    resource_claims: resource_claims__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.phase.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.nominated_node_name.is_some() {
            len += 1;
        }
        if self.host_ip.is_some() {
            len += 1;
        }
        if self.pod_ip.is_some() {
            len += 1;
        }
        if !self.pod_i_ps.is_empty() {
            len += 1;
        }
        if self.start_time.is_some() {
            len += 1;
        }
        if !self.init_container_statuses.is_empty() {
            len += 1;
        }
        if !self.container_statuses.is_empty() {
            len += 1;
        }
        if self.qos_class.is_some() {
            len += 1;
        }
        if !self.ephemeral_container_statuses.is_empty() {
            len += 1;
        }
        if self.resize.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodStatus", len)?;
        if let Some(v) = self.phase.as_ref() {
            struct_ser.serialize_field("phase", v)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.nominated_node_name.as_ref() {
            struct_ser.serialize_field("nominatedNodeName", v)?;
        }
        if let Some(v) = self.host_ip.as_ref() {
            struct_ser.serialize_field("hostIP", v)?;
        }
        if let Some(v) = self.pod_ip.as_ref() {
            struct_ser.serialize_field("podIP", v)?;
        }
        if !self.pod_i_ps.is_empty() {
            struct_ser.serialize_field("podIPs", &self.pod_i_ps)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("startTime", v)?;
        }
        if !self.init_container_statuses.is_empty() {
            struct_ser.serialize_field("initContainerStatuses", &self.init_container_statuses)?;
        }
        if !self.container_statuses.is_empty() {
            struct_ser.serialize_field("containerStatuses", &self.container_statuses)?;
        }
        if let Some(v) = self.qos_class.as_ref() {
            struct_ser.serialize_field("qosClass", v)?;
        }
        if !self.ephemeral_container_statuses.is_empty() {
            struct_ser.serialize_field("ephemeralContainerStatuses", &self.ephemeral_container_statuses)?;
        }
        if let Some(v) = self.resize.as_ref() {
            struct_ser.serialize_field("resize", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "phase",
            "conditions",
            "message",
            "reason",
            "nominatedNodeName",
            "hostIP",
            "podIP",
            "podIPs",
            "startTime",
            "initContainerStatuses",
            "containerStatuses",
            "qosClass",
            "ephemeralContainerStatuses",
            "resize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Phase,
            Conditions,
            Message,
            Reason,
            NominatedNodeName,
            HostIp,
            PodIp,
            PodIPs,
            StartTime,
            InitContainerStatuses,
            ContainerStatuses,
            QosClass,
            EphemeralContainerStatuses,
            Resize,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "phase" => Ok(GeneratedField::Phase),
                            "conditions" => Ok(GeneratedField::Conditions),
                            "message" => Ok(GeneratedField::Message),
                            "reason" => Ok(GeneratedField::Reason),
                            "nominatedNodeName" => Ok(GeneratedField::NominatedNodeName),
                            "hostIP" => Ok(GeneratedField::HostIp),
                            "podIP" => Ok(GeneratedField::PodIp),
                            "podIPs" => Ok(GeneratedField::PodIPs),
                            "startTime" => Ok(GeneratedField::StartTime),
                            "initContainerStatuses" => Ok(GeneratedField::InitContainerStatuses),
                            "containerStatuses" => Ok(GeneratedField::ContainerStatuses),
                            "qosClass" => Ok(GeneratedField::QosClass),
                            "ephemeralContainerStatuses" => Ok(GeneratedField::EphemeralContainerStatuses),
                            "resize" => Ok(GeneratedField::Resize),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut phase__ = None;
                let mut conditions__ = None;
                let mut message__ = None;
                let mut reason__ = None;
                let mut nominated_node_name__ = None;
                let mut host_ip__ = None;
                let mut pod_ip__ = None;
                let mut pod_i_ps__ = None;
                let mut start_time__ = None;
                let mut init_container_statuses__ = None;
                let mut container_statuses__ = None;
                let mut qos_class__ = None;
                let mut ephemeral_container_statuses__ = None;
                let mut resize__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Phase => {
                            if phase__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phase"));
                            }
                            phase__ = map.next_value()?;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::NominatedNodeName => {
                            if nominated_node_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nominatedNodeName"));
                            }
                            nominated_node_name__ = map.next_value()?;
                        }
                        GeneratedField::HostIp => {
                            if host_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostIP"));
                            }
                            host_ip__ = map.next_value()?;
                        }
                        GeneratedField::PodIp => {
                            if pod_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podIP"));
                            }
                            pod_ip__ = map.next_value()?;
                        }
                        GeneratedField::PodIPs => {
                            if pod_i_ps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podIPs"));
                            }
                            pod_i_ps__ = Some(map.next_value()?);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map.next_value()?;
                        }
                        GeneratedField::InitContainerStatuses => {
                            if init_container_statuses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initContainerStatuses"));
                            }
                            init_container_statuses__ = Some(map.next_value()?);
                        }
                        GeneratedField::ContainerStatuses => {
                            if container_statuses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerStatuses"));
                            }
                            container_statuses__ = Some(map.next_value()?);
                        }
                        GeneratedField::QosClass => {
                            if qos_class__.is_some() {
                                return Err(serde::de::Error::duplicate_field("qosClass"));
                            }
                            qos_class__ = map.next_value()?;
                        }
                        GeneratedField::EphemeralContainerStatuses => {
                            if ephemeral_container_statuses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ephemeralContainerStatuses"));
                            }
                            ephemeral_container_statuses__ = Some(map.next_value()?);
                        }
                        GeneratedField::Resize => {
                            if resize__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resize"));
                            }
                            resize__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodStatus {
                    phase: phase__,
                    conditions: conditions__.unwrap_or_default(),
                    message: message__,
                    reason: reason__,
                    nominated_node_name: nominated_node_name__,
                    host_ip: host_ip__,
                    pod_ip: pod_ip__,
                    pod_i_ps: pod_i_ps__.unwrap_or_default(),
                    start_time: start_time__,
                    init_container_statuses: init_container_statuses__.unwrap_or_default(),
                    container_statuses: container_statuses__.unwrap_or_default(),
                    qos_class: qos_class__,
                    ephemeral_container_statuses: ephemeral_container_statuses__.unwrap_or_default(),
                    resize: resize__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodStatusResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodStatusResult", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodStatusResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodStatusResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodStatusResult")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodStatusResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodStatusResult {
                    metadata: metadata__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodStatusResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodTemplate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.template.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodTemplate", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.template.as_ref() {
            struct_ser.serialize_field("template", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodTemplate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "template",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Template,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "template" => Ok(GeneratedField::Template),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodTemplate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodTemplate")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodTemplate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut template__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Template => {
                            if template__.is_some() {
                                return Err(serde::de::Error::duplicate_field("template"));
                            }
                            template__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodTemplate {
                    metadata: metadata__,
                    template: template__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodTemplate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodTemplateList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodTemplateList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodTemplateList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodTemplateList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodTemplateList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodTemplateList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodTemplateList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodTemplateList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PodTemplateSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PodTemplateSpec", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PodTemplateSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PodTemplateSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PodTemplateSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PodTemplateSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PodTemplateSpec {
                    metadata: metadata__,
                    spec: spec__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PodTemplateSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PortStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.port.is_some() {
            len += 1;
        }
        if self.protocol.is_some() {
            len += 1;
        }
        if self.error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PortStatus", len)?;
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            struct_ser.serialize_field("protocol", v)?;
        }
        if let Some(v) = self.error.as_ref() {
            struct_ser.serialize_field("error", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PortStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "port",
            "protocol",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Port,
            Protocol,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "port" => Ok(GeneratedField::Port),
                            "protocol" => Ok(GeneratedField::Protocol),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PortStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PortStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PortStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut port__ = None;
                let mut protocol__ = None;
                let mut error__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Protocol => {
                            if protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocol"));
                            }
                            protocol__ = map.next_value()?;
                        }
                        GeneratedField::Error => {
                            if error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            error__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PortStatus {
                    port: port__,
                    protocol: protocol__,
                    error: error__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PortStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PortworxVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_id.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PortworxVolumeSource", len)?;
        if let Some(v) = self.volume_id.as_ref() {
            struct_ser.serialize_field("volumeID", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PortworxVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeID",
            "fsType",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeId,
            FsType,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeID" => Ok(GeneratedField::VolumeId),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PortworxVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PortworxVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PortworxVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_id__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeId => {
                            if volume_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeID"));
                            }
                            volume_id__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PortworxVolumeSource {
                    volume_id: volume_id__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PortworxVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Preconditions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Preconditions", len)?;
        if let Some(v) = self.uid.as_ref() {
            struct_ser.serialize_field("uid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Preconditions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "uid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uid,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "uid" => Ok(GeneratedField::Uid),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Preconditions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Preconditions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Preconditions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uid__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Preconditions {
                    uid: uid__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Preconditions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PreferAvoidPodsEntry {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pod_signature.is_some() {
            len += 1;
        }
        if self.eviction_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PreferAvoidPodsEntry", len)?;
        if let Some(v) = self.pod_signature.as_ref() {
            struct_ser.serialize_field("podSignature", v)?;
        }
        if let Some(v) = self.eviction_time.as_ref() {
            struct_ser.serialize_field("evictionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PreferAvoidPodsEntry {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "podSignature",
            "evictionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PodSignature,
            EvictionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "podSignature" => Ok(GeneratedField::PodSignature),
                            "evictionTime" => Ok(GeneratedField::EvictionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PreferAvoidPodsEntry;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PreferAvoidPodsEntry")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PreferAvoidPodsEntry, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pod_signature__ = None;
                let mut eviction_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::PodSignature => {
                            if pod_signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podSignature"));
                            }
                            pod_signature__ = map.next_value()?;
                        }
                        GeneratedField::EvictionTime => {
                            if eviction_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("evictionTime"));
                            }
                            eviction_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PreferAvoidPodsEntry {
                    pod_signature: pod_signature__,
                    eviction_time: eviction_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PreferAvoidPodsEntry", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PreferredSchedulingTerm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.weight.is_some() {
            len += 1;
        }
        if self.preference.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.PreferredSchedulingTerm", len)?;
        if let Some(v) = self.weight.as_ref() {
            struct_ser.serialize_field("weight", v)?;
        }
        if let Some(v) = self.preference.as_ref() {
            struct_ser.serialize_field("preference", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PreferredSchedulingTerm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "weight",
            "preference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Weight,
            Preference,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "weight" => Ok(GeneratedField::Weight),
                            "preference" => Ok(GeneratedField::Preference),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PreferredSchedulingTerm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.PreferredSchedulingTerm")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<PreferredSchedulingTerm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut weight__ = None;
                let mut preference__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Preference => {
                            if preference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preference"));
                            }
                            preference__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PreferredSchedulingTerm {
                    weight: weight__,
                    preference: preference__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.PreferredSchedulingTerm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Probe {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.handler.is_some() {
            len += 1;
        }
        if self.initial_delay_seconds.is_some() {
            len += 1;
        }
        if self.timeout_seconds.is_some() {
            len += 1;
        }
        if self.period_seconds.is_some() {
            len += 1;
        }
        if self.success_threshold.is_some() {
            len += 1;
        }
        if self.failure_threshold.is_some() {
            len += 1;
        }
        if self.termination_grace_period_seconds.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Probe", len)?;
        if let Some(v) = self.handler.as_ref() {
            struct_ser.serialize_field("handler", v)?;
        }
        if let Some(v) = self.initial_delay_seconds.as_ref() {
            struct_ser.serialize_field("initialDelaySeconds", v)?;
        }
        if let Some(v) = self.timeout_seconds.as_ref() {
            struct_ser.serialize_field("timeoutSeconds", v)?;
        }
        if let Some(v) = self.period_seconds.as_ref() {
            struct_ser.serialize_field("periodSeconds", v)?;
        }
        if let Some(v) = self.success_threshold.as_ref() {
            struct_ser.serialize_field("successThreshold", v)?;
        }
        if let Some(v) = self.failure_threshold.as_ref() {
            struct_ser.serialize_field("failureThreshold", v)?;
        }
        if let Some(v) = self.termination_grace_period_seconds.as_ref() {
            struct_ser.serialize_field("terminationGracePeriodSeconds", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Probe {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "handler",
            "initialDelaySeconds",
            "timeoutSeconds",
            "periodSeconds",
            "successThreshold",
            "failureThreshold",
            "terminationGracePeriodSeconds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Handler,
            InitialDelaySeconds,
            TimeoutSeconds,
            PeriodSeconds,
            SuccessThreshold,
            FailureThreshold,
            TerminationGracePeriodSeconds,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "handler" => Ok(GeneratedField::Handler),
                            "initialDelaySeconds" => Ok(GeneratedField::InitialDelaySeconds),
                            "timeoutSeconds" => Ok(GeneratedField::TimeoutSeconds),
                            "periodSeconds" => Ok(GeneratedField::PeriodSeconds),
                            "successThreshold" => Ok(GeneratedField::SuccessThreshold),
                            "failureThreshold" => Ok(GeneratedField::FailureThreshold),
                            "terminationGracePeriodSeconds" => Ok(GeneratedField::TerminationGracePeriodSeconds),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Probe;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Probe")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Probe, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut handler__ = None;
                let mut initial_delay_seconds__ = None;
                let mut timeout_seconds__ = None;
                let mut period_seconds__ = None;
                let mut success_threshold__ = None;
                let mut failure_threshold__ = None;
                let mut termination_grace_period_seconds__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Handler => {
                            if handler__.is_some() {
                                return Err(serde::de::Error::duplicate_field("handler"));
                            }
                            handler__ = map.next_value()?;
                        }
                        GeneratedField::InitialDelaySeconds => {
                            if initial_delay_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initialDelaySeconds"));
                            }
                            initial_delay_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TimeoutSeconds => {
                            if timeout_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timeoutSeconds"));
                            }
                            timeout_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PeriodSeconds => {
                            if period_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("periodSeconds"));
                            }
                            period_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SuccessThreshold => {
                            if success_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("successThreshold"));
                            }
                            success_threshold__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FailureThreshold => {
                            if failure_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("failureThreshold"));
                            }
                            failure_threshold__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TerminationGracePeriodSeconds => {
                            if termination_grace_period_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("terminationGracePeriodSeconds"));
                            }
                            termination_grace_period_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Probe {
                    handler: handler__,
                    initial_delay_seconds: initial_delay_seconds__,
                    timeout_seconds: timeout_seconds__,
                    period_seconds: period_seconds__,
                    success_threshold: success_threshold__,
                    failure_threshold: failure_threshold__,
                    termination_grace_period_seconds: termination_grace_period_seconds__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Probe", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProbeHandler {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.exec.is_some() {
            len += 1;
        }
        if self.http_get.is_some() {
            len += 1;
        }
        if self.tcp_socket.is_some() {
            len += 1;
        }
        if self.grpc.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ProbeHandler", len)?;
        if let Some(v) = self.exec.as_ref() {
            struct_ser.serialize_field("exec", v)?;
        }
        if let Some(v) = self.http_get.as_ref() {
            struct_ser.serialize_field("httpGet", v)?;
        }
        if let Some(v) = self.tcp_socket.as_ref() {
            struct_ser.serialize_field("tcpSocket", v)?;
        }
        if let Some(v) = self.grpc.as_ref() {
            struct_ser.serialize_field("grpc", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProbeHandler {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "exec",
            "httpGet",
            "tcpSocket",
            "grpc",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Exec,
            HttpGet,
            TcpSocket,
            Grpc,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "exec" => Ok(GeneratedField::Exec),
                            "httpGet" => Ok(GeneratedField::HttpGet),
                            "tcpSocket" => Ok(GeneratedField::TcpSocket),
                            "grpc" => Ok(GeneratedField::Grpc),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProbeHandler;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ProbeHandler")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ProbeHandler, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exec__ = None;
                let mut http_get__ = None;
                let mut tcp_socket__ = None;
                let mut grpc__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Exec => {
                            if exec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exec"));
                            }
                            exec__ = map.next_value()?;
                        }
                        GeneratedField::HttpGet => {
                            if http_get__.is_some() {
                                return Err(serde::de::Error::duplicate_field("httpGet"));
                            }
                            http_get__ = map.next_value()?;
                        }
                        GeneratedField::TcpSocket => {
                            if tcp_socket__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tcpSocket"));
                            }
                            tcp_socket__ = map.next_value()?;
                        }
                        GeneratedField::Grpc => {
                            if grpc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grpc"));
                            }
                            grpc__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ProbeHandler {
                    exec: exec__,
                    http_get: http_get__,
                    tcp_socket: tcp_socket__,
                    grpc: grpc__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ProbeHandler", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectedVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sources.is_empty() {
            len += 1;
        }
        if self.default_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ProjectedVolumeSource", len)?;
        if !self.sources.is_empty() {
            struct_ser.serialize_field("sources", &self.sources)?;
        }
        if let Some(v) = self.default_mode.as_ref() {
            struct_ser.serialize_field("defaultMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectedVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sources",
            "defaultMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sources,
            DefaultMode,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sources" => Ok(GeneratedField::Sources),
                            "defaultMode" => Ok(GeneratedField::DefaultMode),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectedVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ProjectedVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ProjectedVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sources__ = None;
                let mut default_mode__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Sources => {
                            if sources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sources"));
                            }
                            sources__ = Some(map.next_value()?);
                        }
                        GeneratedField::DefaultMode => {
                            if default_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultMode"));
                            }
                            default_mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ProjectedVolumeSource {
                    sources: sources__.unwrap_or_default(),
                    default_mode: default_mode__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ProjectedVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for QuobyteVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.registry.is_some() {
            len += 1;
        }
        if self.volume.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.user.is_some() {
            len += 1;
        }
        if self.group.is_some() {
            len += 1;
        }
        if self.tenant.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.QuobyteVolumeSource", len)?;
        if let Some(v) = self.registry.as_ref() {
            struct_ser.serialize_field("registry", v)?;
        }
        if let Some(v) = self.volume.as_ref() {
            struct_ser.serialize_field("volume", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.group.as_ref() {
            struct_ser.serialize_field("group", v)?;
        }
        if let Some(v) = self.tenant.as_ref() {
            struct_ser.serialize_field("tenant", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for QuobyteVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "registry",
            "volume",
            "readOnly",
            "user",
            "group",
            "tenant",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Registry,
            Volume,
            ReadOnly,
            User,
            Group,
            Tenant,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "registry" => Ok(GeneratedField::Registry),
                            "volume" => Ok(GeneratedField::Volume),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "user" => Ok(GeneratedField::User),
                            "group" => Ok(GeneratedField::Group),
                            "tenant" => Ok(GeneratedField::Tenant),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuobyteVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.QuobyteVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<QuobyteVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut registry__ = None;
                let mut volume__ = None;
                let mut read_only__ = None;
                let mut user__ = None;
                let mut group__ = None;
                let mut tenant__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Registry => {
                            if registry__.is_some() {
                                return Err(serde::de::Error::duplicate_field("registry"));
                            }
                            registry__ = map.next_value()?;
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::Group => {
                            if group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("group"));
                            }
                            group__ = map.next_value()?;
                        }
                        GeneratedField::Tenant => {
                            if tenant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tenant"));
                            }
                            tenant__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(QuobyteVolumeSource {
                    registry: registry__,
                    volume: volume__,
                    read_only: read_only__,
                    user: user__,
                    group: group__,
                    tenant: tenant__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.QuobyteVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RbdPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monitors.is_empty() {
            len += 1;
        }
        if self.image.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.pool.is_some() {
            len += 1;
        }
        if self.user.is_some() {
            len += 1;
        }
        if self.keyring.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.RBDPersistentVolumeSource", len)?;
        if !self.monitors.is_empty() {
            struct_ser.serialize_field("monitors", &self.monitors)?;
        }
        if let Some(v) = self.image.as_ref() {
            struct_ser.serialize_field("image", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            struct_ser.serialize_field("pool", v)?;
        }
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.keyring.as_ref() {
            struct_ser.serialize_field("keyring", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RbdPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "monitors",
            "image",
            "fsType",
            "pool",
            "user",
            "keyring",
            "secretRef",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Monitors,
            Image,
            FsType,
            Pool,
            User,
            Keyring,
            SecretRef,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "monitors" => Ok(GeneratedField::Monitors),
                            "image" => Ok(GeneratedField::Image),
                            "fsType" => Ok(GeneratedField::FsType),
                            "pool" => Ok(GeneratedField::Pool),
                            "user" => Ok(GeneratedField::User),
                            "keyring" => Ok(GeneratedField::Keyring),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RbdPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.RBDPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<RbdPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monitors__ = None;
                let mut image__ = None;
                let mut fs_type__ = None;
                let mut pool__ = None;
                let mut user__ = None;
                let mut keyring__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Monitors => {
                            if monitors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("monitors"));
                            }
                            monitors__ = Some(map.next_value()?);
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::Pool => {
                            if pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pool"));
                            }
                            pool__ = map.next_value()?;
                        }
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::Keyring => {
                            if keyring__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyring"));
                            }
                            keyring__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(RbdPersistentVolumeSource {
                    monitors: monitors__.unwrap_or_default(),
                    image: image__,
                    fs_type: fs_type__,
                    pool: pool__,
                    user: user__,
                    keyring: keyring__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.RBDPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RbdVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monitors.is_empty() {
            len += 1;
        }
        if self.image.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.pool.is_some() {
            len += 1;
        }
        if self.user.is_some() {
            len += 1;
        }
        if self.keyring.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.RBDVolumeSource", len)?;
        if !self.monitors.is_empty() {
            struct_ser.serialize_field("monitors", &self.monitors)?;
        }
        if let Some(v) = self.image.as_ref() {
            struct_ser.serialize_field("image", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.pool.as_ref() {
            struct_ser.serialize_field("pool", v)?;
        }
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.keyring.as_ref() {
            struct_ser.serialize_field("keyring", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RbdVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "monitors",
            "image",
            "fsType",
            "pool",
            "user",
            "keyring",
            "secretRef",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Monitors,
            Image,
            FsType,
            Pool,
            User,
            Keyring,
            SecretRef,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "monitors" => Ok(GeneratedField::Monitors),
                            "image" => Ok(GeneratedField::Image),
                            "fsType" => Ok(GeneratedField::FsType),
                            "pool" => Ok(GeneratedField::Pool),
                            "user" => Ok(GeneratedField::User),
                            "keyring" => Ok(GeneratedField::Keyring),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RbdVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.RBDVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<RbdVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monitors__ = None;
                let mut image__ = None;
                let mut fs_type__ = None;
                let mut pool__ = None;
                let mut user__ = None;
                let mut keyring__ = None;
                let mut secret_ref__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Monitors => {
                            if monitors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("monitors"));
                            }
                            monitors__ = Some(map.next_value()?);
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::Pool => {
                            if pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pool"));
                            }
                            pool__ = map.next_value()?;
                        }
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::Keyring => {
                            if keyring__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyring"));
                            }
                            keyring__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(RbdVolumeSource {
                    monitors: monitors__.unwrap_or_default(),
                    image: image__,
                    fs_type: fs_type__,
                    pool: pool__,
                    user: user__,
                    keyring: keyring__,
                    secret_ref: secret_ref__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.RBDVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeAllocation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.range.is_some() {
            len += 1;
        }
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.RangeAllocation", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.range.as_ref() {
            struct_ser.serialize_field("range", v)?;
        }
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("data", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeAllocation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "range",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Range,
            Data,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "range" => Ok(GeneratedField::Range),
                            "data" => Ok(GeneratedField::Data),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeAllocation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.RangeAllocation")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<RangeAllocation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut range__ = None;
                let mut data__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Range => {
                            if range__.is_some() {
                                return Err(serde::de::Error::duplicate_field("range"));
                            }
                            range__ = map.next_value()?;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(RangeAllocation {
                    metadata: metadata__,
                    range: range__,
                    data: data__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.RangeAllocation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicationController {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ReplicationController", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicationController {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicationController;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ReplicationController")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ReplicationController, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReplicationController {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ReplicationController", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicationControllerCondition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.last_transition_time.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        if self.message.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ReplicationControllerCondition", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.last_transition_time.as_ref() {
            struct_ser.serialize_field("lastTransitionTime", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicationControllerCondition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
            "lastTransitionTime",
            "reason",
            "message",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
            LastTransitionTime,
            Reason,
            Message,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            "lastTransitionTime" => Ok(GeneratedField::LastTransitionTime),
                            "reason" => Ok(GeneratedField::Reason),
                            "message" => Ok(GeneratedField::Message),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicationControllerCondition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ReplicationControllerCondition")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ReplicationControllerCondition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                let mut last_transition_time__ = None;
                let mut reason__ = None;
                let mut message__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::LastTransitionTime => {
                            if last_transition_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTransitionTime"));
                            }
                            last_transition_time__ = map.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map.next_value()?;
                        }
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReplicationControllerCondition {
                    r#type: r#type__,
                    status: status__,
                    last_transition_time: last_transition_time__,
                    reason: reason__,
                    message: message__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ReplicationControllerCondition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicationControllerList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ReplicationControllerList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicationControllerList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicationControllerList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ReplicationControllerList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ReplicationControllerList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReplicationControllerList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ReplicationControllerList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicationControllerSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.replicas.is_some() {
            len += 1;
        }
        if self.min_ready_seconds.is_some() {
            len += 1;
        }
        if !self.selector.is_empty() {
            len += 1;
        }
        if self.template.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ReplicationControllerSpec", len)?;
        if let Some(v) = self.replicas.as_ref() {
            struct_ser.serialize_field("replicas", v)?;
        }
        if let Some(v) = self.min_ready_seconds.as_ref() {
            struct_ser.serialize_field("minReadySeconds", v)?;
        }
        if !self.selector.is_empty() {
            struct_ser.serialize_field("selector", &self.selector)?;
        }
        if let Some(v) = self.template.as_ref() {
            struct_ser.serialize_field("template", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicationControllerSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "replicas",
            "minReadySeconds",
            "selector",
            "template",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Replicas,
            MinReadySeconds,
            Selector,
            Template,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "replicas" => Ok(GeneratedField::Replicas),
                            "minReadySeconds" => Ok(GeneratedField::MinReadySeconds),
                            "selector" => Ok(GeneratedField::Selector),
                            "template" => Ok(GeneratedField::Template),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicationControllerSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ReplicationControllerSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ReplicationControllerSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut replicas__ = None;
                let mut min_ready_seconds__ = None;
                let mut selector__ = None;
                let mut template__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Replicas => {
                            if replicas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replicas"));
                            }
                            replicas__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinReadySeconds => {
                            if min_ready_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minReadySeconds"));
                            }
                            min_ready_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Selector => {
                            if selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selector"));
                            }
                            selector__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Template => {
                            if template__.is_some() {
                                return Err(serde::de::Error::duplicate_field("template"));
                            }
                            template__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReplicationControllerSpec {
                    replicas: replicas__,
                    min_ready_seconds: min_ready_seconds__,
                    selector: selector__.unwrap_or_default(),
                    template: template__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ReplicationControllerSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplicationControllerStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.replicas.is_some() {
            len += 1;
        }
        if self.fully_labeled_replicas.is_some() {
            len += 1;
        }
        if self.ready_replicas.is_some() {
            len += 1;
        }
        if self.available_replicas.is_some() {
            len += 1;
        }
        if self.observed_generation.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ReplicationControllerStatus", len)?;
        if let Some(v) = self.replicas.as_ref() {
            struct_ser.serialize_field("replicas", v)?;
        }
        if let Some(v) = self.fully_labeled_replicas.as_ref() {
            struct_ser.serialize_field("fullyLabeledReplicas", v)?;
        }
        if let Some(v) = self.ready_replicas.as_ref() {
            struct_ser.serialize_field("readyReplicas", v)?;
        }
        if let Some(v) = self.available_replicas.as_ref() {
            struct_ser.serialize_field("availableReplicas", v)?;
        }
        if let Some(v) = self.observed_generation.as_ref() {
            struct_ser.serialize_field("observedGeneration", ToString::to_string(&v).as_str())?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicationControllerStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "replicas",
            "fullyLabeledReplicas",
            "readyReplicas",
            "availableReplicas",
            "observedGeneration",
            "conditions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Replicas,
            FullyLabeledReplicas,
            ReadyReplicas,
            AvailableReplicas,
            ObservedGeneration,
            Conditions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "replicas" => Ok(GeneratedField::Replicas),
                            "fullyLabeledReplicas" => Ok(GeneratedField::FullyLabeledReplicas),
                            "readyReplicas" => Ok(GeneratedField::ReadyReplicas),
                            "availableReplicas" => Ok(GeneratedField::AvailableReplicas),
                            "observedGeneration" => Ok(GeneratedField::ObservedGeneration),
                            "conditions" => Ok(GeneratedField::Conditions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplicationControllerStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ReplicationControllerStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ReplicationControllerStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut replicas__ = None;
                let mut fully_labeled_replicas__ = None;
                let mut ready_replicas__ = None;
                let mut available_replicas__ = None;
                let mut observed_generation__ = None;
                let mut conditions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Replicas => {
                            if replicas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replicas"));
                            }
                            replicas__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FullyLabeledReplicas => {
                            if fully_labeled_replicas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fullyLabeledReplicas"));
                            }
                            fully_labeled_replicas__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadyReplicas => {
                            if ready_replicas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readyReplicas"));
                            }
                            ready_replicas__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvailableReplicas => {
                            if available_replicas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("availableReplicas"));
                            }
                            available_replicas__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ObservedGeneration => {
                            if observed_generation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("observedGeneration"));
                            }
                            observed_generation__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReplicationControllerStatus {
                    replicas: replicas__,
                    fully_labeled_replicas: fully_labeled_replicas__,
                    ready_replicas: ready_replicas__,
                    available_replicas: available_replicas__,
                    observed_generation: observed_generation__,
                    conditions: conditions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ReplicationControllerStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceClaim {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceClaim", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceClaim {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceClaim;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceClaim")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceClaim, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceClaim {
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceClaim", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceFieldSelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.container_name.is_some() {
            len += 1;
        }
        if self.resource.is_some() {
            len += 1;
        }
        if self.divisor.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceFieldSelector", len)?;
        if let Some(v) = self.container_name.as_ref() {
            struct_ser.serialize_field("containerName", v)?;
        }
        if let Some(v) = self.resource.as_ref() {
            struct_ser.serialize_field("resource", v)?;
        }
        if let Some(v) = self.divisor.as_ref() {
            struct_ser.serialize_field("divisor", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceFieldSelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "containerName",
            "resource",
            "divisor",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ContainerName,
            Resource,
            Divisor,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "containerName" => Ok(GeneratedField::ContainerName),
                            "resource" => Ok(GeneratedField::Resource),
                            "divisor" => Ok(GeneratedField::Divisor),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceFieldSelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceFieldSelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceFieldSelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut container_name__ = None;
                let mut resource__ = None;
                let mut divisor__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ContainerName => {
                            if container_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("containerName"));
                            }
                            container_name__ = map.next_value()?;
                        }
                        GeneratedField::Resource => {
                            if resource__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resource"));
                            }
                            resource__ = map.next_value()?;
                        }
                        GeneratedField::Divisor => {
                            if divisor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("divisor"));
                            }
                            divisor__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceFieldSelector {
                    container_name: container_name__,
                    resource: resource__,
                    divisor: divisor__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceFieldSelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceQuota {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceQuota", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceQuota {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceQuota;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceQuota")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceQuota, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceQuota {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceQuota", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceQuotaList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceQuotaList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceQuotaList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceQuotaList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceQuotaList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceQuotaList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceQuotaList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceQuotaList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceQuotaSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.hard.is_empty() {
            len += 1;
        }
        if !self.scopes.is_empty() {
            len += 1;
        }
        if self.scope_selector.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceQuotaSpec", len)?;
        if !self.hard.is_empty() {
            struct_ser.serialize_field("hard", &self.hard)?;
        }
        if !self.scopes.is_empty() {
            struct_ser.serialize_field("scopes", &self.scopes)?;
        }
        if let Some(v) = self.scope_selector.as_ref() {
            struct_ser.serialize_field("scopeSelector", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceQuotaSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hard",
            "scopes",
            "scopeSelector",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Hard,
            Scopes,
            ScopeSelector,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hard" => Ok(GeneratedField::Hard),
                            "scopes" => Ok(GeneratedField::Scopes),
                            "scopeSelector" => Ok(GeneratedField::ScopeSelector),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceQuotaSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceQuotaSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceQuotaSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hard__ = None;
                let mut scopes__ = None;
                let mut scope_selector__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Hard => {
                            if hard__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hard"));
                            }
                            hard__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Scopes => {
                            if scopes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scopes"));
                            }
                            scopes__ = Some(map.next_value()?);
                        }
                        GeneratedField::ScopeSelector => {
                            if scope_selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scopeSelector"));
                            }
                            scope_selector__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceQuotaSpec {
                    hard: hard__.unwrap_or_default(),
                    scopes: scopes__.unwrap_or_default(),
                    scope_selector: scope_selector__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceQuotaSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceQuotaStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.hard.is_empty() {
            len += 1;
        }
        if !self.used.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceQuotaStatus", len)?;
        if !self.hard.is_empty() {
            struct_ser.serialize_field("hard", &self.hard)?;
        }
        if !self.used.is_empty() {
            struct_ser.serialize_field("used", &self.used)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceQuotaStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hard",
            "used",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Hard,
            Used,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hard" => Ok(GeneratedField::Hard),
                            "used" => Ok(GeneratedField::Used),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceQuotaStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceQuotaStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceQuotaStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hard__ = None;
                let mut used__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Hard => {
                            if hard__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hard"));
                            }
                            hard__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Used => {
                            if used__.is_some() {
                                return Err(serde::de::Error::duplicate_field("used"));
                            }
                            used__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceQuotaStatus {
                    hard: hard__.unwrap_or_default(),
                    used: used__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceQuotaStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResourceRequirements {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.limits.is_empty() {
            len += 1;
        }
        if !self.requests.is_empty() {
            len += 1;
        }
        if !self.claims.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ResourceRequirements", len)?;
        if !self.limits.is_empty() {
            struct_ser.serialize_field("limits", &self.limits)?;
        }
        if !self.requests.is_empty() {
            struct_ser.serialize_field("requests", &self.requests)?;
        }
        if !self.claims.is_empty() {
            struct_ser.serialize_field("claims", &self.claims)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceRequirements {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "limits",
            "requests",
            "claims",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Limits,
            Requests,
            Claims,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "limits" => Ok(GeneratedField::Limits),
                            "requests" => Ok(GeneratedField::Requests),
                            "claims" => Ok(GeneratedField::Claims),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResourceRequirements;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ResourceRequirements")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ResourceRequirements, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut limits__ = None;
                let mut requests__ = None;
                let mut claims__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Limits => {
                            if limits__.is_some() {
                                return Err(serde::de::Error::duplicate_field("limits"));
                            }
                            limits__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Requests => {
                            if requests__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requests"));
                            }
                            requests__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Claims => {
                            if claims__.is_some() {
                                return Err(serde::de::Error::duplicate_field("claims"));
                            }
                            claims__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ResourceRequirements {
                    limits: limits__.unwrap_or_default(),
                    requests: requests__.unwrap_or_default(),
                    claims: claims__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ResourceRequirements", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeLinuxOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.user.is_some() {
            len += 1;
        }
        if self.role.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SELinuxOptions", len)?;
        if let Some(v) = self.user.as_ref() {
            struct_ser.serialize_field("user", v)?;
        }
        if let Some(v) = self.role.as_ref() {
            struct_ser.serialize_field("role", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("level", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeLinuxOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user",
            "role",
            "type",
            "level",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            User,
            Role,
            Type,
            Level,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "user" => Ok(GeneratedField::User),
                            "role" => Ok(GeneratedField::Role),
                            "type" => Ok(GeneratedField::Type),
                            "level" => Ok(GeneratedField::Level),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeLinuxOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SELinuxOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SeLinuxOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user__ = None;
                let mut role__ = None;
                let mut r#type__ = None;
                let mut level__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::User => {
                            if user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("user"));
                            }
                            user__ = map.next_value()?;
                        }
                        GeneratedField::Role => {
                            if role__.is_some() {
                                return Err(serde::de::Error::duplicate_field("role"));
                            }
                            role__ = map.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("level"));
                            }
                            level__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SeLinuxOptions {
                    user: user__,
                    role: role__,
                    r#type: r#type__,
                    level: level__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SELinuxOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScaleIoPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.gateway.is_some() {
            len += 1;
        }
        if self.system.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.ssl_enabled.is_some() {
            len += 1;
        }
        if self.protection_domain.is_some() {
            len += 1;
        }
        if self.storage_pool.is_some() {
            len += 1;
        }
        if self.storage_mode.is_some() {
            len += 1;
        }
        if self.volume_name.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ScaleIOPersistentVolumeSource", len)?;
        if let Some(v) = self.gateway.as_ref() {
            struct_ser.serialize_field("gateway", v)?;
        }
        if let Some(v) = self.system.as_ref() {
            struct_ser.serialize_field("system", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.ssl_enabled.as_ref() {
            struct_ser.serialize_field("sslEnabled", v)?;
        }
        if let Some(v) = self.protection_domain.as_ref() {
            struct_ser.serialize_field("protectionDomain", v)?;
        }
        if let Some(v) = self.storage_pool.as_ref() {
            struct_ser.serialize_field("storagePool", v)?;
        }
        if let Some(v) = self.storage_mode.as_ref() {
            struct_ser.serialize_field("storageMode", v)?;
        }
        if let Some(v) = self.volume_name.as_ref() {
            struct_ser.serialize_field("volumeName", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScaleIoPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "gateway",
            "system",
            "secretRef",
            "sslEnabled",
            "protectionDomain",
            "storagePool",
            "storageMode",
            "volumeName",
            "fsType",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Gateway,
            System,
            SecretRef,
            SslEnabled,
            ProtectionDomain,
            StoragePool,
            StorageMode,
            VolumeName,
            FsType,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "gateway" => Ok(GeneratedField::Gateway),
                            "system" => Ok(GeneratedField::System),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "sslEnabled" => Ok(GeneratedField::SslEnabled),
                            "protectionDomain" => Ok(GeneratedField::ProtectionDomain),
                            "storagePool" => Ok(GeneratedField::StoragePool),
                            "storageMode" => Ok(GeneratedField::StorageMode),
                            "volumeName" => Ok(GeneratedField::VolumeName),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScaleIoPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ScaleIOPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ScaleIoPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gateway__ = None;
                let mut system__ = None;
                let mut secret_ref__ = None;
                let mut ssl_enabled__ = None;
                let mut protection_domain__ = None;
                let mut storage_pool__ = None;
                let mut storage_mode__ = None;
                let mut volume_name__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Gateway => {
                            if gateway__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gateway"));
                            }
                            gateway__ = map.next_value()?;
                        }
                        GeneratedField::System => {
                            if system__.is_some() {
                                return Err(serde::de::Error::duplicate_field("system"));
                            }
                            system__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::SslEnabled => {
                            if ssl_enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sslEnabled"));
                            }
                            ssl_enabled__ = map.next_value()?;
                        }
                        GeneratedField::ProtectionDomain => {
                            if protection_domain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protectionDomain"));
                            }
                            protection_domain__ = map.next_value()?;
                        }
                        GeneratedField::StoragePool => {
                            if storage_pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storagePool"));
                            }
                            storage_pool__ = map.next_value()?;
                        }
                        GeneratedField::StorageMode => {
                            if storage_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageMode"));
                            }
                            storage_mode__ = map.next_value()?;
                        }
                        GeneratedField::VolumeName => {
                            if volume_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeName"));
                            }
                            volume_name__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ScaleIoPersistentVolumeSource {
                    gateway: gateway__,
                    system: system__,
                    secret_ref: secret_ref__,
                    ssl_enabled: ssl_enabled__,
                    protection_domain: protection_domain__,
                    storage_pool: storage_pool__,
                    storage_mode: storage_mode__,
                    volume_name: volume_name__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ScaleIOPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScaleIoVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.gateway.is_some() {
            len += 1;
        }
        if self.system.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        if self.ssl_enabled.is_some() {
            len += 1;
        }
        if self.protection_domain.is_some() {
            len += 1;
        }
        if self.storage_pool.is_some() {
            len += 1;
        }
        if self.storage_mode.is_some() {
            len += 1;
        }
        if self.volume_name.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ScaleIOVolumeSource", len)?;
        if let Some(v) = self.gateway.as_ref() {
            struct_ser.serialize_field("gateway", v)?;
        }
        if let Some(v) = self.system.as_ref() {
            struct_ser.serialize_field("system", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        if let Some(v) = self.ssl_enabled.as_ref() {
            struct_ser.serialize_field("sslEnabled", v)?;
        }
        if let Some(v) = self.protection_domain.as_ref() {
            struct_ser.serialize_field("protectionDomain", v)?;
        }
        if let Some(v) = self.storage_pool.as_ref() {
            struct_ser.serialize_field("storagePool", v)?;
        }
        if let Some(v) = self.storage_mode.as_ref() {
            struct_ser.serialize_field("storageMode", v)?;
        }
        if let Some(v) = self.volume_name.as_ref() {
            struct_ser.serialize_field("volumeName", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScaleIoVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "gateway",
            "system",
            "secretRef",
            "sslEnabled",
            "protectionDomain",
            "storagePool",
            "storageMode",
            "volumeName",
            "fsType",
            "readOnly",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Gateway,
            System,
            SecretRef,
            SslEnabled,
            ProtectionDomain,
            StoragePool,
            StorageMode,
            VolumeName,
            FsType,
            ReadOnly,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "gateway" => Ok(GeneratedField::Gateway),
                            "system" => Ok(GeneratedField::System),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            "sslEnabled" => Ok(GeneratedField::SslEnabled),
                            "protectionDomain" => Ok(GeneratedField::ProtectionDomain),
                            "storagePool" => Ok(GeneratedField::StoragePool),
                            "storageMode" => Ok(GeneratedField::StorageMode),
                            "volumeName" => Ok(GeneratedField::VolumeName),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScaleIoVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ScaleIOVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ScaleIoVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gateway__ = None;
                let mut system__ = None;
                let mut secret_ref__ = None;
                let mut ssl_enabled__ = None;
                let mut protection_domain__ = None;
                let mut storage_pool__ = None;
                let mut storage_mode__ = None;
                let mut volume_name__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Gateway => {
                            if gateway__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gateway"));
                            }
                            gateway__ = map.next_value()?;
                        }
                        GeneratedField::System => {
                            if system__.is_some() {
                                return Err(serde::de::Error::duplicate_field("system"));
                            }
                            system__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::SslEnabled => {
                            if ssl_enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sslEnabled"));
                            }
                            ssl_enabled__ = map.next_value()?;
                        }
                        GeneratedField::ProtectionDomain => {
                            if protection_domain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protectionDomain"));
                            }
                            protection_domain__ = map.next_value()?;
                        }
                        GeneratedField::StoragePool => {
                            if storage_pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storagePool"));
                            }
                            storage_pool__ = map.next_value()?;
                        }
                        GeneratedField::StorageMode => {
                            if storage_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageMode"));
                            }
                            storage_mode__ = map.next_value()?;
                        }
                        GeneratedField::VolumeName => {
                            if volume_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeName"));
                            }
                            volume_name__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ScaleIoVolumeSource {
                    gateway: gateway__,
                    system: system__,
                    secret_ref: secret_ref__,
                    ssl_enabled: ssl_enabled__,
                    protection_domain: protection_domain__,
                    storage_pool: storage_pool__,
                    storage_mode: storage_mode__,
                    volume_name: volume_name__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ScaleIOVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScopeSelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.match_expressions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ScopeSelector", len)?;
        if !self.match_expressions.is_empty() {
            struct_ser.serialize_field("matchExpressions", &self.match_expressions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScopeSelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "matchExpressions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MatchExpressions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "matchExpressions" => Ok(GeneratedField::MatchExpressions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScopeSelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ScopeSelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ScopeSelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut match_expressions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::MatchExpressions => {
                            if match_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matchExpressions"));
                            }
                            match_expressions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ScopeSelector {
                    match_expressions: match_expressions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ScopeSelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScopedResourceSelectorRequirement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scope_name.is_some() {
            len += 1;
        }
        if self.operator.is_some() {
            len += 1;
        }
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ScopedResourceSelectorRequirement", len)?;
        if let Some(v) = self.scope_name.as_ref() {
            struct_ser.serialize_field("scopeName", v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            struct_ser.serialize_field("operator", v)?;
        }
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScopedResourceSelectorRequirement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scopeName",
            "operator",
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ScopeName,
            Operator,
            Values,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scopeName" => Ok(GeneratedField::ScopeName),
                            "operator" => Ok(GeneratedField::Operator),
                            "values" => Ok(GeneratedField::Values),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScopedResourceSelectorRequirement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ScopedResourceSelectorRequirement")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ScopedResourceSelectorRequirement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scope_name__ = None;
                let mut operator__ = None;
                let mut values__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ScopeName => {
                            if scope_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scopeName"));
                            }
                            scope_name__ = map.next_value()?;
                        }
                        GeneratedField::Operator => {
                            if operator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operator"));
                            }
                            operator__ = map.next_value()?;
                        }
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ScopedResourceSelectorRequirement {
                    scope_name: scope_name__,
                    operator: operator__,
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ScopedResourceSelectorRequirement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeccompProfile {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.localhost_profile.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SeccompProfile", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if let Some(v) = self.localhost_profile.as_ref() {
            struct_ser.serialize_field("localhostProfile", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeccompProfile {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "localhostProfile",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            LocalhostProfile,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "localhostProfile" => Ok(GeneratedField::LocalhostProfile),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeccompProfile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SeccompProfile")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SeccompProfile, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut localhost_profile__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::LocalhostProfile => {
                            if localhost_profile__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localhostProfile"));
                            }
                            localhost_profile__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SeccompProfile {
                    r#type: r#type__,
                    localhost_profile: localhost_profile__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SeccompProfile", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Secret {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.immutable.is_some() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        if !self.string_data.is_empty() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Secret", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.immutable.as_ref() {
            struct_ser.serialize_field("immutable", v)?;
        }
        if !self.data.is_empty() {
            let v: std::collections::HashMap<_, _> = self.data.iter()
                .map(|(k, v)| (k, pbjson::private::base64::encode(v))).collect();
            struct_ser.serialize_field("data", &v)?;
        }
        if !self.string_data.is_empty() {
            struct_ser.serialize_field("stringData", &self.string_data)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Secret {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "immutable",
            "data",
            "stringData",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Immutable,
            Data,
            StringData,
            Type,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "immutable" => Ok(GeneratedField::Immutable),
                            "data" => Ok(GeneratedField::Data),
                            "stringData" => Ok(GeneratedField::StringData),
                            "type" => Ok(GeneratedField::Type),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Secret;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Secret")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Secret, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut immutable__ = None;
                let mut data__ = None;
                let mut string_data__ = None;
                let mut r#type__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Immutable => {
                            if immutable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("immutable"));
                            }
                            immutable__ = map.next_value()?;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(
                                map.next_value::<std::collections::HashMap<_, ::pbjson::private::BytesDeserialize<_>>>()?
                                    .into_iter().map(|(k,v)| (k, v.0)).collect()
                            );
                        }
                        GeneratedField::StringData => {
                            if string_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stringData"));
                            }
                            string_data__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Secret {
                    metadata: metadata__,
                    immutable: immutable__,
                    data: data__.unwrap_or_default(),
                    string_data: string_data__.unwrap_or_default(),
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Secret", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretEnvSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretEnvSource", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretEnvSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretEnvSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretEnvSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretEnvSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretEnvSource {
                    local_object_reference: local_object_reference__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretEnvSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretKeySelector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if self.key.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretKeySelector", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretKeySelector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "key",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Key,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "key" => Ok(GeneratedField::Key),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretKeySelector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretKeySelector")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretKeySelector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut key__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretKeySelector {
                    local_object_reference: local_object_reference__,
                    key: key__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretKeySelector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretProjection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.local_object_reference.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretProjection", len)?;
        if let Some(v) = self.local_object_reference.as_ref() {
            struct_ser.serialize_field("localObjectReference", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretProjection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "localObjectReference",
            "items",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocalObjectReference,
            Items,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "localObjectReference" => Ok(GeneratedField::LocalObjectReference),
                            "items" => Ok(GeneratedField::Items),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretProjection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretProjection")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretProjection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut local_object_reference__ = None;
                let mut items__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LocalObjectReference => {
                            if local_object_reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localObjectReference"));
                            }
                            local_object_reference__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretProjection {
                    local_object_reference: local_object_reference__,
                    items: items__.unwrap_or_default(),
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretProjection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.namespace.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretReference", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            struct_ser.serialize_field("namespace", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "namespace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Namespace,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "namespace" => Ok(GeneratedField::Namespace),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut namespace__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Namespace => {
                            if namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespace"));
                            }
                            namespace__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretReference {
                    name: name__,
                    namespace: namespace__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecretVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.secret_name.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.default_mode.is_some() {
            len += 1;
        }
        if self.optional.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecretVolumeSource", len)?;
        if let Some(v) = self.secret_name.as_ref() {
            struct_ser.serialize_field("secretName", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.default_mode.as_ref() {
            struct_ser.serialize_field("defaultMode", v)?;
        }
        if let Some(v) = self.optional.as_ref() {
            struct_ser.serialize_field("optional", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecretVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "secretName",
            "items",
            "defaultMode",
            "optional",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SecretName,
            Items,
            DefaultMode,
            Optional,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "secretName" => Ok(GeneratedField::SecretName),
                            "items" => Ok(GeneratedField::Items),
                            "defaultMode" => Ok(GeneratedField::DefaultMode),
                            "optional" => Ok(GeneratedField::Optional),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecretVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecretVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecretVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut secret_name__ = None;
                let mut items__ = None;
                let mut default_mode__ = None;
                let mut optional__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::SecretName => {
                            if secret_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretName"));
                            }
                            secret_name__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::DefaultMode => {
                            if default_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultMode"));
                            }
                            default_mode__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Optional => {
                            if optional__.is_some() {
                                return Err(serde::de::Error::duplicate_field("optional"));
                            }
                            optional__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecretVolumeSource {
                    secret_name: secret_name__,
                    items: items__.unwrap_or_default(),
                    default_mode: default_mode__,
                    optional: optional__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecretVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SecurityContext {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.capabilities.is_some() {
            len += 1;
        }
        if self.privileged.is_some() {
            len += 1;
        }
        if self.se_linux_options.is_some() {
            len += 1;
        }
        if self.windows_options.is_some() {
            len += 1;
        }
        if self.run_as_user.is_some() {
            len += 1;
        }
        if self.run_as_group.is_some() {
            len += 1;
        }
        if self.run_as_non_root.is_some() {
            len += 1;
        }
        if self.read_only_root_filesystem.is_some() {
            len += 1;
        }
        if self.allow_privilege_escalation.is_some() {
            len += 1;
        }
        if self.proc_mount.is_some() {
            len += 1;
        }
        if self.seccomp_profile.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SecurityContext", len)?;
        if let Some(v) = self.capabilities.as_ref() {
            struct_ser.serialize_field("capabilities", v)?;
        }
        if let Some(v) = self.privileged.as_ref() {
            struct_ser.serialize_field("privileged", v)?;
        }
        if let Some(v) = self.se_linux_options.as_ref() {
            struct_ser.serialize_field("seLinuxOptions", v)?;
        }
        if let Some(v) = self.windows_options.as_ref() {
            struct_ser.serialize_field("windowsOptions", v)?;
        }
        if let Some(v) = self.run_as_user.as_ref() {
            struct_ser.serialize_field("runAsUser", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.run_as_group.as_ref() {
            struct_ser.serialize_field("runAsGroup", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.run_as_non_root.as_ref() {
            struct_ser.serialize_field("runAsNonRoot", v)?;
        }
        if let Some(v) = self.read_only_root_filesystem.as_ref() {
            struct_ser.serialize_field("readOnlyRootFilesystem", v)?;
        }
        if let Some(v) = self.allow_privilege_escalation.as_ref() {
            struct_ser.serialize_field("allowPrivilegeEscalation", v)?;
        }
        if let Some(v) = self.proc_mount.as_ref() {
            struct_ser.serialize_field("procMount", v)?;
        }
        if let Some(v) = self.seccomp_profile.as_ref() {
            struct_ser.serialize_field("seccompProfile", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SecurityContext {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capabilities",
            "privileged",
            "seLinuxOptions",
            "windowsOptions",
            "runAsUser",
            "runAsGroup",
            "runAsNonRoot",
            "readOnlyRootFilesystem",
            "allowPrivilegeEscalation",
            "procMount",
            "seccompProfile",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capabilities,
            Privileged,
            SeLinuxOptions,
            WindowsOptions,
            RunAsUser,
            RunAsGroup,
            RunAsNonRoot,
            ReadOnlyRootFilesystem,
            AllowPrivilegeEscalation,
            ProcMount,
            SeccompProfile,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capabilities" => Ok(GeneratedField::Capabilities),
                            "privileged" => Ok(GeneratedField::Privileged),
                            "seLinuxOptions" => Ok(GeneratedField::SeLinuxOptions),
                            "windowsOptions" => Ok(GeneratedField::WindowsOptions),
                            "runAsUser" => Ok(GeneratedField::RunAsUser),
                            "runAsGroup" => Ok(GeneratedField::RunAsGroup),
                            "runAsNonRoot" => Ok(GeneratedField::RunAsNonRoot),
                            "readOnlyRootFilesystem" => Ok(GeneratedField::ReadOnlyRootFilesystem),
                            "allowPrivilegeEscalation" => Ok(GeneratedField::AllowPrivilegeEscalation),
                            "procMount" => Ok(GeneratedField::ProcMount),
                            "seccompProfile" => Ok(GeneratedField::SeccompProfile),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SecurityContext;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SecurityContext")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SecurityContext, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capabilities__ = None;
                let mut privileged__ = None;
                let mut se_linux_options__ = None;
                let mut windows_options__ = None;
                let mut run_as_user__ = None;
                let mut run_as_group__ = None;
                let mut run_as_non_root__ = None;
                let mut read_only_root_filesystem__ = None;
                let mut allow_privilege_escalation__ = None;
                let mut proc_mount__ = None;
                let mut seccomp_profile__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Capabilities => {
                            if capabilities__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capabilities"));
                            }
                            capabilities__ = map.next_value()?;
                        }
                        GeneratedField::Privileged => {
                            if privileged__.is_some() {
                                return Err(serde::de::Error::duplicate_field("privileged"));
                            }
                            privileged__ = map.next_value()?;
                        }
                        GeneratedField::SeLinuxOptions => {
                            if se_linux_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seLinuxOptions"));
                            }
                            se_linux_options__ = map.next_value()?;
                        }
                        GeneratedField::WindowsOptions => {
                            if windows_options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windowsOptions"));
                            }
                            windows_options__ = map.next_value()?;
                        }
                        GeneratedField::RunAsUser => {
                            if run_as_user__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsUser"));
                            }
                            run_as_user__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunAsGroup => {
                            if run_as_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsGroup"));
                            }
                            run_as_group__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunAsNonRoot => {
                            if run_as_non_root__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsNonRoot"));
                            }
                            run_as_non_root__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnlyRootFilesystem => {
                            if read_only_root_filesystem__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnlyRootFilesystem"));
                            }
                            read_only_root_filesystem__ = map.next_value()?;
                        }
                        GeneratedField::AllowPrivilegeEscalation => {
                            if allow_privilege_escalation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allowPrivilegeEscalation"));
                            }
                            allow_privilege_escalation__ = map.next_value()?;
                        }
                        GeneratedField::ProcMount => {
                            if proc_mount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("procMount"));
                            }
                            proc_mount__ = map.next_value()?;
                        }
                        GeneratedField::SeccompProfile => {
                            if seccomp_profile__.is_some() {
                                return Err(serde::de::Error::duplicate_field("seccompProfile"));
                            }
                            seccomp_profile__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SecurityContext {
                    capabilities: capabilities__,
                    privileged: privileged__,
                    se_linux_options: se_linux_options__,
                    windows_options: windows_options__,
                    run_as_user: run_as_user__,
                    run_as_group: run_as_group__,
                    run_as_non_root: run_as_non_root__,
                    read_only_root_filesystem: read_only_root_filesystem__,
                    allow_privilege_escalation: allow_privilege_escalation__,
                    proc_mount: proc_mount__,
                    seccomp_profile: seccomp_profile__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SecurityContext", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SerializedReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reference.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SerializedReference", len)?;
        if let Some(v) = self.reference.as_ref() {
            struct_ser.serialize_field("reference", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SerializedReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reference",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reference,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reference" => Ok(GeneratedField::Reference),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SerializedReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SerializedReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SerializedReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reference__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Reference => {
                            if reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reference"));
                            }
                            reference__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SerializedReference {
                    reference: reference__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SerializedReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Service {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if self.spec.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Service", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.spec.as_ref() {
            struct_ser.serialize_field("spec", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Service {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "spec",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Spec,
            Status,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "spec" => Ok(GeneratedField::Spec),
                            "status" => Ok(GeneratedField::Status),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Service;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Service")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Service, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut spec__ = None;
                let mut status__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = map.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Service {
                    metadata: metadata__,
                    spec: spec__,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Service", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceAccount {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.secrets.is_empty() {
            len += 1;
        }
        if !self.image_pull_secrets.is_empty() {
            len += 1;
        }
        if self.automount_service_account_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceAccount", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.secrets.is_empty() {
            struct_ser.serialize_field("secrets", &self.secrets)?;
        }
        if !self.image_pull_secrets.is_empty() {
            struct_ser.serialize_field("imagePullSecrets", &self.image_pull_secrets)?;
        }
        if let Some(v) = self.automount_service_account_token.as_ref() {
            struct_ser.serialize_field("automountServiceAccountToken", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceAccount {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "secrets",
            "imagePullSecrets",
            "automountServiceAccountToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Secrets,
            ImagePullSecrets,
            AutomountServiceAccountToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "secrets" => Ok(GeneratedField::Secrets),
                            "imagePullSecrets" => Ok(GeneratedField::ImagePullSecrets),
                            "automountServiceAccountToken" => Ok(GeneratedField::AutomountServiceAccountToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceAccount;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceAccount")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceAccount, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut secrets__ = None;
                let mut image_pull_secrets__ = None;
                let mut automount_service_account_token__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Secrets => {
                            if secrets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secrets"));
                            }
                            secrets__ = Some(map.next_value()?);
                        }
                        GeneratedField::ImagePullSecrets => {
                            if image_pull_secrets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imagePullSecrets"));
                            }
                            image_pull_secrets__ = Some(map.next_value()?);
                        }
                        GeneratedField::AutomountServiceAccountToken => {
                            if automount_service_account_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("automountServiceAccountToken"));
                            }
                            automount_service_account_token__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceAccount {
                    metadata: metadata__,
                    secrets: secrets__.unwrap_or_default(),
                    image_pull_secrets: image_pull_secrets__.unwrap_or_default(),
                    automount_service_account_token: automount_service_account_token__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceAccount", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceAccountList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceAccountList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceAccountList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceAccountList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceAccountList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceAccountList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceAccountList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceAccountList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceAccountTokenProjection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.audience.is_some() {
            len += 1;
        }
        if self.expiration_seconds.is_some() {
            len += 1;
        }
        if self.path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceAccountTokenProjection", len)?;
        if let Some(v) = self.audience.as_ref() {
            struct_ser.serialize_field("audience", v)?;
        }
        if let Some(v) = self.expiration_seconds.as_ref() {
            struct_ser.serialize_field("expirationSeconds", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceAccountTokenProjection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "audience",
            "expirationSeconds",
            "path",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Audience,
            ExpirationSeconds,
            Path,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "audience" => Ok(GeneratedField::Audience),
                            "expirationSeconds" => Ok(GeneratedField::ExpirationSeconds),
                            "path" => Ok(GeneratedField::Path),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceAccountTokenProjection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceAccountTokenProjection")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceAccountTokenProjection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut audience__ = None;
                let mut expiration_seconds__ = None;
                let mut path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Audience => {
                            if audience__.is_some() {
                                return Err(serde::de::Error::duplicate_field("audience"));
                            }
                            audience__ = map.next_value()?;
                        }
                        GeneratedField::ExpirationSeconds => {
                            if expiration_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expirationSeconds"));
                            }
                            expiration_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceAccountTokenProjection {
                    audience: audience__,
                    expiration_seconds: expiration_seconds__,
                    path: path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceAccountTokenProjection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.metadata.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceList", len)?;
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "metadata",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Metadata,
            Items,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "metadata" => Ok(GeneratedField::Metadata),
                            "items" => Ok(GeneratedField::Items),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceList")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut metadata__ = None;
                let mut items__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceList {
                    metadata: metadata__,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServicePort {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.protocol.is_some() {
            len += 1;
        }
        if self.app_protocol.is_some() {
            len += 1;
        }
        if self.port.is_some() {
            len += 1;
        }
        if self.target_port.is_some() {
            len += 1;
        }
        if self.node_port.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServicePort", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.protocol.as_ref() {
            struct_ser.serialize_field("protocol", v)?;
        }
        if let Some(v) = self.app_protocol.as_ref() {
            struct_ser.serialize_field("appProtocol", v)?;
        }
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.target_port.as_ref() {
            struct_ser.serialize_field("targetPort", v)?;
        }
        if let Some(v) = self.node_port.as_ref() {
            struct_ser.serialize_field("nodePort", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServicePort {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "protocol",
            "appProtocol",
            "port",
            "targetPort",
            "nodePort",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Protocol,
            AppProtocol,
            Port,
            TargetPort,
            NodePort,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "protocol" => Ok(GeneratedField::Protocol),
                            "appProtocol" => Ok(GeneratedField::AppProtocol),
                            "port" => Ok(GeneratedField::Port),
                            "targetPort" => Ok(GeneratedField::TargetPort),
                            "nodePort" => Ok(GeneratedField::NodePort),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServicePort;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServicePort")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServicePort, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut protocol__ = None;
                let mut app_protocol__ = None;
                let mut port__ = None;
                let mut target_port__ = None;
                let mut node_port__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Protocol => {
                            if protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocol"));
                            }
                            protocol__ = map.next_value()?;
                        }
                        GeneratedField::AppProtocol => {
                            if app_protocol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appProtocol"));
                            }
                            app_protocol__ = map.next_value()?;
                        }
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPort => {
                            if target_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetPort"));
                            }
                            target_port__ = map.next_value()?;
                        }
                        GeneratedField::NodePort => {
                            if node_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodePort"));
                            }
                            node_port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServicePort {
                    name: name__,
                    protocol: protocol__,
                    app_protocol: app_protocol__,
                    port: port__,
                    target_port: target_port__,
                    node_port: node_port__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServicePort", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceProxyOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceProxyOptions", len)?;
        if let Some(v) = self.path.as_ref() {
            struct_ser.serialize_field("path", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceProxyOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "path",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Path,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "path" => Ok(GeneratedField::Path),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceProxyOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceProxyOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceProxyOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Path => {
                            if path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceProxyOptions {
                    path: path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceProxyOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceSpec {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ports.is_empty() {
            len += 1;
        }
        if !self.selector.is_empty() {
            len += 1;
        }
        if self.cluster_ip.is_some() {
            len += 1;
        }
        if !self.cluster_i_ps.is_empty() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if !self.external_i_ps.is_empty() {
            len += 1;
        }
        if self.session_affinity.is_some() {
            len += 1;
        }
        if self.load_balancer_ip.is_some() {
            len += 1;
        }
        if !self.load_balancer_source_ranges.is_empty() {
            len += 1;
        }
        if self.external_name.is_some() {
            len += 1;
        }
        if self.external_traffic_policy.is_some() {
            len += 1;
        }
        if self.health_check_node_port.is_some() {
            len += 1;
        }
        if self.publish_not_ready_addresses.is_some() {
            len += 1;
        }
        if self.session_affinity_config.is_some() {
            len += 1;
        }
        if !self.ip_families.is_empty() {
            len += 1;
        }
        if self.ip_family_policy.is_some() {
            len += 1;
        }
        if self.allocate_load_balancer_node_ports.is_some() {
            len += 1;
        }
        if self.load_balancer_class.is_some() {
            len += 1;
        }
        if self.internal_traffic_policy.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceSpec", len)?;
        if !self.ports.is_empty() {
            struct_ser.serialize_field("ports", &self.ports)?;
        }
        if !self.selector.is_empty() {
            struct_ser.serialize_field("selector", &self.selector)?;
        }
        if let Some(v) = self.cluster_ip.as_ref() {
            struct_ser.serialize_field("clusterIP", v)?;
        }
        if !self.cluster_i_ps.is_empty() {
            struct_ser.serialize_field("clusterIPs", &self.cluster_i_ps)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        if !self.external_i_ps.is_empty() {
            struct_ser.serialize_field("externalIPs", &self.external_i_ps)?;
        }
        if let Some(v) = self.session_affinity.as_ref() {
            struct_ser.serialize_field("sessionAffinity", v)?;
        }
        if let Some(v) = self.load_balancer_ip.as_ref() {
            struct_ser.serialize_field("loadBalancerIP", v)?;
        }
        if !self.load_balancer_source_ranges.is_empty() {
            struct_ser.serialize_field("loadBalancerSourceRanges", &self.load_balancer_source_ranges)?;
        }
        if let Some(v) = self.external_name.as_ref() {
            struct_ser.serialize_field("externalName", v)?;
        }
        if let Some(v) = self.external_traffic_policy.as_ref() {
            struct_ser.serialize_field("externalTrafficPolicy", v)?;
        }
        if let Some(v) = self.health_check_node_port.as_ref() {
            struct_ser.serialize_field("healthCheckNodePort", v)?;
        }
        if let Some(v) = self.publish_not_ready_addresses.as_ref() {
            struct_ser.serialize_field("publishNotReadyAddresses", v)?;
        }
        if let Some(v) = self.session_affinity_config.as_ref() {
            struct_ser.serialize_field("sessionAffinityConfig", v)?;
        }
        if !self.ip_families.is_empty() {
            struct_ser.serialize_field("ipFamilies", &self.ip_families)?;
        }
        if let Some(v) = self.ip_family_policy.as_ref() {
            struct_ser.serialize_field("ipFamilyPolicy", v)?;
        }
        if let Some(v) = self.allocate_load_balancer_node_ports.as_ref() {
            struct_ser.serialize_field("allocateLoadBalancerNodePorts", v)?;
        }
        if let Some(v) = self.load_balancer_class.as_ref() {
            struct_ser.serialize_field("loadBalancerClass", v)?;
        }
        if let Some(v) = self.internal_traffic_policy.as_ref() {
            struct_ser.serialize_field("internalTrafficPolicy", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceSpec {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ports",
            "selector",
            "clusterIP",
            "clusterIPs",
            "type",
            "externalIPs",
            "sessionAffinity",
            "loadBalancerIP",
            "loadBalancerSourceRanges",
            "externalName",
            "externalTrafficPolicy",
            "healthCheckNodePort",
            "publishNotReadyAddresses",
            "sessionAffinityConfig",
            "ipFamilies",
            "ipFamilyPolicy",
            "allocateLoadBalancerNodePorts",
            "loadBalancerClass",
            "internalTrafficPolicy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ports,
            Selector,
            ClusterIp,
            ClusterIPs,
            Type,
            ExternalIPs,
            SessionAffinity,
            LoadBalancerIp,
            LoadBalancerSourceRanges,
            ExternalName,
            ExternalTrafficPolicy,
            HealthCheckNodePort,
            PublishNotReadyAddresses,
            SessionAffinityConfig,
            IpFamilies,
            IpFamilyPolicy,
            AllocateLoadBalancerNodePorts,
            LoadBalancerClass,
            InternalTrafficPolicy,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ports" => Ok(GeneratedField::Ports),
                            "selector" => Ok(GeneratedField::Selector),
                            "clusterIP" => Ok(GeneratedField::ClusterIp),
                            "clusterIPs" => Ok(GeneratedField::ClusterIPs),
                            "type" => Ok(GeneratedField::Type),
                            "externalIPs" => Ok(GeneratedField::ExternalIPs),
                            "sessionAffinity" => Ok(GeneratedField::SessionAffinity),
                            "loadBalancerIP" => Ok(GeneratedField::LoadBalancerIp),
                            "loadBalancerSourceRanges" => Ok(GeneratedField::LoadBalancerSourceRanges),
                            "externalName" => Ok(GeneratedField::ExternalName),
                            "externalTrafficPolicy" => Ok(GeneratedField::ExternalTrafficPolicy),
                            "healthCheckNodePort" => Ok(GeneratedField::HealthCheckNodePort),
                            "publishNotReadyAddresses" => Ok(GeneratedField::PublishNotReadyAddresses),
                            "sessionAffinityConfig" => Ok(GeneratedField::SessionAffinityConfig),
                            "ipFamilies" => Ok(GeneratedField::IpFamilies),
                            "ipFamilyPolicy" => Ok(GeneratedField::IpFamilyPolicy),
                            "allocateLoadBalancerNodePorts" => Ok(GeneratedField::AllocateLoadBalancerNodePorts),
                            "loadBalancerClass" => Ok(GeneratedField::LoadBalancerClass),
                            "internalTrafficPolicy" => Ok(GeneratedField::InternalTrafficPolicy),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceSpec;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceSpec")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceSpec, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ports__ = None;
                let mut selector__ = None;
                let mut cluster_ip__ = None;
                let mut cluster_i_ps__ = None;
                let mut r#type__ = None;
                let mut external_i_ps__ = None;
                let mut session_affinity__ = None;
                let mut load_balancer_ip__ = None;
                let mut load_balancer_source_ranges__ = None;
                let mut external_name__ = None;
                let mut external_traffic_policy__ = None;
                let mut health_check_node_port__ = None;
                let mut publish_not_ready_addresses__ = None;
                let mut session_affinity_config__ = None;
                let mut ip_families__ = None;
                let mut ip_family_policy__ = None;
                let mut allocate_load_balancer_node_ports__ = None;
                let mut load_balancer_class__ = None;
                let mut internal_traffic_policy__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Ports => {
                            if ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ports"));
                            }
                            ports__ = Some(map.next_value()?);
                        }
                        GeneratedField::Selector => {
                            if selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selector"));
                            }
                            selector__ = Some(
                                map.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::ClusterIp => {
                            if cluster_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clusterIP"));
                            }
                            cluster_ip__ = map.next_value()?;
                        }
                        GeneratedField::ClusterIPs => {
                            if cluster_i_ps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clusterIPs"));
                            }
                            cluster_i_ps__ = Some(map.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map.next_value()?;
                        }
                        GeneratedField::ExternalIPs => {
                            if external_i_ps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("externalIPs"));
                            }
                            external_i_ps__ = Some(map.next_value()?);
                        }
                        GeneratedField::SessionAffinity => {
                            if session_affinity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionAffinity"));
                            }
                            session_affinity__ = map.next_value()?;
                        }
                        GeneratedField::LoadBalancerIp => {
                            if load_balancer_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loadBalancerIP"));
                            }
                            load_balancer_ip__ = map.next_value()?;
                        }
                        GeneratedField::LoadBalancerSourceRanges => {
                            if load_balancer_source_ranges__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loadBalancerSourceRanges"));
                            }
                            load_balancer_source_ranges__ = Some(map.next_value()?);
                        }
                        GeneratedField::ExternalName => {
                            if external_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("externalName"));
                            }
                            external_name__ = map.next_value()?;
                        }
                        GeneratedField::ExternalTrafficPolicy => {
                            if external_traffic_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("externalTrafficPolicy"));
                            }
                            external_traffic_policy__ = map.next_value()?;
                        }
                        GeneratedField::HealthCheckNodePort => {
                            if health_check_node_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("healthCheckNodePort"));
                            }
                            health_check_node_port__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PublishNotReadyAddresses => {
                            if publish_not_ready_addresses__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publishNotReadyAddresses"));
                            }
                            publish_not_ready_addresses__ = map.next_value()?;
                        }
                        GeneratedField::SessionAffinityConfig => {
                            if session_affinity_config__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionAffinityConfig"));
                            }
                            session_affinity_config__ = map.next_value()?;
                        }
                        GeneratedField::IpFamilies => {
                            if ip_families__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ipFamilies"));
                            }
                            ip_families__ = Some(map.next_value()?);
                        }
                        GeneratedField::IpFamilyPolicy => {
                            if ip_family_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ipFamilyPolicy"));
                            }
                            ip_family_policy__ = map.next_value()?;
                        }
                        GeneratedField::AllocateLoadBalancerNodePorts => {
                            if allocate_load_balancer_node_ports__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allocateLoadBalancerNodePorts"));
                            }
                            allocate_load_balancer_node_ports__ = map.next_value()?;
                        }
                        GeneratedField::LoadBalancerClass => {
                            if load_balancer_class__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loadBalancerClass"));
                            }
                            load_balancer_class__ = map.next_value()?;
                        }
                        GeneratedField::InternalTrafficPolicy => {
                            if internal_traffic_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("internalTrafficPolicy"));
                            }
                            internal_traffic_policy__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceSpec {
                    ports: ports__.unwrap_or_default(),
                    selector: selector__.unwrap_or_default(),
                    cluster_ip: cluster_ip__,
                    cluster_i_ps: cluster_i_ps__.unwrap_or_default(),
                    r#type: r#type__,
                    external_i_ps: external_i_ps__.unwrap_or_default(),
                    session_affinity: session_affinity__,
                    load_balancer_ip: load_balancer_ip__,
                    load_balancer_source_ranges: load_balancer_source_ranges__.unwrap_or_default(),
                    external_name: external_name__,
                    external_traffic_policy: external_traffic_policy__,
                    health_check_node_port: health_check_node_port__,
                    publish_not_ready_addresses: publish_not_ready_addresses__,
                    session_affinity_config: session_affinity_config__,
                    ip_families: ip_families__.unwrap_or_default(),
                    ip_family_policy: ip_family_policy__,
                    allocate_load_balancer_node_ports: allocate_load_balancer_node_ports__,
                    load_balancer_class: load_balancer_class__,
                    internal_traffic_policy: internal_traffic_policy__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceSpec", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServiceStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.load_balancer.is_some() {
            len += 1;
        }
        if !self.conditions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.ServiceStatus", len)?;
        if let Some(v) = self.load_balancer.as_ref() {
            struct_ser.serialize_field("loadBalancer", v)?;
        }
        if !self.conditions.is_empty() {
            struct_ser.serialize_field("conditions", &self.conditions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServiceStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "loadBalancer",
            "conditions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LoadBalancer,
            Conditions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "loadBalancer" => Ok(GeneratedField::LoadBalancer),
                            "conditions" => Ok(GeneratedField::Conditions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServiceStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.ServiceStatus")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<ServiceStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut load_balancer__ = None;
                let mut conditions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::LoadBalancer => {
                            if load_balancer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loadBalancer"));
                            }
                            load_balancer__ = map.next_value()?;
                        }
                        GeneratedField::Conditions => {
                            if conditions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conditions"));
                            }
                            conditions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ServiceStatus {
                    load_balancer: load_balancer__,
                    conditions: conditions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.ServiceStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SessionAffinityConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.client_ip.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.SessionAffinityConfig", len)?;
        if let Some(v) = self.client_ip.as_ref() {
            struct_ser.serialize_field("clientIP", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SessionAffinityConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "clientIP",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClientIp,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "clientIP" => Ok(GeneratedField::ClientIp),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SessionAffinityConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.SessionAffinityConfig")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<SessionAffinityConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut client_ip__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ClientIp => {
                            if client_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clientIP"));
                            }
                            client_ip__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SessionAffinityConfig {
                    client_ip: client_ip__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.SessionAffinityConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StorageOsPersistentVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_name.is_some() {
            len += 1;
        }
        if self.volume_namespace.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.StorageOSPersistentVolumeSource", len)?;
        if let Some(v) = self.volume_name.as_ref() {
            struct_ser.serialize_field("volumeName", v)?;
        }
        if let Some(v) = self.volume_namespace.as_ref() {
            struct_ser.serialize_field("volumeNamespace", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StorageOsPersistentVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeName",
            "volumeNamespace",
            "fsType",
            "readOnly",
            "secretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeName,
            VolumeNamespace,
            FsType,
            ReadOnly,
            SecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeName" => Ok(GeneratedField::VolumeName),
                            "volumeNamespace" => Ok(GeneratedField::VolumeNamespace),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StorageOsPersistentVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.StorageOSPersistentVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<StorageOsPersistentVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_name__ = None;
                let mut volume_namespace__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeName => {
                            if volume_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeName"));
                            }
                            volume_name__ = map.next_value()?;
                        }
                        GeneratedField::VolumeNamespace => {
                            if volume_namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeNamespace"));
                            }
                            volume_namespace__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(StorageOsPersistentVolumeSource {
                    volume_name: volume_name__,
                    volume_namespace: volume_namespace__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    secret_ref: secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.StorageOSPersistentVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StorageOsVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_name.is_some() {
            len += 1;
        }
        if self.volume_namespace.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.secret_ref.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.StorageOSVolumeSource", len)?;
        if let Some(v) = self.volume_name.as_ref() {
            struct_ser.serialize_field("volumeName", v)?;
        }
        if let Some(v) = self.volume_namespace.as_ref() {
            struct_ser.serialize_field("volumeNamespace", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.secret_ref.as_ref() {
            struct_ser.serialize_field("secretRef", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StorageOsVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumeName",
            "volumeNamespace",
            "fsType",
            "readOnly",
            "secretRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeName,
            VolumeNamespace,
            FsType,
            ReadOnly,
            SecretRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeName" => Ok(GeneratedField::VolumeName),
                            "volumeNamespace" => Ok(GeneratedField::VolumeNamespace),
                            "fsType" => Ok(GeneratedField::FsType),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "secretRef" => Ok(GeneratedField::SecretRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StorageOsVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.StorageOSVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<StorageOsVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_name__ = None;
                let mut volume_namespace__ = None;
                let mut fs_type__ = None;
                let mut read_only__ = None;
                let mut secret_ref__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumeName => {
                            if volume_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeName"));
                            }
                            volume_name__ = map.next_value()?;
                        }
                        GeneratedField::VolumeNamespace => {
                            if volume_namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeNamespace"));
                            }
                            volume_namespace__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::SecretRef => {
                            if secret_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secretRef"));
                            }
                            secret_ref__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(StorageOsVolumeSource {
                    volume_name: volume_name__,
                    volume_namespace: volume_namespace__,
                    fs_type: fs_type__,
                    read_only: read_only__,
                    secret_ref: secret_ref__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.StorageOSVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Sysctl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Sysctl", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Sysctl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Sysctl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Sysctl")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Sysctl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Sysctl {
                    name: name__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Sysctl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TcpSocketAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.port.is_some() {
            len += 1;
        }
        if self.host.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TCPSocketAction", len)?;
        if let Some(v) = self.port.as_ref() {
            struct_ser.serialize_field("port", v)?;
        }
        if let Some(v) = self.host.as_ref() {
            struct_ser.serialize_field("host", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TcpSocketAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "port",
            "host",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Port,
            Host,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "port" => Ok(GeneratedField::Port),
                            "host" => Ok(GeneratedField::Host),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TcpSocketAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TCPSocketAction")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TcpSocketAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut port__ = None;
                let mut host__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Port => {
                            if port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("port"));
                            }
                            port__ = map.next_value()?;
                        }
                        GeneratedField::Host => {
                            if host__.is_some() {
                                return Err(serde::de::Error::duplicate_field("host"));
                            }
                            host__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TcpSocketAction {
                    port: port__,
                    host: host__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TCPSocketAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Taint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.effect.is_some() {
            len += 1;
        }
        if self.time_added.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Taint", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            struct_ser.serialize_field("effect", v)?;
        }
        if let Some(v) = self.time_added.as_ref() {
            struct_ser.serialize_field("timeAdded", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Taint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
            "effect",
            "timeAdded",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
            Effect,
            TimeAdded,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            "effect" => Ok(GeneratedField::Effect),
                            "timeAdded" => Ok(GeneratedField::TimeAdded),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Taint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Taint")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Taint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                let mut effect__ = None;
                let mut time_added__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::Effect => {
                            if effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effect"));
                            }
                            effect__ = map.next_value()?;
                        }
                        GeneratedField::TimeAdded => {
                            if time_added__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timeAdded"));
                            }
                            time_added__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Taint {
                    key: key__,
                    value: value__,
                    effect: effect__,
                    time_added: time_added__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Taint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Toleration {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if self.operator.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.effect.is_some() {
            len += 1;
        }
        if self.toleration_seconds.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Toleration", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if let Some(v) = self.operator.as_ref() {
            struct_ser.serialize_field("operator", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if let Some(v) = self.effect.as_ref() {
            struct_ser.serialize_field("effect", v)?;
        }
        if let Some(v) = self.toleration_seconds.as_ref() {
            struct_ser.serialize_field("tolerationSeconds", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Toleration {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "operator",
            "value",
            "effect",
            "tolerationSeconds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Operator,
            Value,
            Effect,
            TolerationSeconds,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "operator" => Ok(GeneratedField::Operator),
                            "value" => Ok(GeneratedField::Value),
                            "effect" => Ok(GeneratedField::Effect),
                            "tolerationSeconds" => Ok(GeneratedField::TolerationSeconds),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Toleration;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Toleration")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Toleration, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut operator__ = None;
                let mut value__ = None;
                let mut effect__ = None;
                let mut toleration_seconds__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Operator => {
                            if operator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operator"));
                            }
                            operator__ = map.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map.next_value()?;
                        }
                        GeneratedField::Effect => {
                            if effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effect"));
                            }
                            effect__ = map.next_value()?;
                        }
                        GeneratedField::TolerationSeconds => {
                            if toleration_seconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tolerationSeconds"));
                            }
                            toleration_seconds__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Toleration {
                    key: key__,
                    operator: operator__,
                    value: value__,
                    effect: effect__,
                    toleration_seconds: toleration_seconds__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Toleration", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TopologySelectorLabelRequirement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key.is_some() {
            len += 1;
        }
        if !self.values.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TopologySelectorLabelRequirement", len)?;
        if let Some(v) = self.key.as_ref() {
            struct_ser.serialize_field("key", v)?;
        }
        if !self.values.is_empty() {
            struct_ser.serialize_field("values", &self.values)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TopologySelectorLabelRequirement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "values",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Values,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "values" => Ok(GeneratedField::Values),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TopologySelectorLabelRequirement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TopologySelectorLabelRequirement")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TopologySelectorLabelRequirement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut values__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = map.next_value()?;
                        }
                        GeneratedField::Values => {
                            if values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("values"));
                            }
                            values__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TopologySelectorLabelRequirement {
                    key: key__,
                    values: values__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TopologySelectorLabelRequirement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TopologySelectorTerm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.match_label_expressions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TopologySelectorTerm", len)?;
        if !self.match_label_expressions.is_empty() {
            struct_ser.serialize_field("matchLabelExpressions", &self.match_label_expressions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TopologySelectorTerm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "matchLabelExpressions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MatchLabelExpressions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "matchLabelExpressions" => Ok(GeneratedField::MatchLabelExpressions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TopologySelectorTerm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TopologySelectorTerm")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TopologySelectorTerm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut match_label_expressions__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::MatchLabelExpressions => {
                            if match_label_expressions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matchLabelExpressions"));
                            }
                            match_label_expressions__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TopologySelectorTerm {
                    match_label_expressions: match_label_expressions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TopologySelectorTerm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TopologySpreadConstraint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.max_skew.is_some() {
            len += 1;
        }
        if self.topology_key.is_some() {
            len += 1;
        }
        if self.when_unsatisfiable.is_some() {
            len += 1;
        }
        if self.label_selector.is_some() {
            len += 1;
        }
        if self.min_domains.is_some() {
            len += 1;
        }
        if self.node_affinity_policy.is_some() {
            len += 1;
        }
        if self.node_taints_policy.is_some() {
            len += 1;
        }
        if !self.match_label_keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TopologySpreadConstraint", len)?;
        if let Some(v) = self.max_skew.as_ref() {
            struct_ser.serialize_field("maxSkew", v)?;
        }
        if let Some(v) = self.topology_key.as_ref() {
            struct_ser.serialize_field("topologyKey", v)?;
        }
        if let Some(v) = self.when_unsatisfiable.as_ref() {
            struct_ser.serialize_field("whenUnsatisfiable", v)?;
        }
        if let Some(v) = self.label_selector.as_ref() {
            struct_ser.serialize_field("labelSelector", v)?;
        }
        if let Some(v) = self.min_domains.as_ref() {
            struct_ser.serialize_field("minDomains", v)?;
        }
        if let Some(v) = self.node_affinity_policy.as_ref() {
            struct_ser.serialize_field("nodeAffinityPolicy", v)?;
        }
        if let Some(v) = self.node_taints_policy.as_ref() {
            struct_ser.serialize_field("nodeTaintsPolicy", v)?;
        }
        if !self.match_label_keys.is_empty() {
            struct_ser.serialize_field("matchLabelKeys", &self.match_label_keys)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TopologySpreadConstraint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "maxSkew",
            "topologyKey",
            "whenUnsatisfiable",
            "labelSelector",
            "minDomains",
            "nodeAffinityPolicy",
            "nodeTaintsPolicy",
            "matchLabelKeys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MaxSkew,
            TopologyKey,
            WhenUnsatisfiable,
            LabelSelector,
            MinDomains,
            NodeAffinityPolicy,
            NodeTaintsPolicy,
            MatchLabelKeys,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "maxSkew" => Ok(GeneratedField::MaxSkew),
                            "topologyKey" => Ok(GeneratedField::TopologyKey),
                            "whenUnsatisfiable" => Ok(GeneratedField::WhenUnsatisfiable),
                            "labelSelector" => Ok(GeneratedField::LabelSelector),
                            "minDomains" => Ok(GeneratedField::MinDomains),
                            "nodeAffinityPolicy" => Ok(GeneratedField::NodeAffinityPolicy),
                            "nodeTaintsPolicy" => Ok(GeneratedField::NodeTaintsPolicy),
                            "matchLabelKeys" => Ok(GeneratedField::MatchLabelKeys),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TopologySpreadConstraint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TopologySpreadConstraint")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TopologySpreadConstraint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut max_skew__ = None;
                let mut topology_key__ = None;
                let mut when_unsatisfiable__ = None;
                let mut label_selector__ = None;
                let mut min_domains__ = None;
                let mut node_affinity_policy__ = None;
                let mut node_taints_policy__ = None;
                let mut match_label_keys__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::MaxSkew => {
                            if max_skew__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxSkew"));
                            }
                            max_skew__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TopologyKey => {
                            if topology_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("topologyKey"));
                            }
                            topology_key__ = map.next_value()?;
                        }
                        GeneratedField::WhenUnsatisfiable => {
                            if when_unsatisfiable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("whenUnsatisfiable"));
                            }
                            when_unsatisfiable__ = map.next_value()?;
                        }
                        GeneratedField::LabelSelector => {
                            if label_selector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("labelSelector"));
                            }
                            label_selector__ = map.next_value()?;
                        }
                        GeneratedField::MinDomains => {
                            if min_domains__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minDomains"));
                            }
                            min_domains__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NodeAffinityPolicy => {
                            if node_affinity_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeAffinityPolicy"));
                            }
                            node_affinity_policy__ = map.next_value()?;
                        }
                        GeneratedField::NodeTaintsPolicy => {
                            if node_taints_policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nodeTaintsPolicy"));
                            }
                            node_taints_policy__ = map.next_value()?;
                        }
                        GeneratedField::MatchLabelKeys => {
                            if match_label_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("matchLabelKeys"));
                            }
                            match_label_keys__ = Some(map.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TopologySpreadConstraint {
                    max_skew: max_skew__,
                    topology_key: topology_key__,
                    when_unsatisfiable: when_unsatisfiable__,
                    label_selector: label_selector__,
                    min_domains: min_domains__,
                    node_affinity_policy: node_affinity_policy__,
                    node_taints_policy: node_taints_policy__,
                    match_label_keys: match_label_keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TopologySpreadConstraint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypedLocalObjectReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.api_group.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TypedLocalObjectReference", len)?;
        if let Some(v) = self.api_group.as_ref() {
            struct_ser.serialize_field("apiGroup", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            struct_ser.serialize_field("kind", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypedLocalObjectReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "apiGroup",
            "kind",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ApiGroup,
            Kind,
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "apiGroup" => Ok(GeneratedField::ApiGroup),
                            "kind" => Ok(GeneratedField::Kind),
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypedLocalObjectReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TypedLocalObjectReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TypedLocalObjectReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut api_group__ = None;
                let mut kind__ = None;
                let mut name__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ApiGroup => {
                            if api_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apiGroup"));
                            }
                            api_group__ = map.next_value()?;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TypedLocalObjectReference {
                    api_group: api_group__,
                    kind: kind__,
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TypedLocalObjectReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypedObjectReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.api_group.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.namespace.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.TypedObjectReference", len)?;
        if let Some(v) = self.api_group.as_ref() {
            struct_ser.serialize_field("apiGroup", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            struct_ser.serialize_field("kind", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.namespace.as_ref() {
            struct_ser.serialize_field("namespace", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypedObjectReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "apiGroup",
            "kind",
            "name",
            "namespace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ApiGroup,
            Kind,
            Name,
            Namespace,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "apiGroup" => Ok(GeneratedField::ApiGroup),
                            "kind" => Ok(GeneratedField::Kind),
                            "name" => Ok(GeneratedField::Name),
                            "namespace" => Ok(GeneratedField::Namespace),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypedObjectReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.TypedObjectReference")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TypedObjectReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut api_group__ = None;
                let mut kind__ = None;
                let mut name__ = None;
                let mut namespace__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ApiGroup => {
                            if api_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apiGroup"));
                            }
                            api_group__ = map.next_value()?;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::Namespace => {
                            if namespace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("namespace"));
                            }
                            namespace__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TypedObjectReference {
                    api_group: api_group__,
                    kind: kind__,
                    name: name__,
                    namespace: namespace__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.TypedObjectReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Volume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.volume_source.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.Volume", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.volume_source.as_ref() {
            struct_ser.serialize_field("volumeSource", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Volume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "volumeSource",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            VolumeSource,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "volumeSource" => Ok(GeneratedField::VolumeSource),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Volume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.Volume")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<Volume, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut volume_source__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::VolumeSource => {
                            if volume_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeSource"));
                            }
                            volume_source__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Volume {
                    name: name__,
                    volume_source: volume_source__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.Volume", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VolumeDevice {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.device_path.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VolumeDevice", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.device_path.as_ref() {
            struct_ser.serialize_field("devicePath", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VolumeDevice {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "devicePath",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            DevicePath,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "devicePath" => Ok(GeneratedField::DevicePath),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeDevice;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VolumeDevice")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VolumeDevice, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut device_path__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::DevicePath => {
                            if device_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("devicePath"));
                            }
                            device_path__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VolumeDevice {
                    name: name__,
                    device_path: device_path__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VolumeDevice", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VolumeMount {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.read_only.is_some() {
            len += 1;
        }
        if self.mount_path.is_some() {
            len += 1;
        }
        if self.sub_path.is_some() {
            len += 1;
        }
        if self.mount_propagation.is_some() {
            len += 1;
        }
        if self.sub_path_expr.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VolumeMount", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.read_only.as_ref() {
            struct_ser.serialize_field("readOnly", v)?;
        }
        if let Some(v) = self.mount_path.as_ref() {
            struct_ser.serialize_field("mountPath", v)?;
        }
        if let Some(v) = self.sub_path.as_ref() {
            struct_ser.serialize_field("subPath", v)?;
        }
        if let Some(v) = self.mount_propagation.as_ref() {
            struct_ser.serialize_field("mountPropagation", v)?;
        }
        if let Some(v) = self.sub_path_expr.as_ref() {
            struct_ser.serialize_field("subPathExpr", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VolumeMount {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "readOnly",
            "mountPath",
            "subPath",
            "mountPropagation",
            "subPathExpr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            ReadOnly,
            MountPath,
            SubPath,
            MountPropagation,
            SubPathExpr,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "readOnly" => Ok(GeneratedField::ReadOnly),
                            "mountPath" => Ok(GeneratedField::MountPath),
                            "subPath" => Ok(GeneratedField::SubPath),
                            "mountPropagation" => Ok(GeneratedField::MountPropagation),
                            "subPathExpr" => Ok(GeneratedField::SubPathExpr),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeMount;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VolumeMount")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VolumeMount, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut read_only__ = None;
                let mut mount_path__ = None;
                let mut sub_path__ = None;
                let mut mount_propagation__ = None;
                let mut sub_path_expr__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map.next_value()?;
                        }
                        GeneratedField::ReadOnly => {
                            if read_only__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readOnly"));
                            }
                            read_only__ = map.next_value()?;
                        }
                        GeneratedField::MountPath => {
                            if mount_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mountPath"));
                            }
                            mount_path__ = map.next_value()?;
                        }
                        GeneratedField::SubPath => {
                            if sub_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subPath"));
                            }
                            sub_path__ = map.next_value()?;
                        }
                        GeneratedField::MountPropagation => {
                            if mount_propagation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mountPropagation"));
                            }
                            mount_propagation__ = map.next_value()?;
                        }
                        GeneratedField::SubPathExpr => {
                            if sub_path_expr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subPathExpr"));
                            }
                            sub_path_expr__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VolumeMount {
                    name: name__,
                    read_only: read_only__,
                    mount_path: mount_path__,
                    sub_path: sub_path__,
                    mount_propagation: mount_propagation__,
                    sub_path_expr: sub_path_expr__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VolumeMount", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VolumeNodeAffinity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.required.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VolumeNodeAffinity", len)?;
        if let Some(v) = self.required.as_ref() {
            struct_ser.serialize_field("required", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VolumeNodeAffinity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "required",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Required,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "required" => Ok(GeneratedField::Required),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeNodeAffinity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VolumeNodeAffinity")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VolumeNodeAffinity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut required__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Required => {
                            if required__.is_some() {
                                return Err(serde::de::Error::duplicate_field("required"));
                            }
                            required__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VolumeNodeAffinity {
                    required: required__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VolumeNodeAffinity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VolumeProjection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.secret.is_some() {
            len += 1;
        }
        if self.downward_api.is_some() {
            len += 1;
        }
        if self.config_map.is_some() {
            len += 1;
        }
        if self.service_account_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VolumeProjection", len)?;
        if let Some(v) = self.secret.as_ref() {
            struct_ser.serialize_field("secret", v)?;
        }
        if let Some(v) = self.downward_api.as_ref() {
            struct_ser.serialize_field("downwardAPI", v)?;
        }
        if let Some(v) = self.config_map.as_ref() {
            struct_ser.serialize_field("configMap", v)?;
        }
        if let Some(v) = self.service_account_token.as_ref() {
            struct_ser.serialize_field("serviceAccountToken", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VolumeProjection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "secret",
            "downwardAPI",
            "configMap",
            "serviceAccountToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Secret,
            DownwardApi,
            ConfigMap,
            ServiceAccountToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "secret" => Ok(GeneratedField::Secret),
                            "downwardAPI" => Ok(GeneratedField::DownwardApi),
                            "configMap" => Ok(GeneratedField::ConfigMap),
                            "serviceAccountToken" => Ok(GeneratedField::ServiceAccountToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeProjection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VolumeProjection")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VolumeProjection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut secret__ = None;
                let mut downward_api__ = None;
                let mut config_map__ = None;
                let mut service_account_token__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Secret => {
                            if secret__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secret"));
                            }
                            secret__ = map.next_value()?;
                        }
                        GeneratedField::DownwardApi => {
                            if downward_api__.is_some() {
                                return Err(serde::de::Error::duplicate_field("downwardAPI"));
                            }
                            downward_api__ = map.next_value()?;
                        }
                        GeneratedField::ConfigMap => {
                            if config_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configMap"));
                            }
                            config_map__ = map.next_value()?;
                        }
                        GeneratedField::ServiceAccountToken => {
                            if service_account_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serviceAccountToken"));
                            }
                            service_account_token__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VolumeProjection {
                    secret: secret__,
                    downward_api: downward_api__,
                    config_map: config_map__,
                    service_account_token: service_account_token__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VolumeProjection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.host_path.is_some() {
            len += 1;
        }
        if self.empty_dir.is_some() {
            len += 1;
        }
        if self.gce_persistent_disk.is_some() {
            len += 1;
        }
        if self.aws_elastic_block_store.is_some() {
            len += 1;
        }
        if self.git_repo.is_some() {
            len += 1;
        }
        if self.secret.is_some() {
            len += 1;
        }
        if self.nfs.is_some() {
            len += 1;
        }
        if self.iscsi.is_some() {
            len += 1;
        }
        if self.glusterfs.is_some() {
            len += 1;
        }
        if self.persistent_volume_claim.is_some() {
            len += 1;
        }
        if self.rbd.is_some() {
            len += 1;
        }
        if self.flex_volume.is_some() {
            len += 1;
        }
        if self.cinder.is_some() {
            len += 1;
        }
        if self.cephfs.is_some() {
            len += 1;
        }
        if self.flocker.is_some() {
            len += 1;
        }
        if self.downward_api.is_some() {
            len += 1;
        }
        if self.fc.is_some() {
            len += 1;
        }
        if self.azure_file.is_some() {
            len += 1;
        }
        if self.config_map.is_some() {
            len += 1;
        }
        if self.vsphere_volume.is_some() {
            len += 1;
        }
        if self.quobyte.is_some() {
            len += 1;
        }
        if self.azure_disk.is_some() {
            len += 1;
        }
        if self.photon_persistent_disk.is_some() {
            len += 1;
        }
        if self.projected.is_some() {
            len += 1;
        }
        if self.portworx_volume.is_some() {
            len += 1;
        }
        if self.scale_io.is_some() {
            len += 1;
        }
        if self.storageos.is_some() {
            len += 1;
        }
        if self.csi.is_some() {
            len += 1;
        }
        if self.ephemeral.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VolumeSource", len)?;
        if let Some(v) = self.host_path.as_ref() {
            struct_ser.serialize_field("hostPath", v)?;
        }
        if let Some(v) = self.empty_dir.as_ref() {
            struct_ser.serialize_field("emptyDir", v)?;
        }
        if let Some(v) = self.gce_persistent_disk.as_ref() {
            struct_ser.serialize_field("gcePersistentDisk", v)?;
        }
        if let Some(v) = self.aws_elastic_block_store.as_ref() {
            struct_ser.serialize_field("awsElasticBlockStore", v)?;
        }
        if let Some(v) = self.git_repo.as_ref() {
            struct_ser.serialize_field("gitRepo", v)?;
        }
        if let Some(v) = self.secret.as_ref() {
            struct_ser.serialize_field("secret", v)?;
        }
        if let Some(v) = self.nfs.as_ref() {
            struct_ser.serialize_field("nfs", v)?;
        }
        if let Some(v) = self.iscsi.as_ref() {
            struct_ser.serialize_field("iscsi", v)?;
        }
        if let Some(v) = self.glusterfs.as_ref() {
            struct_ser.serialize_field("glusterfs", v)?;
        }
        if let Some(v) = self.persistent_volume_claim.as_ref() {
            struct_ser.serialize_field("persistentVolumeClaim", v)?;
        }
        if let Some(v) = self.rbd.as_ref() {
            struct_ser.serialize_field("rbd", v)?;
        }
        if let Some(v) = self.flex_volume.as_ref() {
            struct_ser.serialize_field("flexVolume", v)?;
        }
        if let Some(v) = self.cinder.as_ref() {
            struct_ser.serialize_field("cinder", v)?;
        }
        if let Some(v) = self.cephfs.as_ref() {
            struct_ser.serialize_field("cephfs", v)?;
        }
        if let Some(v) = self.flocker.as_ref() {
            struct_ser.serialize_field("flocker", v)?;
        }
        if let Some(v) = self.downward_api.as_ref() {
            struct_ser.serialize_field("downwardAPI", v)?;
        }
        if let Some(v) = self.fc.as_ref() {
            struct_ser.serialize_field("fc", v)?;
        }
        if let Some(v) = self.azure_file.as_ref() {
            struct_ser.serialize_field("azureFile", v)?;
        }
        if let Some(v) = self.config_map.as_ref() {
            struct_ser.serialize_field("configMap", v)?;
        }
        if let Some(v) = self.vsphere_volume.as_ref() {
            struct_ser.serialize_field("vsphereVolume", v)?;
        }
        if let Some(v) = self.quobyte.as_ref() {
            struct_ser.serialize_field("quobyte", v)?;
        }
        if let Some(v) = self.azure_disk.as_ref() {
            struct_ser.serialize_field("azureDisk", v)?;
        }
        if let Some(v) = self.photon_persistent_disk.as_ref() {
            struct_ser.serialize_field("photonPersistentDisk", v)?;
        }
        if let Some(v) = self.projected.as_ref() {
            struct_ser.serialize_field("projected", v)?;
        }
        if let Some(v) = self.portworx_volume.as_ref() {
            struct_ser.serialize_field("portworxVolume", v)?;
        }
        if let Some(v) = self.scale_io.as_ref() {
            struct_ser.serialize_field("scaleIO", v)?;
        }
        if let Some(v) = self.storageos.as_ref() {
            struct_ser.serialize_field("storageos", v)?;
        }
        if let Some(v) = self.csi.as_ref() {
            struct_ser.serialize_field("csi", v)?;
        }
        if let Some(v) = self.ephemeral.as_ref() {
            struct_ser.serialize_field("ephemeral", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hostPath",
            "emptyDir",
            "gcePersistentDisk",
            "awsElasticBlockStore",
            "gitRepo",
            "secret",
            "nfs",
            "iscsi",
            "glusterfs",
            "persistentVolumeClaim",
            "rbd",
            "flexVolume",
            "cinder",
            "cephfs",
            "flocker",
            "downwardAPI",
            "fc",
            "azureFile",
            "configMap",
            "vsphereVolume",
            "quobyte",
            "azureDisk",
            "photonPersistentDisk",
            "projected",
            "portworxVolume",
            "scaleIO",
            "storageos",
            "csi",
            "ephemeral",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HostPath,
            EmptyDir,
            GcePersistentDisk,
            AwsElasticBlockStore,
            GitRepo,
            Secret,
            Nfs,
            Iscsi,
            Glusterfs,
            PersistentVolumeClaim,
            Rbd,
            FlexVolume,
            Cinder,
            Cephfs,
            Flocker,
            DownwardApi,
            Fc,
            AzureFile,
            ConfigMap,
            VsphereVolume,
            Quobyte,
            AzureDisk,
            PhotonPersistentDisk,
            Projected,
            PortworxVolume,
            ScaleIo,
            Storageos,
            Csi,
            Ephemeral,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hostPath" => Ok(GeneratedField::HostPath),
                            "emptyDir" => Ok(GeneratedField::EmptyDir),
                            "gcePersistentDisk" => Ok(GeneratedField::GcePersistentDisk),
                            "awsElasticBlockStore" => Ok(GeneratedField::AwsElasticBlockStore),
                            "gitRepo" => Ok(GeneratedField::GitRepo),
                            "secret" => Ok(GeneratedField::Secret),
                            "nfs" => Ok(GeneratedField::Nfs),
                            "iscsi" => Ok(GeneratedField::Iscsi),
                            "glusterfs" => Ok(GeneratedField::Glusterfs),
                            "persistentVolumeClaim" => Ok(GeneratedField::PersistentVolumeClaim),
                            "rbd" => Ok(GeneratedField::Rbd),
                            "flexVolume" => Ok(GeneratedField::FlexVolume),
                            "cinder" => Ok(GeneratedField::Cinder),
                            "cephfs" => Ok(GeneratedField::Cephfs),
                            "flocker" => Ok(GeneratedField::Flocker),
                            "downwardAPI" => Ok(GeneratedField::DownwardApi),
                            "fc" => Ok(GeneratedField::Fc),
                            "azureFile" => Ok(GeneratedField::AzureFile),
                            "configMap" => Ok(GeneratedField::ConfigMap),
                            "vsphereVolume" => Ok(GeneratedField::VsphereVolume),
                            "quobyte" => Ok(GeneratedField::Quobyte),
                            "azureDisk" => Ok(GeneratedField::AzureDisk),
                            "photonPersistentDisk" => Ok(GeneratedField::PhotonPersistentDisk),
                            "projected" => Ok(GeneratedField::Projected),
                            "portworxVolume" => Ok(GeneratedField::PortworxVolume),
                            "scaleIO" => Ok(GeneratedField::ScaleIo),
                            "storageos" => Ok(GeneratedField::Storageos),
                            "csi" => Ok(GeneratedField::Csi),
                            "ephemeral" => Ok(GeneratedField::Ephemeral),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut host_path__ = None;
                let mut empty_dir__ = None;
                let mut gce_persistent_disk__ = None;
                let mut aws_elastic_block_store__ = None;
                let mut git_repo__ = None;
                let mut secret__ = None;
                let mut nfs__ = None;
                let mut iscsi__ = None;
                let mut glusterfs__ = None;
                let mut persistent_volume_claim__ = None;
                let mut rbd__ = None;
                let mut flex_volume__ = None;
                let mut cinder__ = None;
                let mut cephfs__ = None;
                let mut flocker__ = None;
                let mut downward_api__ = None;
                let mut fc__ = None;
                let mut azure_file__ = None;
                let mut config_map__ = None;
                let mut vsphere_volume__ = None;
                let mut quobyte__ = None;
                let mut azure_disk__ = None;
                let mut photon_persistent_disk__ = None;
                let mut projected__ = None;
                let mut portworx_volume__ = None;
                let mut scale_io__ = None;
                let mut storageos__ = None;
                let mut csi__ = None;
                let mut ephemeral__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::HostPath => {
                            if host_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostPath"));
                            }
                            host_path__ = map.next_value()?;
                        }
                        GeneratedField::EmptyDir => {
                            if empty_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("emptyDir"));
                            }
                            empty_dir__ = map.next_value()?;
                        }
                        GeneratedField::GcePersistentDisk => {
                            if gce_persistent_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gcePersistentDisk"));
                            }
                            gce_persistent_disk__ = map.next_value()?;
                        }
                        GeneratedField::AwsElasticBlockStore => {
                            if aws_elastic_block_store__.is_some() {
                                return Err(serde::de::Error::duplicate_field("awsElasticBlockStore"));
                            }
                            aws_elastic_block_store__ = map.next_value()?;
                        }
                        GeneratedField::GitRepo => {
                            if git_repo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gitRepo"));
                            }
                            git_repo__ = map.next_value()?;
                        }
                        GeneratedField::Secret => {
                            if secret__.is_some() {
                                return Err(serde::de::Error::duplicate_field("secret"));
                            }
                            secret__ = map.next_value()?;
                        }
                        GeneratedField::Nfs => {
                            if nfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nfs"));
                            }
                            nfs__ = map.next_value()?;
                        }
                        GeneratedField::Iscsi => {
                            if iscsi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iscsi"));
                            }
                            iscsi__ = map.next_value()?;
                        }
                        GeneratedField::Glusterfs => {
                            if glusterfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("glusterfs"));
                            }
                            glusterfs__ = map.next_value()?;
                        }
                        GeneratedField::PersistentVolumeClaim => {
                            if persistent_volume_claim__.is_some() {
                                return Err(serde::de::Error::duplicate_field("persistentVolumeClaim"));
                            }
                            persistent_volume_claim__ = map.next_value()?;
                        }
                        GeneratedField::Rbd => {
                            if rbd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rbd"));
                            }
                            rbd__ = map.next_value()?;
                        }
                        GeneratedField::FlexVolume => {
                            if flex_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("flexVolume"));
                            }
                            flex_volume__ = map.next_value()?;
                        }
                        GeneratedField::Cinder => {
                            if cinder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cinder"));
                            }
                            cinder__ = map.next_value()?;
                        }
                        GeneratedField::Cephfs => {
                            if cephfs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cephfs"));
                            }
                            cephfs__ = map.next_value()?;
                        }
                        GeneratedField::Flocker => {
                            if flocker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("flocker"));
                            }
                            flocker__ = map.next_value()?;
                        }
                        GeneratedField::DownwardApi => {
                            if downward_api__.is_some() {
                                return Err(serde::de::Error::duplicate_field("downwardAPI"));
                            }
                            downward_api__ = map.next_value()?;
                        }
                        GeneratedField::Fc => {
                            if fc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fc"));
                            }
                            fc__ = map.next_value()?;
                        }
                        GeneratedField::AzureFile => {
                            if azure_file__.is_some() {
                                return Err(serde::de::Error::duplicate_field("azureFile"));
                            }
                            azure_file__ = map.next_value()?;
                        }
                        GeneratedField::ConfigMap => {
                            if config_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("configMap"));
                            }
                            config_map__ = map.next_value()?;
                        }
                        GeneratedField::VsphereVolume => {
                            if vsphere_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vsphereVolume"));
                            }
                            vsphere_volume__ = map.next_value()?;
                        }
                        GeneratedField::Quobyte => {
                            if quobyte__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quobyte"));
                            }
                            quobyte__ = map.next_value()?;
                        }
                        GeneratedField::AzureDisk => {
                            if azure_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("azureDisk"));
                            }
                            azure_disk__ = map.next_value()?;
                        }
                        GeneratedField::PhotonPersistentDisk => {
                            if photon_persistent_disk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("photonPersistentDisk"));
                            }
                            photon_persistent_disk__ = map.next_value()?;
                        }
                        GeneratedField::Projected => {
                            if projected__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projected"));
                            }
                            projected__ = map.next_value()?;
                        }
                        GeneratedField::PortworxVolume => {
                            if portworx_volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("portworxVolume"));
                            }
                            portworx_volume__ = map.next_value()?;
                        }
                        GeneratedField::ScaleIo => {
                            if scale_io__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scaleIO"));
                            }
                            scale_io__ = map.next_value()?;
                        }
                        GeneratedField::Storageos => {
                            if storageos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageos"));
                            }
                            storageos__ = map.next_value()?;
                        }
                        GeneratedField::Csi => {
                            if csi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("csi"));
                            }
                            csi__ = map.next_value()?;
                        }
                        GeneratedField::Ephemeral => {
                            if ephemeral__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ephemeral"));
                            }
                            ephemeral__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VolumeSource {
                    host_path: host_path__,
                    empty_dir: empty_dir__,
                    gce_persistent_disk: gce_persistent_disk__,
                    aws_elastic_block_store: aws_elastic_block_store__,
                    git_repo: git_repo__,
                    secret: secret__,
                    nfs: nfs__,
                    iscsi: iscsi__,
                    glusterfs: glusterfs__,
                    persistent_volume_claim: persistent_volume_claim__,
                    rbd: rbd__,
                    flex_volume: flex_volume__,
                    cinder: cinder__,
                    cephfs: cephfs__,
                    flocker: flocker__,
                    downward_api: downward_api__,
                    fc: fc__,
                    azure_file: azure_file__,
                    config_map: config_map__,
                    vsphere_volume: vsphere_volume__,
                    quobyte: quobyte__,
                    azure_disk: azure_disk__,
                    photon_persistent_disk: photon_persistent_disk__,
                    projected: projected__,
                    portworx_volume: portworx_volume__,
                    scale_io: scale_io__,
                    storageos: storageos__,
                    csi: csi__,
                    ephemeral: ephemeral__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VsphereVirtualDiskVolumeSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.volume_path.is_some() {
            len += 1;
        }
        if self.fs_type.is_some() {
            len += 1;
        }
        if self.storage_policy_name.is_some() {
            len += 1;
        }
        if self.storage_policy_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource", len)?;
        if let Some(v) = self.volume_path.as_ref() {
            struct_ser.serialize_field("volumePath", v)?;
        }
        if let Some(v) = self.fs_type.as_ref() {
            struct_ser.serialize_field("fsType", v)?;
        }
        if let Some(v) = self.storage_policy_name.as_ref() {
            struct_ser.serialize_field("storagePolicyName", v)?;
        }
        if let Some(v) = self.storage_policy_id.as_ref() {
            struct_ser.serialize_field("storagePolicyID", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VsphereVirtualDiskVolumeSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volumePath",
            "fsType",
            "storagePolicyName",
            "storagePolicyID",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumePath,
            FsType,
            StoragePolicyName,
            StoragePolicyId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumePath" => Ok(GeneratedField::VolumePath),
                            "fsType" => Ok(GeneratedField::FsType),
                            "storagePolicyName" => Ok(GeneratedField::StoragePolicyName),
                            "storagePolicyID" => Ok(GeneratedField::StoragePolicyId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VsphereVirtualDiskVolumeSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<VsphereVirtualDiskVolumeSource, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_path__ = None;
                let mut fs_type__ = None;
                let mut storage_policy_name__ = None;
                let mut storage_policy_id__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::VolumePath => {
                            if volume_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumePath"));
                            }
                            volume_path__ = map.next_value()?;
                        }
                        GeneratedField::FsType => {
                            if fs_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fsType"));
                            }
                            fs_type__ = map.next_value()?;
                        }
                        GeneratedField::StoragePolicyName => {
                            if storage_policy_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storagePolicyName"));
                            }
                            storage_policy_name__ = map.next_value()?;
                        }
                        GeneratedField::StoragePolicyId => {
                            if storage_policy_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storagePolicyID"));
                            }
                            storage_policy_id__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VsphereVirtualDiskVolumeSource {
                    volume_path: volume_path__,
                    fs_type: fs_type__,
                    storage_policy_name: storage_policy_name__,
                    storage_policy_id: storage_policy_id__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeightedPodAffinityTerm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.weight.is_some() {
            len += 1;
        }
        if self.pod_affinity_term.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.WeightedPodAffinityTerm", len)?;
        if let Some(v) = self.weight.as_ref() {
            struct_ser.serialize_field("weight", v)?;
        }
        if let Some(v) = self.pod_affinity_term.as_ref() {
            struct_ser.serialize_field("podAffinityTerm", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeightedPodAffinityTerm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "weight",
            "podAffinityTerm",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Weight,
            PodAffinityTerm,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "weight" => Ok(GeneratedField::Weight),
                            "podAffinityTerm" => Ok(GeneratedField::PodAffinityTerm),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeightedPodAffinityTerm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.WeightedPodAffinityTerm")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<WeightedPodAffinityTerm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut weight__ = None;
                let mut pod_affinity_term__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                map.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PodAffinityTerm => {
                            if pod_affinity_term__.is_some() {
                                return Err(serde::de::Error::duplicate_field("podAffinityTerm"));
                            }
                            pod_affinity_term__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(WeightedPodAffinityTerm {
                    weight: weight__,
                    pod_affinity_term: pod_affinity_term__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.WeightedPodAffinityTerm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WindowsSecurityContextOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.gmsa_credential_spec_name.is_some() {
            len += 1;
        }
        if self.gmsa_credential_spec.is_some() {
            len += 1;
        }
        if self.run_as_user_name.is_some() {
            len += 1;
        }
        if self.host_process.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("k8s.io.api.core.v1.WindowsSecurityContextOptions", len)?;
        if let Some(v) = self.gmsa_credential_spec_name.as_ref() {
            struct_ser.serialize_field("gmsaCredentialSpecName", v)?;
        }
        if let Some(v) = self.gmsa_credential_spec.as_ref() {
            struct_ser.serialize_field("gmsaCredentialSpec", v)?;
        }
        if let Some(v) = self.run_as_user_name.as_ref() {
            struct_ser.serialize_field("runAsUserName", v)?;
        }
        if let Some(v) = self.host_process.as_ref() {
            struct_ser.serialize_field("hostProcess", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WindowsSecurityContextOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "gmsaCredentialSpecName",
            "gmsaCredentialSpec",
            "runAsUserName",
            "hostProcess",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GmsaCredentialSpecName,
            GmsaCredentialSpec,
            RunAsUserName,
            HostProcess,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "gmsaCredentialSpecName" => Ok(GeneratedField::GmsaCredentialSpecName),
                            "gmsaCredentialSpec" => Ok(GeneratedField::GmsaCredentialSpec),
                            "runAsUserName" => Ok(GeneratedField::RunAsUserName),
                            "hostProcess" => Ok(GeneratedField::HostProcess),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WindowsSecurityContextOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct k8s.io.api.core.v1.WindowsSecurityContextOptions")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<WindowsSecurityContextOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gmsa_credential_spec_name__ = None;
                let mut gmsa_credential_spec__ = None;
                let mut run_as_user_name__ = None;
                let mut host_process__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::GmsaCredentialSpecName => {
                            if gmsa_credential_spec_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gmsaCredentialSpecName"));
                            }
                            gmsa_credential_spec_name__ = map.next_value()?;
                        }
                        GeneratedField::GmsaCredentialSpec => {
                            if gmsa_credential_spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gmsaCredentialSpec"));
                            }
                            gmsa_credential_spec__ = map.next_value()?;
                        }
                        GeneratedField::RunAsUserName => {
                            if run_as_user_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runAsUserName"));
                            }
                            run_as_user_name__ = map.next_value()?;
                        }
                        GeneratedField::HostProcess => {
                            if host_process__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hostProcess"));
                            }
                            host_process__ = map.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(WindowsSecurityContextOptions {
                    gmsa_credential_spec_name: gmsa_credential_spec_name__,
                    gmsa_credential_spec: gmsa_credential_spec__,
                    run_as_user_name: run_as_user_name__,
                    host_process: host_process__,
                })
            }
        }
        deserializer.deserialize_struct("k8s.io.api.core.v1.WindowsSecurityContextOptions", FIELDS, GeneratedVisitor)
    }
}
